{"pages":[],"posts":[{"title":"2017年的回顾","text":"2017年，我经历了什么？ 还完了笔记本的分期，有了一台属于自己的MacBook Pro 经历了刚毕业的迷茫期，从零开始开始着手iOS项目 终于从一个参照别人的代码去改改小bug的菜鸡变成了能够独立承担整个模块的菜鸟了 在经历了漫长时间后又重新开始了写博客，用hexo做了自己的Blog，一切重新开始 成功追完了crashcourse的哲学课和知识产权，收获良多 去了一次黄姚古镇，我记得去年也去了南浔古镇，难道我与古镇有缘，出去玩总会跑到古镇去？ 拥有了一台属于自己的PS4,实现了用自己的钱去买PS4的计划 感谢宫崎老贼的怜悯，让我这样的跪在《黑魂1》的手残党竟然通关了《黑魂3》(感谢那位帮我一起打赢了 薪王化身 的太阳骑士，赞美太阳!) 因为横尾太郎而预购了《尼尔-机械纪元》，结果发现，虽然音乐和剧情都是一流，偏偏游戏做的不怎么样，是白金工作室飘了？还是SE没给够钱呢？ 最后发现果然《女神异闻录5》才是17年的天下第一(塞尔达什么的，等我拥有了NS在说吧) 2018的期望呢？仔细看起来，17年算是平实而稳定的度过了。没做什么大事情，但是也没有虚度光阴。那即将到来的2018年，该为自己做下什么约定呢？ 作为2018年可能热门程度最大的两个技术，或多或少都应该去了解，未来离不开它们，即便是做APP的码农也是一样 人工智能 区块链 Swift和Python，前者是iOS开发的未来，后者是人工智能的现在，这些都将是我在2018的学习点 虽然开发native app才是关系到现阶段饭碗的事情，但是我非常喜欢 PWA 的概念，在新的年头我会去了解了解 希望新的一年里能拥有一台NS，玩上《异度之刃2》和《塞尔达传说-荒野之息》 年初不要忘了收入《战场女武神4》！！！！ 最后，祝自己新年快乐！","link":"/2017/12/29/2017-Annual-Summary/"},{"title":"App 上架流程","text":"App 的 上架 和 真机测试，算是App开发流程的最后一步了，那么苹果是如何保证 App Store 上 App 的安全性，以及本地真机测试时苹果是如何授权的呢？ App 上架流程Apple IDApple ID其实就是开发者账号，拥有开发者账户是App上架的必须条件，通常有三种： 账户类型 App Store 上架 测试设备数量 申请条件 个人 支持上架 100 无 公司 支持上架 100 需要邓氏码 企业 不支持上架 100 需要邓氏码 企业账户通常针对的是 公司内部发布App APP 的签名和证书意义：保证APP的稳定性和苹果对其的控制权 当 APP 上传 App Store 后，App Store会对 App 进行加密 和 封装 处理。手机从 App Store 上面下载 App 后，iOS 系统会对 App 进行解密和校验，之后才会安装。 但是，以上的流程 均是 针对 App Store 的行为，加密和解密都是 App Store 完成的。 那么作为开发者，我们不可能每次 真机测试 都通过 App Store 平台来完成这个过程，所以我们通常需要在本地加密，然后用真机中 iOS系统 去解密。 通常本地的加密流程是： 获取本地的 CSR文件，与本地的 p12 一起保证 Certificate 和 Profiles 的本地稳定性和安全。 在开发者平台中，用 CSR文件 创建 Certificate 这个苹果授权的证书。 在开发者平台中，使用相关证书，填写相关 App 的BunldID，和需要安装这个App的真机的 DevicesID，创建对应的 Profiles描述文件。 Xcode项目中添加Profiles后，编译打包。 DevicesID对应的真机便可以通过iOS系统解密安装了。 如果证书需要给其他人用，则将生成的证书下载，在本地安装后导出成p12文件，生成的p12文件在其他电脑上安装，则其他人可以使用这个证书。所以通常在测试和发布证书申请成功并安装后，一定要将证书导出成p12文件好好保存，给其他开发者或者下个开发者使用，其他人直接安装p12就可以安装好对应的相关证书，就不需要再去申请了。 具体流程则是： 先通过本地Mac的钥匙串 中的证书助理，申请CSR文件 按要求填写好后，选择 存储在本地磁盘 CSR文件便获得了，用于申请Certificate证书 打开苹果的开发者平台，选择 Certificate，Identifiers&amp;Profiles 这个选项 左边栏目中，选择 Certificate(证书) 选项，点击添加Certificate 在这个界面就可以创建证书了但是这里的选项很多，App相关的主要就是前三个： 类型 作用 Apple Development 用于开发调试，真机测试 Apple Distribution 用于发布和上架 选择其中一个后，选择本地创建好的 CSR 文件 ，既可以创建证书 CSR文件是本地通过钥匙串获得的，提供CSR文件是为了向开发者平台证明当前的Mac电脑是安全稳定的。 创建成功后就可以看到相关证书信息了 选择 Profile 栏，选择添加 Profile 根据我们的需求，选择需要创建的Profile类型 类型 作用 iOS App Development 创建它需要bundleID+开发证书＋测试设备(在devices中添加) Ad Hoc (临时发布) 包含指定的设备信息，导出的ipa也只能安装到制定的设备中，常用于发布分配给测试人员的测试包 App Store (正式发布) 创建需要bundle ID + 发布证书 然后选择这个 Profile 中，选择需要包含的 App ID 选择对应的证书 选择需要向 Profile 中添加的设备DeviceID 最后给这个Profile文件取个名既可以完成创建。 最后在Xcode中，添加这个Profile，就可以完成这个Profile对应的需求了。 通常在 Debug 栏中，放 Development 描述文件。而 release 栏中，放 Distribution 描述文件。 此外，如果只是个人开发者，其实不需要处理这么烦杂的证书流程，直接将这里的Automatically manage signing 选中，Xcode就会自动生成 开发和发布 所需要的证书，相当轻松。 APP 唯一标识符 UDID UDID的全称是Unique Device Identifier，顾名思义，它就是苹果IOS设备的唯一识别码，它由40个字符的字母和数字组成。iOS 5 之后UDID系统就取消了 MAC Address iOS 7 之后，苹果为了安全问题禁止获取了。 IDFA （常用） IDFA的全称是Identifier for Advertision,中文意思是广告标识符。 同一设备上所有APP的取值都相同 可变不唯一，可关闭（在iPhone中的隐私-&gt;广告，可以修改和开闭IDFA） 如果使用IDFA，注意判断用户是否禁止了IDFA import AdSupport 1234let manager = ASIdentifierManager.shared() if manager.isAdvertisingTrackingEnabled { return ASIdentifierManager.shared().advertisingIdentifier.uuidString } IDFV IDFV的全称是Identifier for Vendor,中文意思是应用开发商标识符。 同一设备上的所有APP的取值一般都是不同的，但是相同应用开发商的值是相同的 这个和 App Store 或者 Bundle ID 来判断的。比如： app的 Bundle ID 是 com.companyName.xxxx,那么只要前缀是com.companyName的app，其获取的IDFV就是一样的。所有com.companyName.test和com.companyName.production获取的值是一样的。 但是，当该公司旗下的 所有APP 都卸载后，再次安装该公司的APP，此时的IDFV会重置。 UIDevice.current.identifierForVendor?.uuidString 第三方的OpenID 很多公司开始对用户设置唯一标识符，这样避开了设备问题。 打包上架当所有条件都已经准备好后，就可以开始打包上架了。 首先在 Xcode 中，选择 Product -&gt; Archive ，这个时候就会显示一个打包界面。 选择 Distribute App，进入打包的下一步 根据选项，选择需要打包的类型 选择直接打包上传AppStore，还是打包到本地 选择自动配置描述文件，还是选择手动配置描述文件。配置完后就是正式的loading界面了 然后打开开发者平台，选择 App Store Connect，进入相关界面后，选择 我的APP，就可以看到之前上传的App了，上面会显示 准备提交 根据页面的提示，完成相应的内容，之后就可以提交审核了 TestFilght苹果官方的应用测试平台。 在开发者平台中，打开具体 APP 的界面后，选择TestFilght,然后按要求添加测试人员。 完成后，测试人员下载 TestFilght 这个APP，通过 测试平台 发放的URL，打开 TestFilght ，则会跳转到对应的APP下载界面，然后就可以下载测试了。 现在的第三方测试平台也挺多的，很多也非常好用，考虑到有时候安卓和iOS会同期发布测试版本，所有很多时候都是使用第三方测试平台的。","link":"/2018/09/01/AppAddAppStore/"},{"title":"Apple Push Notification service","text":"APNs : Apple Push Notification service 的简称，由苹果公司提供的推送通知服务 Apple Push NotificationRemote Notification 远程推送申请推送证书首先确保已经申请好可用的APPID，然后在:“Certificate界面” 的 “Services” 栏目下，找到 iOS Apple Push Notification service SSL (Sandbox) Apple Push Notification service SSL (Sandbox &amp; Production) 前者是测试环境下的推送服务，后者是生产环境下的推送服务。 按提示步骤完成注册后，便可以将证书下载下来，在自己的电脑上双击安装，成功后会自动打开本地的“钥匙串”，然后找到那个安装好的证书，右键导出为”.p12”文件，将这个文件交个后台的推送服务器。 接下来就是本地代码的事情了。 注册推送首先在Xcode ——&gt; TARGETS的Capabilities中找到Push Notifications,然后打开，并确保没有报错。 然后在AppDelegate.swift的application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?)中，对推送进行注册. 123456 // 获取推送通知的权限let settings = UIUserNotificationSettings.init(types: [.alert, .sound, .badge], categories: nil)application.registerUserNotificationSettings(settings) // 注册远程推送application.registerForRemoteNotifications() 然后再完成UIApplicationDelegate中关于推送的协议 1234567891011func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { print(&quot;deviceToken:\\(deviceToken)&quot;)} func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) { print(&quot;userInfo:\\(userInfo)&quot;)} func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { print(&quot;error:\\(error)&quot;)} OK,远程推送的代码就完成了。 Local Notification 本地推送前半部分和远程推送一样，都需要先获取推送权限 123// 获取推送通知的权限let settings = UIUserNotificationSettings.init(types: [.alert, .sound, .badge], categories: nil)application.registerUserNotificationSettings(settings) 后面再根据需求在需要的地方写上推送代码 1234567891011121314application.cancelAllLocalNotifications() let notification = UILocalNotification()notification.alertTitle = &quot;notification&quot;notification.alertBody = &quot;Hey&quot;notification.alertAction = &quot;OK&quot;notification.soundName = UILocalNotificationDefaultSoundNamenotification.applicationIconBadgeNumber = 1// 推送时间 notification.fireDate = Date.init(timeIntervalSinceReferenceDate: 2)// 按着firedate的时间来推送application.scheduleLocalNotification(notification) 原理在远程推送中，要完成推送要分为几步： 首先在程序中，注册APNs(Apple Push Notification servers)推送。 在注册时，项目的bundleID和UDID等信息会发送给APNs。 APNs会生成一个Device Token作为设备令牌给我们。 然后我们将这个令牌给后台处理，方便消息推送。 当需要推送的时候，后台将消息按格式发送给APNs，APNs根据Device Token找到需要推送的设备对象，完成推送。","link":"/2018/07/30/ApplePushNotification/"},{"title":"iOS 开发整理","text":"文章不涉及语言部分，代码部分Objective-C和Swift都有可能使用。 文章内容以APP开发为主，以及开发相关的设计模式、设计规范和相关原理。 iOS 开发整理UI开发UIView (视图)UIView在iOS中则是在屏幕上用来管理一块矩形区域的对象，也是iOS开发中最为基础的UI控件。 开发中UIView的作用常用的有两个： 布局 管理子View 管理区域内的事件 渲染图像和动画 布局主要指的是 View 的大小和位置，依靠的是UIView的 frame 属性。 12UIView *view = [[UIView alloc] init]; // 创建一个UIViewview.frame = CGRectMake(10,20,30,40); // view坐标 (10,20),view的宽高(40,50) 管理子View代表UIView具有容器属性，可以通过 addSubview方法 在一个UIView中添加子UIView。而对于拥有多个子View的复杂View，UIView通常采用的是栈管理来处理所有的同级的子View。当子View出现重叠现象的时候，优先显示的则是后入栈的View。 1234UIView *superView = [[UIView alloc] init]; UIView *subView = [[UIView alloc] init]; [superView addSubview: subView]; 管理区域内的事件是因为 UIView 继承自 UIResponder 。UIResponder 是所有事件响应的基石，为整个事件查找过程提供了处理能力, UIView继承自UIResponder, 也就拥有相关的事件处理能力。因此 UIView 具有响应触摸事件的能力。 渲染图像和动画的特性主要在于 UIView 下面的 CALayer 。CALayer直接继承自NSObject，所以它不具备事件能力，只用于绘制内容，而UIView则是Layer的代理，Layer依靠UIView提供的容器显示绘制内容。CALayer 在iOS中等同一个纹理。CALayer中的content属性就指向了一个缓存区，用于放置bitmap。 UIView也拥有他的生命周期。 在 子View 添加到 父View 的过程中，会经历下面几个函数。 1234- (void)willMoveToSuperview:(nullable UIView *)newSuperview;- (void)didMoveToSuperview;- (void)willMoveToWindow:(nullable UIWindow *)newWindow;- (void)didMoveToWindow; 通过实际的测试我们会知道顺序为：willMoveToSuperview -&gt; didMoveToSuperview -&gt; willMoveToWindow -&gt; didMoveToWindow。先添加到父View上面，最后在Window上面显示出来。 UIViewController (视图控制器)UIViewController，本身包含一个自身的UIView，通常作为一个控制器和容器，管理其下的所有View和子控制器。 开发中，常见与每个界面都有一个属于自己的 UIViewController ，界面内的相关内容都在这个 UIViewController 中处理。 UIViewController的生命周期执行顺序为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354+ (void)initialize { NSLog(@&quot;类初始化方法：initialize &quot;);}- (instancetype)init { self = [super init]; NSLog(@&quot;实例初始化方法：init&quot;); return self;}- (void)loadView { [super loadView]; NSLog(@&quot;加载视图：loadView&quot;);}#pragma mark- life cycle- (void)viewDidLoad { [super viewDidLoad]; NSLog(@&quot;将要加载视图：viewDidLoad&quot;);}- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; NSLog(@&quot;视图将要出现：viewWillAppear:(BOOL)animated&quot;);}- (void)viewWillLayoutSubviews { [super viewWillLayoutSubviews]; NSLog(@&quot;将要布局子视图：viewWillLayoutSubviews&quot;);}- (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; NSLog(@&quot;已经布局子视图：viewDidLayoutSubviews&quot;);}- (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; NSLog(@&quot;视图已经出现：viewDidAppear:(BOOL)animated&quot;);}- (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; NSLog(@&quot;视图将要消失：viewWillDisappear:(BOOL)animated);}- (void)viewDidDisappear:(BOOL)animated { [super viewDidDisappear:animated]; NSLog(@&quot;视图已经消失：viewDidDisappear:(BOOL)animated&quot;);}- (void)dealloc { NSLog(@&quot;释放：dealloc&quot;);} 相关的业务可以在对应的函数中处理。 TabBar样式页面构建TabBar是最常见的iOS视图构建方式，常见于App的底部，由多个按钮组成，点击不同的按钮会切换不同的页面。 我们通常使用UITabBarController来管理TabBar以及用于切换页面的各个UIViewController。 123456789101112// 创建不同的UIViewControlllet firstNavi = UINavigationController(rootViewController: UIViewController())firstNavi.viewControllers.first?.view.backgroundColor = .redfirstNavi.tabBarItem.title = &quot;First&quot; let secondNavi = UINavigationController(rootViewController: UIViewController())secondNavi.viewControllers.first?.view.backgroundColor = .bluesecondNavi.tabBarItem.title = &quot;Second&quot; // 创建TabBarController，并添加需要控制的UIViewControllerlet tabbarViewController = TabBarController()tabbarViewController.viewControllers = [firstNavi, secondNavi] Navigation管理页面跳转Navigation使用 栈管理页面 ，常用两种操作： push pop 1234// 后面的布尔值判断是否需要动画效果navigationController?.pushViewController(NewViewController(), animated: true)navigationController?.popViewController(animated: true) UITableView 的使用delegate 简介delegate是方便iOS开发使用代理模式。 在iOS中，设计者先设计好一套delegate，然后在具体的实际直接调用delegate即可。使用者则按需求实现对应的方法，并让delegate = self即可。 iOS中的delegate是基于协议protocol完成的 1234567891011121314151617181920212223242526272829// A类中设计一个协议，协议中定义相关接口// protocol如果继承了AnyObject表示这个协议只用于Class使用。protocol CheckClickProtocol: AnyObject { func navigationFinish();}Class A {// 创建一个delegate变量方便外部调用，使用weak是避免循环引用(如果protocol没有继承AnyObject则不需要weak) weak var delegate: CheckClickProtocol? func show() { // 在需要的时机调用delegate delegate?.navigationFinish() }}// Class B 继承协议CheckClickProtocolClass B: CheckClickProtocol { // Class B 实现了协议内的方法 func navigationFinish() { print(&quot;跳转完成&quot;) } // 创建Class A的实例，并将delegate赋予self。 A().delegate = self} 这样一个代理也就完成了，当调用delegate?.navigationFinish()，就调用Class B中的实现方法。 UITableViewUITableView 是iOS开发中最常用的组建，用于表示竖列表。 通常有两种Style，左边是Plain模式，右边是Group模式 123456789// 创建一个UITableViewvar tableView: UITableView?tableView = UITableView(frame: UIScreen.main.bounds, style: .plain)tableView?.delegate = selftableView?.dataSource = selftableView?.register(UITableViewCell.classForCoder(), forCellReuseIdentifier: &quot;cell&quot;)// 添加到页面上view.addSubview(tableView!) UITableView的主要功能需要使用 UITableViewDelegate 和 UITableViewDataSource 两个协议来实现的。 UITableViewDataSource 用作操作数据内容 UITableViewDelegate 用于处理滚动和展示的相关逻辑 UITableViewDataSource常用协议方法： 12345678910// 设置每个组有多少行func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int// 设置每行的Cellfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell// 设置有多少组func numberOfSections(in tableView: UITableView) -&gt; Int // 设置每组的组头内容func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? // 设置每组的组尾内容func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? UITableViewDelegate常用协议方法： 123456789101112// 设置每行高度func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat// 设置组头的高度func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat// 设置组尾的高度func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat// 设置自定义组头func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView?// 设置自定义组尾func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&gt; UIView?// 点击事件处理func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) 按照相关协议可以轻松完成相关内容。 UICollectionView 的使用UICollectionView是一种流式布局的表格控件。 UICollectionView的使用逻辑大部分都和UITableView是一样的，但是也有不同点： UICollectionViewCell 必须先regist注册，然后在函数 cellForItemAt 中使用 UICollectionView不是用行来代表每个内容的，而是用的item 1234567891011// 创建布局模式let collectionViewLayout = UICollectionViewFlowLayout()// 创建UICollectionViewcollectionView = UICollectionView(frame: view.bounds, collectionViewLayout: collectionViewLayout)// 设置代理collectionView?.delegate = selfcollectionView?.dataSource = self// 注册CellcollectionView?.register(UICollectionViewCell.classForCoder(), forCellWithReuseIdentifier: &quot;cell&quot;)// 添加到页面上 view.addSubview(collectionView!) 而对应的基本协议： 123456789101112// 设置需要展示的个数func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { return 500} // 设置每个Cellfunc collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;cell&quot;, for: indexPath) cell.backgroundColor = .orange return cell} UICollectionViewLayoutUICollectionViewLayout 是用于生成UICollectionView的所有布局信息的抽象类，所有自定义的用于UICollectionView的Layout都需要继承UICollectionViewLayout。 而UICollectionViewFlowLayout则是由系统提供的一个布局信息。 在Layout中有个三个基本属性： 123456// 设置每个item的大小collectionViewLayout.itemSize = CGSize(width: 100,height: 100)// 设置每行的最小间距collectionViewLayout.minimumLineSpacing = 20// 设置每个item左右之间的最小间距collectionViewLayout.minimumInteritemSpacing = 20 这里值得注意的是，minimumLineSpacing 和 minimumInteritemSpacing 只是代表着最小间距，而不是实际间距，因为itemSize过小时，这个间距会增大，如果itemSize过大时，这个间距会变小，等间距小到minimumLineSpacing或minimumInteritemSpacing时，间距将不会小于这个最小值。 当然，也有更加细致的处理方式，那就是UICollectionViewDelegateFlowLayout，在使用了UICollectionViewDelegateFlowLayout委托后，可以根据里面定义的协议来处理相关内容。 比如： 12345// 处理Item的大小func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { return CGSize(width: 100, height: 100)} UICollectionView 实现瀑布流todo UIScrollView的使用UIScrollView 是开发中最常见的控件之一，用于视图滚动上面。UIScrollView 的原理： UIScrollView等于只显示视图的一部分，其它部分遮罩起来 通过变化UIScrollView的bounds属性来起到移动的效果 class UIScrollView : UIView UIScrollView中有三个基本属性： contentSize contentSize是整个scrollview的可滚动区域 contentOffset contentOffset表示了scrollview的移动 contentInset contentInset用于简单的改变滚动规则（更改滚动区域等） 1234567891011121314151617181920func createScrollView() {// 创建一个ScrollView let scrollView = UIScrollView(frame: CGRect(x: 0, y: 0, width: view.bounds.width, height: view.bounds.height)) // 设置滑动模式 scrollView.isPagingEnabled = true // 设置滑动内容总面积 scrollView.contentSize = CGSize(width: view.bounds.width * 2, height: view.bounds.height) // 重置滑动区域位置 scrollView.contentOffset = CGPoint.zero // 添加内容 for _ in 0...1 { let view = UIView(frame: CGRect(x: 0, y: 0, width: self.view.bounds.width, height: self.view.bounds.height)) scrollView.addSubview(view) } // scrollView 添加到显示页面 view.addSubview(scrollView)} UIScrollViewDelegate当然，UIScrollView也有着一套协议，只要遵循 UIScrollViewDelegate 即可 其中常见的协议内容是： scrollViewDidScroll: 滑动监听 scrollViewWillBeginDragging: 开始滚动时调用一次 scrollViewWillEndDragging:withVelocity:targetContentOffset: didEndDragging前调用,滑动scrollView，并且手指离开时执行。一次有效滑动，只执行一次。 scrollViewDidEndDragging:willDecelerate: 滑动视图，当手指离开屏幕那一霎那，调用该方法。一次有效滑动，只执行一次。 scrollViewShouldScrollToTop: 指示当用户点击状态栏后，滚动视图是否能够滚动到顶部。需要设置滚动视图的属性 scrollViewDidScrollToTop: 当滚动视图滚动到最顶端后，执行该方法 scrollViewWillBeginDecelerating: 滑动减速时调用该方法。 scrollViewDidEndDecelerating: 滚动视图减速完成，滚动将停止时，调用该方法。一次有效滑动，只执行一次 UIScrollView的属性 scrollEnabled ： UIScrollView能否滑动 ， 默认为true 1open var isScrollEnabled: Bool directionalLockEnabled ： UIScrollView是否限制滑动方向，true则为只能单一方向滑动，false则是不限制，默认为false 1open var isDirectionalLockEnabled: Bool scrollsToTop : 点击状态栏后回到scrollView顶部，此属性默认为true，但是同期有多个scrollview时会失效，要将不需要此功能的scrollview及其子类的scrollsToTop设为false 1open var scrollsToTop: Bool scrollRectToVisible:animated: : 在可滚动范围内，滚动到一个未显示区域。 1open func scrollRectToVisible(_ rect: CGRect, animated: Bool) pagingEnabled : 是否支持分页 ，默认为false 1open var isPagingEnabled: Bool bounces : 是否支持弹簧 ，默认支持 1open var bounces: Bool alwaysBounceVertical | alwaysBounceHorizontal : 在bounces为YES时，设置垂直或者竖直反弹是否有效 ，默认均为false 12open var alwaysBounceVertical: Boolopen var alwaysBounceHorizontal: Bool tracking ： 用户按上屏幕时，返回true 1open var isTracking: Bool { get } touchesShouldBegin:withEvent:inContentView: : 在子类中重写，点击屏幕时，如果处于一个可交互的视图上，则调用此函数，并且返回为false的话，该子视图的交互无效 1open func touchesShouldBegin(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?, in view: UIView) -&gt; Bool touchesShouldCancel: 返回值true，发生滚动， touch不在传递给子视图， false则不滚动，touch 传递给子视图canCancelContentTouches： 如果是false ，即使touch move，也不滚动的，如果是true， - tracking后，手指移动，会调用 touchesShouldCancelInContentView 方法； 12open var canCancelContentTouches: Boolopen func touchesShouldCancel(in view: UIView) -&gt; Bool delaysContentTouches : 默认值为true；如果设置为false，则无论手指移动的多么快，始终都会将触摸事件传递给内部控件；设置为NO可能会影响到UIScrollView的滚动功能。 1open var delaysContentTouches: Bool dragging : 在scrollview上面，按着时为true，松开为false 1open var isDragging: Bool { get } decelerating : 抬起手指后，内容是否滑动 1open var isDecelerating: Bool { get } decelerationRate : 手指放开后的减速率 1open var decelerationRate: UIScrollView.DecelerationRate Scroll Indicator 滑动控制器 12345- indicatorStyle //滚动控制器风格- scrollIndicatorInsets //表示滚动指示器从封闭滚动视图中被嵌入的距离。- showsHorizontalScrollIndicator- showsVerticalScrollIndicator- flashScrollIndicators //短暂地显示滚动指示器。 UILable的使用用于展示一行或者多行 read-only 的文字。 class UILabel : UIView 常用属性： text 文字展示 textColor 字体颜色 font 字体型号 textAlignment 对齐方式 backgroundColor 背景色 numberOfLines 最大展示行数 lineBreakMode 文字超出后的，表示省略的小数点出现的位置 sizeToFit() 让UILabel的面积大小去适应文字内容大小，以确保文字能被完全显示 Ex. 123456789101112let showTxt = UILabel(frame: CGRect(x: 100, y: 100, width: 200, height: 50))showTxt.text = &quot;文字展示&quot;showTxt.textColor = .orangeshowTxt.font = UIFont.systemFont(ofSize: 16)showTxt.textAlignment = .leftshowTxt.backgroundColor = .darkGrayshowTxt.numberOfLines = 1showTxt.lineBreakMode = .byTruncatingTailshowTxt.sizeToFit()view.addSubview(showTxt) sizeToFit()可以让UILabell自适应文字，所以当需要文字自适应的时候很好用 Ex. 123456789101112131415let showTxt = UILabel(frame: CGRect(x: 10, y: 100, width: 200, height: 50))showTxt.text = &quot;文字展示&quot;view.addSubview(showTxt) let nextLable = UILabel(frame: CGRect(x: 210, y: 100, width: 0, height: 0))nextLable.text = &quot;下一段话语&quot;nextLable.sizeToFit()view.addSubview(nextLable) let finalLabel = UILabel(frame: CGRect(x: 210 + nextLable.bounds.width, y: 100, width: 0, height: 0))finalLabel.text = &quot;结束话题&quot;finalLabel.sizeToFit()view.addSubview(finalLabel)// 最后三段文字会紧密的挨在一起 UIImageView 的使用UIImageView是一个专门用于显示图像或者动图的类 class UIImageView : UIView iOS中，所有的图片都会被系统封装成 UIImage，然后去用于展示。 常见的封装方式: 12345678// 从 main bundle 中获取资源去封装let image0 = UIImage(named: &quot;home&quot;)// 使用具体的data资源去封装let image1 = UIImage(data: Data())// 按照硬盘文件目录去获取资源去封装，而不是从main bundle中let image2 = UIImage(contentsOfFile: &quot;urlPath&quot;) 创建UIImageView通常有静图和动图两种： 12345678910111213141516// 封装两个图片let image0 = UIImage(named: &quot;home&quot;)let image1 = UIImage(named: &quot;personal&quot;) // 创建一个UIImageView并显示一张图片 let imageView = UIImageView(image: image0)imageView.frame = CGRect(x: 0, y: 300, width: 100, height: 100)view.addSubview(imageView) // 创建一个UIImageView并显示一组动图 let animationImageView = UIImageView()animationImageView.frame = CGRect(x: 100, y: 300, width: 100, height: 100)animationImageView.animationImages = [image0!, image1!]animationImageView.animationDuration = 0.5animationImageView.startAnimating()view.addSubview(animationImageView) 因为图片大小有时候和UIImageView 的大小会不一样，使用UIImageView也提供可选择的适应方式。 scaleToFill 缩放图片，让ImageView完全显示图片 scaleAspectFit 保持图片比例缩放，ImageView会完全显示图片，但是会出现留白 scaleAspectFill 保持图片比例缩放，ImageView不完全显示图片，也不会出现留白 手势和点击UIButtonUIButton是系统自带的按钮控件 class UIButton : UIControl UIButton的使用非常简单: 12345678910// 创建ButtonsearchButton = UIButton(frame: CGRect(x: 0, y: view.bounds.height/2, width: 100, height: 50))// 设置Button在不同状态下的样式searchButton?.setTitle(&quot;点击&quot;, for: .normal)searchButton?.setTitle(&quot;按住&quot;, for: .highlighted)view.addSubview(searchButton!)// 设给button添加点击事件，onClickHandler: 是事件处理函数 searchButton?.addTarget(self, action: #selector(onClickHandler(sender:)), for: .touchUpInside) UIButton是继承自UIControl的，UIControl中iOS主要用于各种事件处理。UIButton继承了UIControl后也拥有了事件处理能力 Target-ActionTarget-Action 是一种事件处理常用 设计模式。比如事件处理中，触发了某个事件后，对应的Target就会去调用对应的Action来处理事件。 比较典型的就是button的点击事件处理: 12//其中 Self 就是 Target，对应的处理函数则是 Action，而touchUpInside则是触发的条件button?.addTarget(self, action: #selector(onClickHandler(sender:)), for: .touchUpInside) UIGestureRecognizerUIGestureRecognizer 是处理手势的基类 class UIGestureRecognizer : NSObject 在任何UIView上面，都是可以添加一个或者多个手势的，然后通过Target-Action来处理事件。 添加手势时需要小心，手势会影响一些系统自带控件的事件响应 常见的手势封装有： UITapGestureRecognizer “点击”手势，可以设置点击的次数 UIPinchGestureRecognizer “捏合”手势，比如可以用来改变图片大小 UIRotationGestureRecognizer “旋转”手势，两指转动 UISwipeGestureRecognizer “轻扫”手势，手指从屏幕上轻划过 UIPanGestureRecognizer “滑动”手势，可以识别拖拽或移动动作 UIScreenEdgePanGestureRecognizer 边缘滑动 UILongPressGestureRecognizer “长按”手势 手势的使用也很简单： 1234567891011func creatGestureRecognizer() { // 创建一个需要使用的UIView let tapView = UIView(frame: CGRect(x: 0, y: 500, width: 200, height: 100)) tapView.backgroundColor = .cyan view.addSubview(tapView) // 创建一个手势，使用Target-Action添加好事件处理 let tapGR = UITapGestureRecognizer(target: self, action: #selector(onClickHandler(sender:))) // 将事件添加到需要作用于的UIView，即可 tapView.addGestureRecognizer(tapGR) } UIGestureRecognizer 也有对应的delegate，可以对其做更加细致的处理 WKWebViewWKWebView是用来在app内显示和处理web内容的控件。 class WKWebView : UIView 使用WKWebView需要导入WebKit框架 123456// 创建webview的配置对象let webConfig = WKWebViewConfiguration()// 创建webviewwebView = WKWebView(frame: view.bounds, configuration: webConfig)// 添加到显示页面上view.addSubview(webView) 加载URL 123if let urlPath = URL(string: &quot;blog.csdn.net&quot;) { webView.load(URLRequest(url: urlPath))} 需要注意的是，WKWebView默认是无法加载http，需要加载https。一定需要加载http的话，可以通过修改或者添加Info.plist中的NSAppTransportSecurity来完成 WKUIDelegate和WKNavigationDelegate要更加细节的出现WKWebView的内容，就需要WKUIDelegate和WKNavigationDelegate两个delegate了。 WKNavigationDelegate 处理跳转和请求相关内容 func webView(_ webView: WKWebView, decidePolicyFor navigationAction: 是否加载请求，用于处理 scheme拦截，js和native通信 以及 特殊处理 func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!); webView完成加载 func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error); webView加载失败，可在此时显示重新加载按钮 func webViewWebContentProcessDidTerminate(_ webView: WKWebView); webView crash 回调 WKUIDelegate 处理UI相关内容 func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -&gt; Void) Alert弹框 func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -&gt; Void) TextInput弹框 func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -&gt; Void) confirm弹框 通过KVO来处理进度条之类的问题KVO 是iOS自带的处理 监听模式 的API。通过为某个对象添加监听者，来监听对象的属性变化。 KVO 的使用容易造成各种循环使用，而且使用繁杂，所以网上有很多安全并且方便的KVO框架来使用 以WebView中的进度条为例： 1webview.addObserver(self, forKeyPath: &quot;estimatedProgress&quot;, options: NSKeyValueObservingOptions.new, context: nil) 为对象 webview 添加一个监听者 self，监听的内容是 estimatedProgress 属性,监听的要求是 NSKeyValueObservingOptions.new (当出现新内容时)。 123456override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { if keyPath == &quot;estimatedProgress&quot; { print(&quot;已经加载 \\(webView.estimatedProgress * 100)%&quot;) }} 通过 observeValue 方法，获取监听的内容。 在 Swift 4 之后，iOS有添加了新的添加监听的方法 1234567891011121314// 创建 NSKeyValueObservation 变量，这个变量必须有var observation: NSKeyValueObservation?fun observationFunc() { // 按照方法提示添加监听 observation = webView.observe(\\WKWebView.estimatedProgress, options: .new) { [weak self] (wkwebview, change) in // 必须使用weak self，不然很容易出现循环引用 guard let self = self else { return } print(&quot;已经加载 \\(change.newValue! * 100)%&quot;) self.progressview.progress = Float(wkwebview.estimatedProgress) }} PS： 在以前的旧版本中，还需要在dealloc中添加 removeObserver 来手动取消监听，但是在xcode7以上，就不需要移除监听者为self的监听了，系统会自动处理。 WebView和Native显示复杂页面开发中，我们经常将 WebView 和 Native 混合使用： 一些多端统一的 富文本 内容，由webview来显示。比如：图文详情 而复杂的控件则让Native来显示。比如：比如视频播放 很多第三方开源项目可以方便我们作相关的混合处理，比如 HybridPageKit 等 iOS动画iOS中的动画核心是 Core Aniamtion。在此基础上，苹果封装了一批简单的、方便使用的动画API。 UIView动画 UIkit组件自带的动画 UIView动画UIView动画是iOS动画开发中最常见的，基本上可以包含我们开发中大部分的动画需求。处理基本的Frame，Alpha，Transform等需求，缺点则是不能自定义动画的中间过程。 UIView动画的设置非常简单: 1234567UIView.animate(withDuration: 1, delay: 0, options: .autoreverse, animations: { let newXpoing = animationImageView.frame.origin.x + 200 let newFrame = CGRect(x: newXpoing, y: animationImageView.frame.origin.y, width: animationImageView.bounds.width, height: animationImageView.bounds.height) animationImageView.frame = newFrame }) { (finish) in print(&quot;是否动画完成:\\(finish)&quot;)} 通过UIView自带的animation方法，duration代表一共需要的时间，delay代表延多少时间开始，options表示动画的类型，后面两个block中，前者animations表示动画结束的状态，后者表示动画结束后的逻辑。 实际上这是最简单的UIView动画，UIView还提供了非常多的动画API方便使用。 CoreAniamtionCoreAniamtion常用语处理要求更高，更加细致的动画。比较常用的几个类是： CABasicAnimation 基础动画 CAKeyframeAnimation 设置关键路径和时间的动画 CAAnimationGroup 简单动画组成复杂动画 CATransition 转场动画 以 CAKeyframeAnimation 为例： 12345678910// 创建一个 CAKeyframeAnimation 对象，并设置keyPathlet keyframeAnimation = CAKeyframeAnimation(keyPath: &quot;transform.scale&quot;)// 设置动画的关键时间点keyframeAnimation.keyTimes = [0, 0.2, 1]// 设置动画的每个关键时间点的关键值大小keyframeAnimation.values = [1, 2, 1]// 设置动画的运行时间keyframeAnimation.duration = 5// 在需要动画的对象上添加动画animationImageView.layer.add(keyframeAnimation, forKey: &quot;scaleAnimation&quot;) 而CAAnimationGroup则是将复杂动画拆解为多个简单动画： 123456789101112131415161718192021// 设置一段简单动画let keyframeAnimation = CAKeyframeAnimation(keyPath: &quot;transform.scale&quot;)keyframeAnimation.keyTimes = [0, 0.2, 1]keyframeAnimation.values = [1, 2, 1]keyframeAnimation.duration = 5 // 设置另一个简单动画 let keyframeAnimationMove = CAKeyframeAnimation(keyPath: &quot;transform.scale&quot;)keyframeAnimationMove.keyTimes = [0, 0.2, 1]keyframeAnimationMove.values = [1, 2, 1]keyframeAnimationMove.beginTime = 5keyframeAnimationMove.duration = 5// 创建 CAAnimationGroup 对象 let animationGroup = CAAnimationGroup()// 设置这组动画的运行时间 animationGroup.duration = 10// 将各个简单动画组合在一起 animationGroup.animations = [keyframeAnimation, keyframeAnimationMove]// 在需要动画的对象上添加动画 animationImageView.layer.add(animationGroup, forKey: &quot;animationGoup&quot;) 这些CAKeyframeAnimation对象中的keyPath，是指的CALayer中的属性 在复杂动画中，还有一种关于粒子效果的动画，在iOS也有着 CAEmitterLayer 类的API去实现，具体情况具体分析。 UITextView &amp; UITextFeild UITextFeild 可编辑的文字输入控件，常见于输入框 UITextView 可滚动展示的文字输入控件，常见于复杂的富文本显示和编辑 123456// 创建 UITextField 对象let inputFeild = UITextField(frame: CGRect(x: 10, y: 150, width: 200, height: 50))inputFeild.backgroundColor = .orange// 设置 UITextField 的默认提示语inputFeild.placeholder = &quot;请输入内容&quot;view.addSubview(inputFeild) 123456// 创建 UITextView 对象let textView = UITextView(frame: CGRect(x: 10, y: 200, width: 200, height: 100))// 给 UITextView 对象 复制 显示内容textView.text = &quot;红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚，红红火火恍恍惚惚&quot;textView.backgroundColor = .yellowview.addSubview(textView) UITextView &amp; UITextFeild 都拥有 becomeFirstResponder() 方法，可以直接将焦点转移到对应的 UITextView &amp; UITextFeild 中，并调起 键盘。inputFeild.becomeFirstResponder() UITextView &amp; UITextFeild 也有各自对应的Delegate，和 UIScrollView 一样，更加细节的操作可以根据Delegate提供的方法来实现。 网络开发系统网络框架APP中的一个基本的网络请求流程是： url字符串通过URL(string:)方法根据相关的协议封装为URL对象 然后通过URLRequest(url:)，添加URL和一些请求参数和设置，封装为一个URLRequest对象，形成一个请求 然后通过系统提供的URLsession去将URLRequest对象发送给服务器。(URLsession接受，发送和处理请求，封装Request为Task，然后做处理) 接受服务器返回的数据 URL格式: 作用:资源定位 https://192.163.0.1:8080/files/net.md?name=&quot;boy&quot;#nose URLsession是iOS网络开发中非常重要的一个区域。主要用于负责接受，发送和处理请求，一个URLsession可以创建多个请求，同时一个app也可以创建多个URLsession，URLsession封装Request为Task，来控制其状态。 一个简单的用于理解的例子就是浏览器，一个浏览器可以打开多个窗口请求不同的网站(URLsession可以创建多个请求)，而且同时一个浏览器还可以同时拥有正常模式和无痕模式(一个app也可以创建多个URLsession)。 URLsession封装Request为Task，而常见的Task有四种: dataTask 处理JSON之类的数据流，也是开发中最常见的类型 downloadTask 处理大数据的下载，查看进度和断点下载等 uploadTask 上传数据 streamTask 流数据 12345678910111213141516func requestHandler() { // 封住URL let url = URL(string: &quot;http://t.weather.sojson.com/api/weather/city/101030100&quot;) // 如果需要设置request，则需要继续封装request。 var request = URLRequest(url: url!, cachePolicy: .returnCacheDataElseLoad) request.httpMethod = &quot;Get&quot; // 系统提供了一个URLSession，除非特殊需要，不用重新创建一个 let session = URLSession.shared // data就是服务器返回的数据 let task = session.dataTask(with: request) { (data, response, error) in let dicStr = String(data: data ?? Data(), encoding: .utf8) print(&quot;data: \\(dicStr ?? &quot;&quot;)&quot;) } // 请求发起 task.resume() } URLRequest 默认为 Get，当为 Get 时，可以设置缓存策略 useProtocolCachePolicy ： NSURLRequestCachePolicy枚举定义了一些常量，这些常量被用来指定当系统处理网络请求时与缓存系统的交互类型。这些常量覆盖了很多需要做的交互，在确定是否已经存在缓存数据用于满足加载请求后做。 reloadIgnoringLocalCacheData ： URL加载的数据应该从来源加载。不应该使用任何现有的本地缓存数据(不论其是否是新的或是有效的)来满足URL加载请求。 reloadIgnoringLocalAndRemoteCacheData ： 不使用本地缓存，且在协议允许的范围内也不使用任何代理以及中介的缓存。 returnCacheDataElseLoad ： 已有的缓存不管是否到期都应该被用来满足加载请求。如果依然没有缓存的数据，请求会从原地址加载。 returnCacheDataDontLoad ： 已有的缓存不管是否到期都应该被用来满足加载请求。如果依然没有缓存的数据，也不会从原地址尝试加载。这种情况一般用于“离线模式”。 reloadRevalidatingCacheData ： 已有的缓存现需要从来源证实有效性，不然需要从原地址重新加载。 所有按照实际情况选择缓存策略。 项目中设计网络层很多iOS开发问题，都可以用中间层来解决。iOS中的网络请求设计也是如此。 在业务方面的网络层，通常有三个要点： 请求接口 数据回调 数据转换 数据缓存 请求接口即网络层调用接口输入参数，通常有两张设计方式。 集中式 所有参数通过一个接口输入。 好处则是参数明确，使用简单。缺点也是请求太多后会变得臃肿复杂。 分布式 设计一个请求基类，然后根据不同的业务设计一个继承自基类的业务请求类，在各自的业务中直接实例化这个业务请求类获取网络数据。 好处非常明显， 让请求网络的业务中，代码量减少，设计更加的优雅轻盈，可扩展性也强。缺点则是当业务非常的多的时候，必然会导致类爆炸，同时维护上百个业务请求类。 数据回调网络层的传输大多以异步加载为主，即服务器响应后由网络层来负责将数据推给上层业务线程。因此，在回调方案中，block delegate notification 均是不错的选择方案，可以根据不同的实际情况做选择。通常情况下 block 使用频率稍高。 数据转换这个其实是一个返回数据处理问题。通常我们并不是将服务端返回的数据直接拿出来用的，而是转换成 Dictionary 或者 Model。而这个返回 可用数据 的过程也是网络层需要处理的地方之一。 数据缓存数据缓存在网络请求中也需要考虑，当请求的数据不是容易变化的数据时，就需要考虑数据缓存问题，将请求成功后服务器给的数据缓存下来，在下次请求时直接使用缓存的数据，这样可以减少流量消耗和请求时间。 数据JSON解析JSON是一种轻量级的、高可读性的、纯文本形式的数据交换语言，传输由属性值或者序列性的值组成的数据对象。也是app网络开发中最常见的数据交换语言。 iOS中也自带了解析JSON的方法。 在OC或者Swift4之前，常用JSONSerialization来实现，将JSON转成NSDictionary 123// data是json对象let jsonDic = (try! JSONSerialization.jsonObject(with: data!, options: .mutableContainers)) as! NSDictionaryprint(&quot;data: \\(jsonDic)&quot;) Swift4之后则拥有Codable来直接编码或者解码JSON。 public typealias Codable = Decodable &amp; Encodable 123456789101112131415// 设置CityInfo遵循Decodable解码协议struct CityInfo: Decodable {// 变量和JSON里面的key也必须是一致的 var city: String var citykey: Int var parent: String var updateTime: String}// 解码JSON对象data, 将其转化成CityInfo对象guard let jsonModel = try? JSONDecoder().decode(CityInfo.self, from: data!) else { fatalError(&quot;`JSON Decode Failed`&quot;)} print(&quot;data: \\(jsonModel)&quot;) 实际上，iOS中的数据使用通常都是 JSON 转成 字典或者数组 然后转成 Model 的过程，最后使用 Model 的过程。 文件管理iOS APP中，每个APP都有有着自己的沙盒。APP之间除非使用苹果提供的特殊方法外，是无法互相访问的。 每个APP的沙盒内，一般包含两个部分： APP自身的内容 〖 Bundles 〗文件 应用配置文件 二进制资源和文件 APP的文件系统(文件内的内容按文件名分类) 〖 Datas 〗文件 Document 可存放体积较大的用户数据 Library 开发者常用，自带缓存文件夹(Cache) 和 用户偏好设置等(Preferences)，还可自定义子文件夹 SystemData 系统文件 temp 临时文件 获取沙盒的方法: NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) NSSearchPathForDirectoriesInDomains是方法宏，documentDirectory是Document文件夹，userDomainMask指用户文件。 FileManagerFileManager是iOS提供的操作文件的管理类。 Ex. 1234567891011121314151617181920212223242526272829303132func conigFile() { // 获取系统自带的 FileManager let fileManage = FileManager.default // 获取 缓存文件 路径 let cachePath = URL(string: NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).first!) // 设置 新文件夹 路径 let dataPath = cachePath?.appendingPathComponent(&quot;WeathAppData&quot;) // 创建文件夹 do { try fileManage.createDirectory(atPath: dataPath!.path, withIntermediateDirectories: true, attributes: nil) } catch { fatalError(&quot;创建失败&quot;) } // 设置 文件 路径 let itemPath = dataPath!.appendingPathComponent(&quot;item&quot;) // 创建文件内容 let itemData = Data() // 创建文件 do { try fileManage.createFile(atPath: itemPath.path, contents: itemData, attributes: nil) } catch { fatalError(&quot;创建失败&quot;) } } 其他的文件移动，删除，拷贝等操作也通过 FileManager 提供的API 来完成。 存储iOS中系统提供了三种储存方式： UserDefaults NSKeyedArchiver 序列化归档 CoreData 数据库 Keychain 密码管理和存储 UserDefaultsUserDefaults 内容存储在系统的 Library 文件夹下的 Preferences 文件夹中。存储对象以轻量级为主，用户设置之类的内容偏多。 123456// 系统自带的UserDefaults单例，按照 key-value的方式存放数据UserDefaults.standard.set(&quot;123&quot;, forKey: &quot;test&quot;)// 系统自带的UserDefaults单例，调用获取value的方法 let test = UserDefaults.standard.value(forKey: &quot;test&quot;)print(&quot;UserDefaults: \\(test ?? &quot;nil&quot;)&quot;) 第三方存储第三方存储中常见的是两个类型 key-value 类型 ： 比如 Realm 等 关系数据库 类型：比如 SQLite，FMDB 等 SQLite是比较基础的跨平台数据库，无论是苹果的CoreData还是第三方的FMDB都对其的封装。 线程进程 创建进程：创建所有必要的管理信息，创建完成后才会加入下一步 就绪：获得了一切需要资源和管理信息 运行：运行状态进程数小于等于系统处理器的总数 阻塞：等待，睡眠 终止：进程结束运行 线程 线程是进程的基本执行单元，进程的任务都是在线程中执行的。其中主线程负责主要的进程任务，在iOS开发中，主线程通常为UI线程。 多线程 多线程常用地方： 网络请求 图片加载 任务执行方式： 串行 并行 多线程执行原理 单核操作系统主要是通过时间片来实现的，两个线程在不同的时间片上交替执行，完成多线程。 多核操作系统是把线程分配给不同的处理器来执行，完成真正的并行。 优缺点 优点： 简化了编程模型：高效的处理大型任务或者零散任务 更加轻量级 提高了效率和资源利用率 缺点： 加强了程序设计的复杂性 占用内存空间（不要乱用多线程） 增加了CPU的调度开销，增加了CPU占有率 iOS中多线程的实现技术方案 pThread NSThread 针对线程 GCD 针对线程队列 NSOperation 对于GCD的面向对象封装 GCD 的使用iOS开发中比较常用的多线程技术，苹果官方说法为：异步执行任务的技术之一。 1234567891011121314151617181920// 获取全局并发队列，执行异步DispatchQueue.global().async { var image:UIImage? do { // 网络请求下载图片 let data = try Data(contentsOf: URL(string: &quot;https://i0.hdslb.com/bfs/article/32d57fcafe36df2896d47be0031b33ab8f46eaad.jpg&quot;)!) image = UIImage(data: data) } catch { fatalError() } if (image != nil) { // 获取主线程队列，进行UI操作 DispatchQueue.main.async { self.topImageView.image = image } } } 自定义队列： 12// label: 自定义队列名; attributes: 使用 并发或者串行let concurrentQueue = DispatchQueue(label: &quot;com.concurrentQueue&quot;, attributes: .concurrent) 网络图片加载缓存异步网络请求的数据图片缓存在网络图片加载中相当重要，将请求成功后服务器给的图片数据缓存下来，在下次请求时直接使用缓存的数据，这样可以减少流量消耗和请求时间，常用用于图片下载。 以常用的第三方图片异步网络图片加载框架 SDWebImage例： 设置一套散列表，将请求的 URL 编码后做为 key 值。 根据 key 值，查找散列表中是否有对应的值，如果用，就根据对应的值在缓存中获取图片数据。 如果没有对应的值，则直接进行网络请求，并将获得的数据缓存，然后设置对应URL的value值。 SDWebImage 的使用SDWebImage 的设计结构： 1234// sd_setImage： 设置图片// URL： url地址// placeholderImage： 占位图imageView.sd_setImage(with: URL(string: &quot;http://www.domain.com/path/to/image.jpg&quot;), placeholderImage: UIImage(named: &quot;placeholder.png&quot;)) cocospods使用pod init 出现bad interpreter: No such file or directory通常为mac升级系统时，可能和导致cocospod不能使用，这时升级一下cocospod即可。 12&gt;$ sudo gem update --system&gt;$ sudo gem install cocoapods -n/usr/local/bin 音视频系统框架 AVKit 和 AVFoundationAVKit (iOS8+ ) 是iOS 提供的用于音视频开发的框架。 提供AVPlayerViewController 提供层级较高的接口 提供创建播放相关的UI内容 常见的点击视频后，打开了一个背景黑色的默认播放界面，那个一般就是AVPlayerViewController。 AVFoundationAVKit 是基于 AVFoundation 封装的框架，如果AVKit无法满足需求，需要对音视频更为底层的控制和自定义，则可以直接使用 AVFoundation。 AVFoundation 有几个关键属性需要认知： AVAsset 资源属性 （各种媒体数据） AVPlayer 播放控制属性 （Controller） AVPlayerLayer 播放画面属性 （View） AVplayerItem AVAsset封装，播放状态属性 （Model） 使用流程： AVplayerItem封装AVAsset，AVPlayer根据AVplayerItem创建播放器，AVPlayer中获取AVPlayerLayer，将AVPlayerLayer添加到需要播放的View的Layer上面。 1234567891011121314151617// 获取URLguard let mp4Url = URL(string: DefineConst.TestMap4Url) else { fatalError()}// 封装URL成AVPlayerItemlet playerItem = AVPlayerItem(url: mp4Url)// 创建AVPlayer// 如果不需要处理AVPlayerItem的属性，可以直接调用：// let playerController = AVPlayer(url: mp4Url)let playerController = AVPlayer(playerItem: playerItem)// 创建AVPlayerLayerlet playerLayer = AVPlayerLayer(player: playerController)// 将AVPlayerLayer添加到需要播放的View的Layer上面playerLayer.frame = avplayerView.boundsavplayerView.layer.addSublayer(playerLayer)// 播放playerController.play() 通常app内，正在播放的视频只会是一个，所以推荐创建一个管理单例去设置视频播放。 KVO和Notification从WebView开始我们就明白用KVO来处理进度条，实际上在视频播放中也是如此，用KVO和Notification来处理部分播放的属性。 Notification的使用方式: 123456789101112131415161718192021// 创建通知中心 NotificationCenter.default// 设置监听方法 test// 设置通知的名字 isTestNotificationCenter.default.addObserver(self, selector: #selector(test), name: NSNotification.Name(rawValue:&quot;isTest&quot;), object: nil)// 实现通知监听方法@objc func test(nofi : Notification){ let str = nofi.userInfo![&quot;post&quot;] print(String(describing: str!) + &quot;this notifi&quot;) }// 点击发送通知进行override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { NotificationCenter.default.post(name: NSNotification.Name(&quot;isTest&quot;), object: self, userInfo: [&quot;post&quot;:&quot;NewTest&quot;]) }// 移除通知deinit { /// 移除通知 NotificationCenter.default.removeObserver(self) } 布局frameframe 是iOS中最基础的布局。通过计算绝对坐标布局视图位置。 AutoLayoutAutoLayout 有别于 frame，不再是绝对坐标，还是变成了描述性质的语言，只需要写上约束条件，然后根据约束条件，系统生成frame去布局位置。 好处： 布局变得简单，特别是可变内容或者屏幕适配之类的 坏处：一定程度上性能不如frame，所以性能敏感的地方不要使用 AutoLayout 布局一般使用NSLayoutConstraint，但是NSLayoutConstraint使用非常烦琐，为了解决AutoLayout的编码复杂问题，苹果推出了VFL语言来方便编码，但是实际上VFL仍然有很多的不足，所以我们通常还是使用第三方库来完成约束。 但是在iOS9 之后可以使用一种新的布局API ： NSLayoutAnchor class NSLayoutAnchor&lt;AnchorType&gt; : NSObject where AnchorType : AnyObject 1234567891011avplayerView.translatesAutoresizingMaskIntoConstraints = false// 给avplayerView添加宽度约束avplayerView.widthAnchor.constraint(equalToConstant: view.bounds.width).isActive = true// 给avplayerView添加高度约束avplayerView.heightAnchor.constraint(equalToConstant: view.bounds.width * 9 / 16).isActive = true// 给avplayerView的顶部和topImageView的底部添加约束，约束值为0avplayerView.topAnchor.constraint(equalTo: topImageView.bottomAnchor).isActive = true// avplayerView的纵向和view的纵向一致avplayerView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true iOS适配分辨率： 逻辑分辨率：直观反应大小和距离，描述显示的单位，例如UIScreen取的屏幕数据就是逻辑分辨率尺寸 物理分辨率：手机屏幕像素大小，物理分辨率越高，色彩丰富度也越高 逻辑分辨率 是 物理分辨率 按照一定的缩放采样形成的。 通常适配采用的是 逻辑分辨率 适配主要有三点： 位置，大小，文字是否按比例适配 图片资源适配 @1x @2x @3x 推荐使用 ImageAsset iPhonex适配 safeArea等 autolayout App间的唤起和通信URL-SchemeScheme一般用来表示协议，比如 http、https、ftp 等，URL Scheme的字面意思理解就是地址协议。 alipay://open?page=payPage&amp;title=pay Scheme: alipay 在移动端Safari浏览器输入以上示例网址就会提示你 在”支付宝”中打开链接吗？，然后由你选择”取消”或”打开”。和HTTP协议格式的URL访问流程进行对比，iOS URL Scheme实际上就是启动一个应用的 URL。 设置方法： 选择项目的 TARGETS，打开 Info栏，找到 URL Type，然后根据提示填写URL-Scheme即可 一般情况下，是会调用先安装的app。但是iOS的系统app的URL Scheme肯定是最高的。所以我们定义URL Scheme的时候，尽量避开系统app已经定义过的URL Scheme。 Universal LinkUniversal Link(通用链接) 是Apple在 iOS9 推出的一种能够方便的通过传统HTTPS链接来启动APP的功能，可以使用相同的网址打开网址和APP。当你的应用支持Universal Link(通用链接)，当用户点击一个链接是可以跳转到你的网站并获得无缝重定向到对应的APP，且不需要通过Safari浏览器。 相对于URL-Scheme，Universal Link更加的常见，通常会开发一个和 原生APP 内容一致的 H5页面，然后这个页面的 url 即是一个 Universal Link，当你打开这个页面的时候，会查看你的APP是否有安装对应的APP，如果有则直接跳转到 原生APP 的对应页面，如果没有则直接显示一样内容的 H5 页面。 使用Universal Link需要到开发者中心配置：找到对应的App ID，在Application Services列表里有Associated Domains一条，把它变为Enabled就可以了。 然后在工程配置中相应功能：targets-&gt;Signing&amp;Capabilites-&gt;Capability-&gt;Associated Domains，在其中的Domains中填入你想支持的域名，也必须必须以applinks:为前缀。 官方配置文档 库iOS 中常见的库 ： 库 Library 静态库 .a文件 动态库 .dylib文件 iOS开发中基本不用 OAuth和OpenID OAuth 授权 提供第三方登录授权，避免在APP输入第三方的账户密码，增强了安全性。比如在APP中使用微信登录的流程。 OpenID 隐藏明文，每个APP独立OpenID在第三方登录中，使用OpenID来标记用户，增强用户的信息的安全性比如用第三方微信登录时，微信会把代表用户的微信号加密成OpenID，来标记用户 日志日志作用日志系统的作用： 定位问题 记录用户的行为操作 记错错误的执行 Crash收集 Debug过程数据 通常日志系统会配合上报，上报后，后台会分析和整理这些日志数据，方便开发者等相关人员查看。 日志系统存储相关日志在本地时，注意在 非主线程&amp;线程安全 通常使用 开源项目 来创建日志系统 ，比如 CocoaLumberjack 等 上报上报技术常见两种： 埋点 在具体的业务代码中添加相应的代码特别：代码侵入，无法更改比如 友盟 的 无埋点 基于Runtime等技术Hoot通用方法，不需要在业务代码中添加内容 特别：动态下发、增加、删除 上报比如 Aspect 的 上报 最好还是使用 公司内部平台 或者 第三方数据平台 比较好。 Crash上报和处理推荐使用 开源项目 ： Bugly / 友盟 等 定位使用系统框架：CoreLocation.framework 可以获取设备的 地理位置，方向 和 海拔 等。 定位授权包含两种： when-in-use authorization: 可以在应用运行期间使用定位服务，可以开启后台运行时扔使用定位，但是不能在获取定位时自动启动应用 always authorization: 可以使用所有的定位服务，如果与定位相关的事件发生时应用没有在运行，会自动启动你的应用并发送定位事件 注意：官方文档中建议只获取when-in-use定位授权 When-in-use 向Info.plist中添加Privacy - Location When In Use Usage Description（或者添加NSLocationWhenInUseUsageDescription键） 创建并配置CLLocationManager对象 调用CLLocationManager对象的**requestWhenInUseAuthorization()**方法即可 1234567891011121314151617181920212223// 创建 CLLocationManager 对象let locationManager = CLLocationManager()func enableBasicLocationServices() { locationManager.delegate = self switch CLLocationManager.authorizationStatus() { case .notDetermined: // Request when-in-use authorization initially locationManager.requestWhenInUseAuthorization() break case .restricted, .denied: // Disable location features disableMyLocationBasedFeatures() break case .authorizedWhenInUse, .authorizedAlways: // Enable location features enableMyWhenInUseFeatures() break } }} Application Extension是 系统和其他APP 交互的扩展，Extension是为APP而存在的，一个APP可以有多个Extension，安装好APP后会自动安装好其自带的Extension。 Extension常见的有三类： Share 分享扩展 Today 今日扩展 Keyboard 键盘扩展 比如：（今日扩展: 将应用的最新消息展示给用户） 使用： 首先File -&gt; New,找到 Target 选项，然后在 Extension 区域，选择自己想要创建的Extension 类型(比如 Today Extension)，然后一个基础的Extension就创建成功了。 Extension创建成功后，会在项目中创建一个和Extension同名的文件夹，里面是UIViewController等文件，可以通过这些修改和添加Extension的内容。","link":"/2020/01/02/Base_for_iOS/"},{"title":"Bit-Computing","text":"位运算是对内存中的数据(二进制数据)直接进行二进制运算操作 Bit-Computing常见位运算符常见位运算符如下： 运算符 描述 &amp; AND 运算 I OR运算 ~ 取反运算 ^ XOR运算 &lt;&lt; 左移运算符 &gt;&gt; 右移运算符 运算方法按位 与 运算例子: 1234567- (void)computering { int a = 10; // 1010 int b = 29; //11101 NSLog(@&quot; &amp; 运算 = %d&quot;,(a&amp;b));}//Log:&quot; &amp; 运算 = 8&quot; 运算方法: 按位依次进行 “与” 运算 运算过程: 123456789101112131415//转换为二进制表示a = 1010b = 11101a &amp; b = {01010-----11101-----01000 //按位依次进行 &quot;与&quot; 运算 ||01000 = 8 // 再转为10进制}// 所以 a &amp; b = 8 按位 或 运算例子: 1234567- (void)computering { int a = 10; // 1010 int b = 29; //11101 NSLog(@&quot; | 运算 = %d&quot;,(a|b));}//Log:&quot; | 运算 = 31&quot; 运算方法: 按位依次进行 “或” 运算 运算过程: 123456789101112131415//转换为二进制表示a = 1010b = 11101a &amp; b = {01010-----11101-----11111 //按位依次进行 &quot;或&quot; 运算 ||11111 = 16+8+4+2+1 = 31 // 再转为10进制}// 所以 a | b = 31 取反运算例子: 123456- (void)computering { int a = 10; // 1010 NSLog(@&quot; 取反运算 = %d&quot;,(~a));}//Log:&quot; 取反运算 = = -11&quot; 运算方法: 单目运算符，按位取反 运算过程: 1234567891011121314//转换为二进制表示a = 1010~a = {1010-----0101 //按位依次进行 &quot;取反&quot; 运算 ||1010 ||1011 = -11}// ~a = -11 例子中，因为 a 是有符号的，所以当取反后发现最高位为负，所以除符号外再次取反加一则为实际的值。 按位 异或 运算例子: 1234567- (void)computering { int a = 8; // 01000 int b = 29; //11101 NSLog(@&quot; ^ 运算 = %d&quot;,(a^b));}//Log:&quot; ^ 运算 = 21&quot; 运算方法: 0^0=0； 0^1=1； 1^0=1； 1^1=0 ：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0 运算过程: 12345678910111213//转换为二进制表示a = 01000b = 11101a &amp; b = {01000-----11101-----10101 = 21 }// 所以 a ^ b = 21 左移运算符 右移运算符例子: 1234567891011- (void)computering { int a = 29; NSLog(@&quot; &lt;&lt; 运算 a&lt;&lt;1 = %d&quot;,a&lt;&lt;1); NSLog(@&quot; &lt;&lt; 运算 a&lt;&lt;2 = %d&quot;,a&lt;&lt;2); NSLog(@&quot; &lt;&lt; 运算 a&lt;&lt;3 = %d&quot;,a&lt;&lt;3);}// log:// &lt;&lt; 运算 a&lt;&lt;1 = 58// &lt;&lt; 运算 a&lt;&lt;2 = 116// &lt;&lt; 运算 a&lt;&lt;3 = 232 运算方式：左移运算符：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。右移运算符：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。操作数每右移一位，相当于该数除以2。 运算过程: 1234567891011121314151617181920//以左移一位为例a = 11101//左移一位11101 =&gt; 111010 = 58 = 29*2//以左移两位为例a = 11101//左移两位11101 =&gt; 1110100 = 116 = 58*2//以右移一位为例a = 11101//右移一位11101 =&gt; 01110 = 14 = int(29/2)//以右移两位为例a = 11101//右移两位11101 =&gt; 00111 = 7 = 14/2 运算常用方式判断奇偶与数字’1’进行与运算，则可以直接判断最后一位的值，而偶数最后一位为0，奇数为1，和’1’于运算后，值为奇数则1&amp;1=1，值为偶数则0&amp;1=0. 12345678- (void)computering { int a = 29; int b = 10; NSLog(@&quot;%d,%d&quot;,a&amp;1,b&amp;1);}log: 1,0 交换两数123456789- (void)computering { int a = 29; int b = 10; a ^= b; b ^= a; a ^= b; NSLog(@&quot;%d,%d&quot;,a,b);}log:10,29 设置可同时赋值多个枚举成员的枚举类似ktype = kType0|kType1|kType2这类的形式。通常的定义为：(iOS版本) 1234567891011//UIView的官方枚举类似UIViewAutoresizing。typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) { UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5}; 我们来看看为什么这样的写法可以做到同时包含的效果。 int在32位上面有4个字节，共32位，为了方便显示，只看最后4位。 其中 UIViewAutoresizingFlexibleLeftMargin 的二进制为：1 &lt;&lt; 0 ： 0001 =&gt; 0010 = 2 其中 UIViewAutoresizingFlexibleTopMargin 的二进制为：1 &lt;&lt; 3 ： 0001 =&gt; 1000 = 8 因此：UIViewAutoresizingFlexibleLeftMargin| UIViewAutoresizingFlexibleTopMargin = 1010 我们设置一个type == 1010. 然后进行比较: 123456789101112131415if(type &amp; UIViewAutoresizingFlexibleLeftMargin) { NSLog(@&quot;UIViewAutoresizingFlexibleLeftMargin包含&quot;);}if(type &amp; UIViewAutoresizingFlexibleTopMargin) { NSLog(@&quot;UIViewAutoresizingFlexibleTopMargin包含&quot;);}if(type &amp; UIViewAutoresizingFlexibleRightMargin) { NSLog(@&quot;UIViewAutoresizingFlexibleRightMargin包含&quot;);}log:UIViewAutoresizingFlexibleLeftMargin包含 UIViewAutoresizingFlexibleTopMargin包含 因为： 1234567891011type = 1010UIViewAutoresizingFlexibleLeftMargin = 0010UIViewAutoresizingFlexibleTopMargin = 1000UIViewAutoresizingFlexibleRightMargin = 0100type &amp; UIViewAutoresizingFlexibleLeftMargin = 1010 &amp; 0010 = (0010 != 0) = YEStype &amp; UIViewAutoresizingFlexibleTopMargin = 1010 &amp; 1000 = (1000 != 0) = YEStype &amp; UIViewAutoresizingFlexibleRightMargin = 1010 &amp; 0100 = (0 == 0) = NO 以上便是原因。 总结位运算作为最为基础的运算方式之一，能完成很多平时不方便完成的操作。增强了平时编码的灵活性。","link":"/2017/12/18/Bit-Computing/"},{"title":"Beego Framework","text":"介绍Beego 是一款用Go语言来开发的应用框架。 安装 安装BeeGo go get github.com/astaxie/beego 安装BeeGo工具 go get github.com/beego/bee bee的可执行文件默认存放在 $GOPATH/bin 里面，所以需要把 $GOPATH/bin 添加到您的环境变量中。 创建项目在$GOPATH/src中，创建项目文件夹，并进入该文件夹中. 输入bee new ProjectName即可创建BeeGo项目。 项目结构: 1234567891011121314151617ProjectName|-- conf| `-- app.conf|-- controllers| `-- default.go|-- main.go|-- models|-- routers| `-- router.go|-- static| |-- css| |-- img| `-- js|-- tests| `-- default_test.go`-- views `-- index.tpl main.go为项目的入口。 Router 路由12345678910package routersimport ( &quot;BeeGoDemo/GoSever/controllers&quot; &quot;github.com/astaxie/beego&quot;)func init() { beego.Router(&quot;/&quot;, &amp;controllers.MainController{})} 注册路由: beego.Router(&quot;/&quot;, &amp;controllers.MainController{}) 这个函数的功能是映射 URL 到 Controller, 然后用户就可以通过访问 这个URL 去执行 Controller 里的逻辑。 Controller 控制器123456789101112131415package controllersimport ( &quot;github.com/astaxie/beego&quot;)type MainController struct { beego.Controller}func (c *MainController) Get() { c.Data[&quot;Website&quot;] = &quot;beego.me&quot; c.Data[&quot;Email&quot;] = &quot;astaxie@gmail.com&quot; c.TplName = &quot;index.tpl&quot;} 例子中，声明了一个控制器 MainController，这个控制器里面内嵌了 beego.Controller，这就是 Go 的嵌入方式，也就是 MainController 自动拥有了所有 beego.Controller 的方法。 然后我们可以通过重写 beego.Controller 的方法来实现一些基本功能。比如例子中就重写了 Get() 方法 而 c.Data 是一个用来存储输出数据的 map，可以赋值任意类型的值。 Model 模型简单应用不会使用，但是复杂应用是必然使用的。 通常用于处理数据关系。数据库的操作通常就写在model文件夹中，models的文件夹下创建model的对象，所有的关于数据库的操作都是在models中进行的，controller调用models中的方法即可。 12345678910111213141516171819202122232425262728package models import ( &quot;github.com/astaxie/beego/orm&quot; _ &quot;github.com/go-sql-driver/mysql&quot;) var ( db orm.Ormer) type UserInfo struct { Id int64 Username string Password string} func init() { orm.Debug = true orm.RegisterDataBase(&quot;default&quot;, &quot;mysql&quot;, &quot;name:pw@/test?charset=utf8&quot;, 30) orm.RegisterModel(new(UserInfo)) db = orm.NewOrm()} func AddUser(user_info *UserInfo) (int64, error) { id, err := db.Insert(user_info) return id, err} View 图层在 Controller 的案例中，有 c.TplName = &quot;index.tpl&quot; 的语句，表示渲染该模板文件，BeeGo中默认支持 tpl 和 html。如果想显示其他的就调用 beego.AddTemplateExt 中设置. 因此，我们可以在 views 文件夹中方式我们需要显示的前端文件。 一个简单的例子，我们讲一个内容仅有 &lt;p&gt;Hi BeeGo&lt;/p&gt; 的HTML文件放在 views 文件夹中。 并在 controllers 的 Get() 函数中修改为 c.TplName = &quot;showIndex.html&quot;，运行项目，浏览器输入网址，就可以显示出一句 “Hi BeeGo” 了。 static文件项目会默认创建一个存放静态文件的目录 1234├── static │ ├── css │ ├── img │ └── js 如果需要加入新的静态文件目录，比如下载视频之类的。也可以通过 SetStaticPath 注册洗的静态文件目录。 beego.SetStaticPath(&quot;/down&quot;, &quot;downloadMovie&quot;) 这样的话，用户访问 http://$path$/down/hahaha.avi ,就会访问 downloadMovie 文件夹下面的视频。 值得一提的是，这个注册必须在 main.go 文件中 beego.Run() 之前加入。 参考文档地址:https://beego.me/docs/intro","link":"/2019/06/20/BeeGo/"},{"title":"计算机科学 - 二进制和算数逻辑单元","text":"现代的计算机和依赖计算机的设备里都用到二进制,而算术逻辑单元主要功能是进行二进制的算术运算。 二进制和算数逻辑单元布尔代数布尔代数（Boolean algebra）是捕获了集合运算和逻辑运算二者的根本性质的一个代数结构。 特别是，它处理集合运算交集、并集、补集；和逻辑运算与、或、非。 布尔代数是计算机的基础和核心。 计算机科学相关的基本操作符号： NOT : ! AND : &amp;&amp; OR : || XOR : ^ 前三个和很常见，而 XOR(异或) 则是稍微少见一点点，简单的理解就是 异或: 比较的两者不相同(有且仅有一个为真) 例如：true ^ true = falsefalse ^ false = falsetrue ^ false = truefalse ^ true = true 二进制数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制 用两种状态来表示信息(true/false) 采用原因： 在电路中比较容易实现 状态稳定 有着现有的逻辑学使用（布尔代数） 通常采用 1 &amp; 0 作为 true &amp; false的表示。 同时二进制也可以表示其他进制的数据： 例如 263 = 2^8 + 2^2 + 2^1 + 2^0 = 100000111 二进制的计算和10进制是一样的，唯一的不同，就是 向前移位的条件不再是满10，而是满2(二进制是逢二进一) 1011 + 1001 = 10100 而这里面的每一个 1 或者 0 在计算科学中被称为 bit(位) 我们常在看到 多少位的计算机，比如 8位计算机(8-bits)，这表示此计算机的操作是 8位8位 来处理的**(即处理数据的时候，每个处理单位大小为 8bits)**。 但是 8-bits 运算能力并不算强，比如在图像处理中，8-bits 也仅仅处理256种颜色，因此 8-bits 画面是不如 24-bits画面清晰 因为 8-bits 属于比较基础的位数，所以通常将 8-bits 成为 byte(字节) 8-bits == 1 byte 1 KB == 2^10 bytes = 1024 bytes 在计算机中，信息使用二进制来表示： 举个例子，我们平时文字所谓的编码(比如Unicode之类)，其实原理上就是一张表，表中为每一个我们会用到的字符都编上了号码，同时这个号码都使用二进制来表示。同时这张表都存在于我们的计算机中。 假设一张表中，我 爱 你 三个字的标号为 1 2 3，那么一个人通过计算机发送“我爱你”给另一个人的时候，实际上传送的信息为 00000001 00000010 00000011,当出现收到这个二进制码后，通过二进制码找到自己计算机中表中的内容，然后将内容显示出来:”我爱你”. ALU (算数逻辑单元)算术逻辑单元（英语：Arithmetic Logic Unit, ALU）是中央处理器的执行单元，是所有中央处理器的核心组成部分，由 与门 和 或门 构成的算数逻辑单元，主要功能是进行二进制的算术运算，如加减乘(不包括整数除法)。基本上，在所有现代CPU体系结构中，二进制都以补码的形式来表示。 ALU有两个单元： 算术单元(AU) 逻辑单元(LU) 在这些单元中，通过不同的电路组合，完成对应的效果。 我们知道在二进制中，1==true , 0==false 0+0=0 1+0=1 0+1=1 这种效果的加法在电路中可以直接用 XOR 来实现。 0+0=0 &amp;rArr; 0^0=01+0=1 &amp;rArr; 1^0=10+1=1 &amp;rArr; 0^1=1 至于1+1,因为在二进制中1+1 != 2而是为1+1=10,这个使用 XOR 则无法完成，通常我们使用 AND 与之配合，组成 半加器 半加器 这样，当A和B都是True时，先通过 XOR 变成 false，并保留，然后在通过 AND 得出 true，最后的结果就是 true false，也就是 10。XOR 得出 和， AND 得出 进位 但是，即便是这个样子，也是不完整，因为我们可能会需要三位计算，比如: 1 + 1 + 1 = 11,这个时候，我们则需要全加器 在半加器的基础上，加上一个半加器，同时用一个 OR 来判断是非需要进位，这样就构成了一个全加器 全加器 当有了半加器和全加器后，三位以上的加法就都可以实现了，因为前两位不需要考虑前面的进位问题，所以前两位使用半加器，之后的位相加，就直接上全加器就行了，后面有多少位就加多少个全加器 多位相加 那么，如果最后一位再次发生进位，而此时已经超出了计算机的位数呢？(比如8位计算机计算，结果出现了进位第九位的情况)，那就是**overflow(溢出)**。 通常出现了overflow(溢出)，不是闪退就是卡死了。 然后在位数增多后，只能不停的加入 全加器 ，这样会让整个单元变得复杂缓慢，因此诞生了 超前进位加法器。 超前进位加法器 在处理 二进制 加法能力上更快 此外，ALU 并非只有加法，通常越复杂，能力越强的ALU的功能也就越多，但是 加法 和 移位 应该是最基础和常见的功能。 整个ALU可以抽象化成下图的方式: 参考 Wikipedia Crash Course Computer Science","link":"/2019/01/30/ComputerScience_ALU/"},{"title":"色彩笔记","text":"在计算机中，计算机本身并不能直接通过名字识别色彩，而是通过数字完成记录的。 色彩笔记色彩基础RGBRGB是一种常见的色彩记录方式。通常有两种表达方式： 向量 eg:RGB(0,0,0) 16进制 eg:RGB(#FFFFFF) 而分别将 16进制 的: 第一个数表示红色 第二个数表示绿色 第三个数表示蓝色 这三个色也就是所谓的三原色 因此,RGB从#000000到#FFFFFF用来表示所有的颜色(每个数字的范围为0~255) HSBHSB是一种使用向量形式表示的三元组 eg: H表示色调(范围是0~360)。这是这种表示方法中，对颜色起决定性作用的数值，既然取值范围是0-360，我们就不难把它想象成一个圆。然后，让X轴逆时针转动，第I象限表示从红过渡到黄；第II象限表示从黄过渡到绿，第III象限表示从绿过渡到蓝，第IV象限表示从蓝到紫再回到红色。 S表示饱和度(范围是0~100)。我们可以把它想象成是颜色的浓淡，值越大越浓，越接近颜色本身，越小越淡。 B表示亮度(范围是0~100)。这个值越大，颜色越明亮，越有助于我们看到要表现的颜色，越小颜色越暗，这个值为0的时候，表示黑色。 HSB通常在工具中表现为色带模式，由红开始，由红结束。 色彩在UI布局中的使用在APP中，通常存在两类色彩： 主色彩：为基本色彩，是给用户整体颜色印象的色彩 次色彩：主要用于交互和突出内容上面 紫色为主色彩，绿色是用于交互的次色彩 但是，次色彩 并非必须存在，在为了营造APP简洁风格的时候，可以只是用主色彩eg. 常用的主色彩谷歌给出了建议： 以及推荐的相关主色彩下的次色彩: 文字搭配色彩设计原则：坚持同一种字体颜色，然后通过半透明度来区分不同级别的字体，不要直接调整文字颜色的RGB值。同时，深色背景用浅色字，浅色背景用深色字。 Icon配合文字Icon和文字搭配在一起的时候，让它和文字保持相同的颜色，然后也通过半透明度来区分图标的状态 用于浅色背景的时候，图标颜色#000000，用54%表示可用状态，38%表示不可用状态； 用于深色背景的时候，图标颜色#FFFFFF，用100%表示可用状态，50%表示不可用状态； eg. 推荐色彩相关网站 dribbble uigradients coolors nipponcolors 笔记参考 泊学网 Material Design","link":"/2018/04/12/Color_Notes/"},{"title":"让自己的开源库支持CocoaPods","text":"在iOS开发中，CocoaPods几乎成了使用第三方库的标配工具，因此我们也可以让自己的公共库也支持CocoaPods。 让自己的开源库支持CocoaPods 最近尝试整理这一年在项目中自己写的一些功能扩展和封装，突然想起来我还没有试过将自己的功能库上传CocoaPods，这样子就算换个项目，只需要Pod install,就能在下个项目中继续使用那些整理好的功能。 因为是第一次尝试，所以就先将一个非常小的原生弹框封装作为使用对象吧。 第一步原本的项目文件结构： 12345678910111213141516171819202122232425262728//需要上传GitHub的文件.├── LICENSE // MIT license├── MyUIDemo│ ├── AppDelegate.h│ ├── AppDelegate.m│ ├── Assets.xcassets│ │ ├── AppIcon.appiconset│ │ │ └── Contents.json│ │ └── Contents.json│ ├── Base.lproj│ │ ├── LaunchScreen.storyboard│ │ └── Main.storyboard│ ├── Info.plist│ ├── SeaNativeHUD // 真正需要让CocoaPods知道的文件夹│ │ ├── SeaNativeHUD.h│ │ └── SeaNativeHUD.m│ ├── ViewController.h│ ├── ViewController.m│ └── main.m├── MyUIDemo.xcodeproj│ ├── project.pbxproj│ └── project.xcworkspace│ ├── contents.xcworkspacedata│ └── xcshareddata│ └── IDEWorkspaceChecks.plist├── README.md //开源库的说明文件└── logo.png CocoaPods强制要求所有的Pods依赖库都必须有license文件，否则验证不会通过。 然后 cd 到这个文件夹里面，使用:pod spec create 你的库名创建一个podspec文件 123456789101112131415161718192021...│ ├── SeaNativeHUD│ │ ├── SeaNativeHUD.h│ │ └── SeaNativeHUD.m│ ├── ViewController.h│ ├── ViewController.m│ └── main.m├── MyUIDemo.xcodeproj│ ├── project.pbxproj│ └── project.xcworkspace│ ├── contents.xcworkspacedata│ └── xcshareddata│ └── IDEWorkspaceChecks.plist├── README.md├── SeaNativeHUD.podspec // 创建一个podspec文件└── logo.png 然后打开这个podspec文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138## Be sure to run `pod spec lint test.podspec' to ensure this is a# valid spec and to remove all comments including this before submitting the spec.## To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html# To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/#Pod::Spec.new do |s| # ――― Spec Metadata ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # These will help people to find your library, and whilst it # can feel like a chore to fill in it's definitely to your advantage. The # summary should be tweet-length, and the description more in depth. # s.name = &quot;test&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;A short description of test.&quot; # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don't worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESC DESC s.homepage = &quot;http://EXAMPLE/test&quot; # s.screenshots = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot; # ――― Spec License ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Licensing your code is important. See http://choosealicense.com for more info. # CocoaPods will detect a license file if there is a named LICENSE* # Popular ones are 'MIT', 'BSD' and 'Apache License, Version 2.0'. # s.license = &quot;MIT (example)&quot; # s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; } # ――― Author Metadata ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Specify the authors of the library, with email addresses. Email addresses # of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also # accepts just a name if you'd rather not provide an email address. # # Specify a social_media_url where others can refer to, for example a twitter # profile URL. # s.author = { &quot;Bob&quot; =&gt; &quot;hgdigm@gmail.com&quot; } # Or just: s.author = &quot;Bob&quot; # s.authors = { &quot;Bob&quot; =&gt; &quot;hgdigm@gmail.com&quot; } # s.social_media_url = &quot;http://twitter.com/Bob&quot; # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # If this Pod runs only on iOS or OS X, then specify the platform and # the deployment target. You can optionally include the target after the platform. # # s.platform = :ios # s.platform = :ios, &quot;5.0&quot; # When using multiple platforms # s.ios.deployment_target = &quot;5.0&quot; # s.osx.deployment_target = &quot;10.7&quot; # s.watchos.deployment_target = &quot;2.0&quot; # s.tvos.deployment_target = &quot;9.0&quot; # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Specify the location from where the source should be retrieved. # Supports git, hg, bzr, svn and HTTP. # s.source = { :git =&gt; &quot;http://EXAMPLE/test.git&quot;, :tag =&gt; &quot;#{s.version}&quot; } # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # CocoaPods is smart about how it includes source code. For source files # giving a folder will include any swift, h, m, mm, c &amp; cpp files. # For header files it will include any header in the folder. # Not including the public_header_files will make all headers public. # s.source_files = &quot;Classes&quot;, &quot;Classes/**/*.{h,m}&quot; s.exclude_files = &quot;Classes/Exclude&quot; # s.public_header_files = &quot;Classes/**/*.h&quot; # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # A list of resources included with the Pod. These are copied into the # target bundle with a build phase script. Anything else will be cleaned. # You can preserve files from being cleaned, please don't preserve # non-essential files like tests, examples and documentation. # # s.resource = &quot;icon.png&quot; # s.resources = &quot;Resources/*.png&quot; # s.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot; # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Link your library with frameworks, or libraries. Libraries do not include # the lib prefix of their name. # # s.framework = &quot;SomeFramework&quot; # s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot; # s.library = &quot;iconv&quot; # s.libraries = &quot;iconv&quot;, &quot;xml2&quot; # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # If your library depends on compiler flags you can set them in the xcconfig hash # where they will only apply to your library. If you depend on other Podspecs # you can include multiple dependencies to ensure it works. # s.requires_arc = true # s.xcconfig = { &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; } # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;end 我们可以发现有很多代码都是注释状态，这些都是先准备好的模板，我们选择我们需要的变量去赋值： 12345678910111213141516Pod::Spec.new do |s| s.name = &quot;SeaNativeHUD&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;A easy function for Native HUD.&quot; s.description = &quot;在iOS上面使用的原生风格弹框组件，对项目代码无侵入，使用简单.&quot; s.homepage = &quot;https://github.com/seabrea/SeaNativeHUD&quot; s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; } s.author = { &quot;seabrea&quot; =&gt; &quot;hgdigm@gmail.com&quot; } s.platform = :ios, &quot;9.0&quot; s.ios.deployment_target = &quot;9.0&quot; s.source = { :git =&gt; &quot;https://github.com/seabrea/SeaNativeHUD.git&quot;, :tag =&gt; &quot;#{s.version}&quot; } s.source_files = &quot;MyUIDemo/SeaNativeHUD/**/*.{h,m}&quot; s.requires_arc = true end 解释一下我所选择的属性： **s.name:**库名 **s.version:**版本号 **s.summary:**简介 **s.description:**描述 **s.homepage:**首页 **s.license:**许可证 **s.author:**作者 **s.platform:**支持的平台及版本 **s.ios.deployment_target:**最低要求的系统版本 **s.source:**源文件的文字 **s.source_files:**选择所允许下载的文件(pod install时下载的文件) **s.requires_arc:**支持ARC **s.dependency:**依赖库 tag =&gt; “#{s.version}” 表示版本号和Tag号一致，这样就可以方便版本控制 – s.source_files的常见写法: 123- &quot;Dic/*&quot; //“*” 表示匹配所有文件- &quot;Dic1/Dic2/*.{h,m}&quot; //“*.{h,m}” 表示匹配所有以.h和.m结尾的文件- &quot;Dic/**/*.h&quot; //“**” 表示匹配所有子目录 此时，第一步就完成了。 第二步接下来，我们需要在GitHub上面创建一个仓库，并把这个项目上传至GitHub上面你准备好的仓库中。 并将为你准备好的这个版本打上Tag 12git tag &quot;0.0.1&quot;git push --tags 也可以使用SourceTree完成上面所有Git相关的操作，原理都是一样的。另外如果你写了(tag =&gt; &quot;#{s.version}&quot;),那tag号和s.version要保持一致。 做完以后我们需要验证验证一下,在有你的podspec文件的目录下输入:pod spec lint 你的库名.podspec --verbose 如果你的那些步骤啊之类的处理错了，此时会报错，大部分错误只需要copy+搜索就能解决。 而你的描述过短之类的问题，则会报警告，但是警告并不影响验证,有时候你可以选择pod lib lint --allow-warnings来忽略警告⚠️。 当最后出现XXXX passed validation时则表示验证通过了。 第三步万事俱备只欠东风。接下来就是发布这个库的时候了。 首先你需要检查下你有没有上传的资格，只有注册后的用户才能上传。 输入pod trunk me来检查一下。如果不能查看到用户信息，则表示你不是用户。 创建用户:pod trunk register 邮箱 &quot;用户名&quot;,创建完成后，进入你填写的邮箱，会收到一个验证链接，点击链接完成验证。 最后一步:pod trunk push 你的库名.podspec 稍微等一下后，如果出错，会有错误提示; 如果成功了，会有恭喜成功的提示。 然后更新一下你的本地CocoaPod Spec库,然后pod search 你的库名,就可以看到你的库了。 总结事实上，将自己的库上传CocoaPods并不麻烦，做好每个步骤可以避免大部分的问题。 最后附上这个库的地址：https://github.com/seabrea/SeaNativeHUD","link":"/2018/12/18/CreateLibToCocoaPod/"},{"title":"计算机原理简介","text":"计算机是由层次结构组成的，每层完成规定的功能。 计算机原理简介简单概括计算机的组成内容 底层，也就是硬件层，通常是 CPU/GPU 内存/硬盘 显示器/键盘； 中层，其实就是以操作系统为主的系统软件层，涉及 操作系统、编译原理和计算机网络等； 顶层，就是应用软件层，基本上以APP为主。 计算机体系冯诺依曼体系将程序指令和数据一起储存的计算机设计概念。（存储型计算机概念） 必须包含五个组成: 存储器：储存程序指令和数据 控制器：控制流程 运算器：数据运算 输入设备：将程序指令和数据送至计算机 输出设备：输出 通常 运算器 和 控制器 处于一个模块，被成为 CPU。 现代计算机体系冯诺依曼体系无法调和存储器速率和对运算器的数据交换的效率。所以脱胎于冯诺依曼体系的现代计算机体系形成了。 现代计算机体系相对于冯诺依曼体系，将 存储器 、运算器 和 控制器 放到了一个模块里面。而这个存储器是专门为CPU提供数据的高效存储器（通常为寄存器和内存），这样大大的提高了CPU的使用效率。 现代计算机 是以 存储器 为核心的。 计算机编程层次计算机编程层次只是方便理解，并非完全固定。 硬件逻辑层 以 与或门 等逻辑电路组成。 微程序机器层 通过 微指令集 编写 微程序(机器指令) 提供硬件使用。 传统机器层 通过 CPU 指令集 编写程序提供给 微程序 使用，引导 CPU 工作等。 操作系统层 提供向上的对接应用接口和操作；向下提供对于指令系统和硬件资源的管理 汇编语言层 汇编语言可以通过汇编器直接将其编译成机器可识别的机器码；汇编语言也是人类可以方便阅读的最底层开发语言，很多语言和程序都是基础汇编开发出来的。 高级语言层 高级开发语言：JAVA之类 应用层 程序翻译和程序解释为了方便开发计算机相关功能，出现了很多的程序语言，来开发基于计算机的功能。但是计算机本身不懂人类的语言，人类也不懂计算机的语言（机器编码），所以需要对开发原因进行翻译或者解释。 程序翻译将开发语言，通过编译器翻译为可以被计算机理解的语言。这个过程叫 程序翻译。需要通过编译器翻译的开发语言，也通常被称为 编译型语言 Ex. C/C++、Objective-C、Go 程序解释还有另一种情况，那就是开发语言的开发内容会被输入到机器码编写的程序，然后直接运行。这个过程被称为程序解释，处理这个过程的就是解释器。这类开发语言也通常被称为 解释型语言 Ex. Python、JavaScript、Php 例外实际上，为了提高效率方便开发，现代语言中很多会选择两种都使用，比如 JAVA 和 C#，它们就是 翻译+解释 的语言。 Ex. JAVA JAVA 首先会编译成为 JAVA字节码，然后通过虚拟机，将 JAVA字节码 解释成机器码 参考 Crash Course Computer Science常见计算机组成原理知识适合大忙人的编程必备基础知识","link":"/2019/12/24/ComputerScienceBase/"},{"title":"字符编码介绍","text":"一个规则,这个规则可以将字符映射到唯一一种状态(二进制字符串)，这就是编码. 字符编码 编码(encode) 解码(decode) encode 是数据转换成另一种形式的过程，类似 某个字符转化成一串二进制数据。 decode就是逆向这一过程。 字符集 字符集是规定某个字符对应某种二进制数据的转换关系。 字库表 字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。编码字符集，即用一个编码值 code point来表示一个字符在字库中的位置。字符编码，将编码字符集和实际存储数值之间的转换关系。 UTF-8和Unicode的关系 Unicode就是上面提到的编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。随着互联网的发展，对同一字库集的要求越来越迫切，Unicode标准也就自然而然的出现。它几乎涵盖了各个国家语言可能出现的符号和文字，并将为他们编号。Unicode的编号从0000开始一直到10FFFF共分为16个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一个Plane，可见UTF-8虽然是一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库， 乱码 解码错误。","link":"/2017/10/24/Encode/"},{"title":"数据结构","text":"数据结构是计算机中存储、组织数据的方式。 数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。 最为常见和基础的数据结构: 栈（Stack） 堆（Heap） 数组（Array） 散列表（Hash） 队列（Queue） 链表（Linked List） 树（Tree） 图（Graph） 常见数据结构栈 栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 栈 通常使用链表或者数组实现。 在iOS开发中最为常见的栈结构就是 导航栏 : 在UINavigationController中，使用pushViewController将一个控制器加入一个数组中，当需要返回上一个控制器的时候，在用popViewControllerAnimated将当前控制器出Pop出数组，再去获取这个数组的最后一个控制器作为返回后的显示控制器。 另外值得一提的是，我们平时接触到的 栈内存 和 栈 并不是同一种东西。 栈内存 是用来存放数据的内存空间，由操作系统来自动分配和管理的，某种意义上为“实际存在的物理结构” 栈 则是一种数据结构，是一种存储和组织数据的方式 队列 队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。按先进先出（FIFO, First-In-First-Out）的原理运作。 队列 通常使用链表或者数组实现。 队列的操作方式和栈类似，唯一的区别在于队列只允许新数据在后端进行添加。 iOS中最明显的队列结构就是莫过于 多线程操作 了 比如我们需要先执行某段代码，然后再执行某段代码。在GCD(iOS多线程技术) 12345678910111213141516171819dispatch_queue_t queue = dispatch_queue_create(&quot;name&quot;, DISPATCH_QUEUE_SERIAL);dispatch_async(queue, ^{ sleep(1); NSLog(@&quot;1&quot;);});dispatch_async(queue, ^{ sleep(3); NSLog(@&quot;2&quot;);});dispatch_async(queue, ^{ sleep(2); NSLog(@&quot;3&quot;);});/// 输出 1 2 3 堆 堆是计算机科学中的一种特别的树状数据结构。 n个元素序列{k1, k2… ki…kn},当且仅当满足下列关系时称之为堆：(ki &lt;= k2i, ki &lt;= k2i+1)或者(ki &gt;= k2i, ki &gt;= k2i+1), (i = 1, 2, 3, 4… n/2) 堆始于堆排序, 堆的实现通过构造二叉堆(实为二叉树的一种). 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。 根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 堆 最常见的地方则是在排序算法中—堆排序 同样的， 堆内存 和 堆 也并不是同一种东西。 堆内存 也是用来存放数据的内存空间，但是通常在操作系统中，一般是由程序员动态分配释放的，堆的大小取决于计算机有效的虚拟内存 堆 则是一种数据结构，和 栈 一样是一种存储和组织数据的方式 数组 数组是由相同类型的元素的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引可以计算出该元素对应的存储地址。最简单的数据结构类型是一维数组。 iOS中的数组 1NSArray *list = @[@(0),@(1),@(2),@(3),@(4)]; 散列表 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数(散列函数)，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数(哈希函数)，存放记录的数组称做散列表。 散列表 和 数组 一样，都是开发中最为常见的数据结构。 iOS中字典的底层就是一个散列表结构（实际上大部分高级开发语言的字典都是散列表结构） 123NSDictionary *hashTable = @{@&quot;key1&quot;:@&quot;content1&quot;, @&quot;key2&quot;:@&quot;content2&quot;, @&quot;key3&quot;:@&quot;content3&quot;}; 链表 链表 是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 单链表: 双链表: iOS中有链表结构的地方，比较明显的就是NSMutableArray拥有一定链表的特性，但是NSMutableArray是否就是底层使用链表却是不确定的，毕竟iOS并不开源。 12345NSMutableArray *list = @[@(0)].mutableCopy;[list addObject:@(1)];NSLog(@&quot;%@&quot;,list);// 输出 0 1 除此之外，AutoreleasePool 则应用到了双向链表结构，AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成，结构如图: 图中的parent指针和child指针则是用于构建双向链表 thread是当前线程 id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置 一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表(双向链表)，后来的autorelease对象在新的page加入. AutoreleasePoolPage每个对象会开辟4096字节内存**(也就是虚拟内存一页的大小)，除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址** 树 树 是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点 没有父节点的节点称为根节点 每一个非根节点有且只有一个父节点 除了根节点外，每个子节点可以分为多个不相交的子树 树里面没有环路 而iOS里面说到树，就不得不提到里面的UI结构了，因为iOS中的UI关系层次就是遵循树结构的 图 图论（Graph theory）是组合数学的一个分支，和其他数学分支，如群论、矩阵论、拓扑学有着密切关系。图是图论的主要研究对象。图是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。 图是一种复杂的非线性结构 图是由顶点和边组成的：(可以无边，但至少包含一个顶点) 一组顶点：通常用 V(vertex) 表示顶点集合 一组边：通常用 E(edge) 表示边的集合 笔记参考 Wikipedia 黑幕背后的Autorelease 腾讯云文档 数据结构与算法：图和图算法(一)","link":"/2019/01/17/DataStructure/"},{"title":"Go 笔记","text":"Go 笔记介绍1234567package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;Hello, 世界&quot;)} Go 安装Mac下，可使用HomeBrewbrew install go然后就可以等待下载安装了。 然后我选择了 VSCode，插件安装中安装Go的开发工具。OK后就可以开始Go的学习了。 Go 的基本语法Hello World如果已经熟悉Swift了，那么Go的很多写法不会让人感觉不习惯。 以一个 HelloWorld.go 文件为例熟悉一下基本结构， 12345678package main import &quot;fmt&quot;func main() { fmt.Print(&quot;Hi\\n&quot;)} package ： 是包名 import ： 导入其他包 func ： 函数 值得注意的几点： 函数的第一个左花括号必须与函数名同行 每行不用分好结尾，规范的代码，每行只会有一句代码 引入了包就必须使用，如果存在未使用的引入包，会编译报错 变量 &amp; 常量 &amp; ioda 变量: var [name] [type] = [content] ==简化==&gt; [name] := [content] 变量创建后是必须使用的，不然报错 常量: const [name] [type] = [content] 常量可以创建后不使用 变量和常量在使用过程中通常可以省略[type] 12345678910111213141516171819func main() { var item int = 1 var num float64 = 0.2 numShort := 0.4 itemShort := 2 fmt.Println(&quot;变量: &quot;,item) fmt.Println(&quot;变量: &quot;,num) fmt.Println(&quot;变量: &quot;,itemShort) fmt.Println(&quot;变量: &quot;,numShort) const numConst int = 100 fmt.Println(&quot;常量： &quot;,numConst)} 常量在使用常量组赋值的时候，第一个元素必须赋值 1234567891011func main() { const ( a = 1 b c ) fmt.Println(a,b,b)} 不然会报错，而且后面的值会等于前一个值，所以上面的例子中，会输出:三个1。 如果想赋值有序常量，可以使用 iota iota 起始值为0，每次增加1 1234567891011121314151617181920212223242526func main() { const ( a = iota b c ) fmt.Println(a,b,c)}// 输出: 0,1,2func main() { const ( a = iota &lt;&lt; 2 b c ) fmt.Println(a,b,c)}// 输出0，2，4 string12var str string = &quot;string&quot;str1 := &quot;string1&quot; 字符串操作: 1234567891011121314func main() { str := &quot;string&quot; // 输出str fmt.Println(str) // 数组str的字节长度 fmt.Println(len(str)) // 字符截取，str[n:m] 的意思是截取 大于等于n 小于m 的子字符串 fmt.Println(str[1:3])} switch和其他语言差不多: 12345678910111213141516func main() { item := 1 switch item { case 0: fmt.Println(&quot;0&quot;) case 1: fmt.Println(&quot;1&quot;) default: fmt.Println(&quot;default&quot;) }}// 输出 数组 &amp; 多维数组 数组： 固定长度（内存中固定长度的内存空间） 多维数组： 一个数组变量中每个元素又是一个数组变量 数组声明: 123var list [3]int = [3]int{1,2,3}arrayList := [3]int{4,5,6} 多维数组声明: 123var list [2][2]int = [2][2]int{{1,2},{1,2}}arrayList := [2][2]int{{1,2},{1,2}} for 循环go中只有这一种循环结构 1234for index := 0; index &lt; 10; index++ { fmt.Println(index)} goto方便跳转: 1234567891011121314151617181920212223242526func main() { for index := 0; index &lt; 10; index++ { if index == 5 { goto testPrint } else { fmt.Println(&quot;go&quot;) } } testPrint: fmt.Println(&quot;hi&quot;)}/* 输出：gogogogogohi*/ slice 切片我将其理解成动态数组 123var list []int = []int{1,2,3}newList := []int{3,4,5} 不同于数组，slice是指针，在申请的时候并不会分配内存。 slice的增删改查 1234567891011121314newList := []int{3,4,5}fmt.Println(newList)newList = append(newList, 1)fmt.Println(newList)newList = append(newList[:1],newList[2:]...)fmt.Println(newList)输出：[3 4 5][3 4 5 1][3 5 1] slice没有直接删除函数，增加和删除都是用append完成，删除本质上是slice的重组 slice可以直接copy 12345678910111213list1 := []int{1,2,3,4}list2 := []int{5,6}// 将list2的值在对应在list1的位置进行copy赋值copy(list1,list2)fmt.Println(list1)fmt.Println(list2)输出:[5 6 3 4][5 6] map创建: 12mapItem := map[string]string{&quot;key&quot;:&quot;value&quot;} 增删: 123456789mapItem := map[string]string{&quot;key&quot;:&quot;value&quot;,&quot;key1&quot;:&quot;value2&quot;,&quot;key2&quot;:&quot;value3&quot;}fmt.Println(mapItem)delete(mapItem, &quot;key&quot;)fmt.Println(mapItem)mapItem[&quot;key3&quot;] = &quot;value3&quot;fmt.Println(mapItem) 匿名函数123456789101112// 最后写一个 () 表示执行func() { fmt.Println(&quot;Hi&quot;)}()// 有参数和返回值// 函数可以作为函数变量来赋值testFnc := func(name string) string { return &quot;你的名字叫： &quot; + name}fmt.Println(testFnc(&quot;Bob&quot;)) 参考：Golang从入门到跑路Go学习笔记-雨痕GO 开源在线阅读大佬给的Go学习路线","link":"/2019/06/17/Go-note/"},{"title":"Flutter基础","text":"Flutter 是谷歌开发的一款多平台构建前端应用的UI框架。可一套代码运行在iOS、安卓和Web上面。 Flutter基础Flutter安装因为之前在App开发方面，主要是从事iOS开发，环境搭建上Flutter和iOS有着一些区别。 在Flutter开发中，windows环境需要下载三个东西： Flutter SDK a. 在官网下载对应的SDK压缩包，解压在非高权限的文件夹内；b. 将flutter\\bin加入 系统环境变量-用户变量 的Path环境变量中。 AndroidStudio 安卓开发环境和安卓打包工具，并在其中安装Flutter和Dart的插件 VSCode (可选) 代码编辑器，安装Flutter的插件即可。 当以上内容都安装好以后，便可以打开命令行，输入flutter doctor指令，就会自动检查环境还缺少的部分，可以根据提示再补全所缺少的内容。 需要注意一点：就是gradle,gradle是安卓开发使用到的一种构建工具，但是很多时候在使用Flutter开发项目使用安卓来调试的时候，会出现gradle构建失败导致无法使用模拟器获取真机调试，通常原因是版本不一致的问题，所以注意gradle和AndroidStudio的版本对应。 Flutter工作区常用文件夹通常比较值得注意的时三个地方: lib文件夹 lib文件夹就是主要存放我们的逻辑和UI代码的地方，类似cocos中的script文件夹 test文件夹 存放测试代码的地方 pubspec.yaml 项目配置文件，比如app name、第三方库依赖 之类的 项目入口在 lib 文件夹下通常会有一个main.dart文件，这个文件就是项目的入口文件。 文件中包含以下重要内容： 12345void main() { runApp(MyApp());}// 可简写为void main() =&gt; runApp(MyApp()); main() 是dart的入口函数 runApp() 是Flutter的入口函数 MyApp() 是自定义的入口组件 =&gt; 用于简写 一个只有一行内容的函数。 Flutter UI层WidgetWidget 的作用类似 iOS 中的 UIView，但是比 UIView 更加的轻量级。 Widget 是 Flutter 中 UI 部分的基石。void main() =&gt; runApp(MyApp()); 中的 MyApp() 所实例化的对象就是一个 Widget。 runApp() 是 Flutter 的入口函数，传入的 Widget 就是当前 界面的 UI 根节点，后续的 Widget 则依次按照代码内容添加到这个 Widget 节点树上面。 常见的基础Widget： Text 应用内创建带样式的文本 Row, Column 水平 (Row) 和垂直(Column) 方向创建灵活的布局。 Stack 按照绘制顺序将 widget 堆叠在一起。 Container 创建一个方形容器 MaterialAppflutter开发APP中常用的符合MaterialApp Design设计理念的入口Widget。MaterialApp会提供一整套符合Material风格的组件。 1234567891011121314151617181920212223242526MaterialApp({ Key key, this.title = '', // 设备用于为用户识别应用程序的单行描述(仅安卓有效) this.home, // 应用程序默认路由的小部件,用来定义当前应用打开的时候，所显示的界面 this.color, // 在操作系统界面中应用程序使用的主色。 this.theme, // 应用程序小部件使用的颜色。 this.routes = const &lt;String, WidgetBuilder&gt;{}, // 应用程序的顶级路由表 this.navigatorKey, // 在构建导航器时使用的键。 this.initialRoute, // 如果构建了导航器，则显示的第一个路由的名称 this.onGenerateRoute, // 应用程序导航到指定路由时使用的路由生成器回调 this.onUnknownRoute, // 当 onGenerateRoute 无法生成路由(initialRoute除外)时调用 this.navigatorObservers = const &lt;NavigatorObserver&gt;[], // 为该应用程序创建的导航器的观察者列表 this.builder, // 用于在导航器上面插入小部件，但在由WidgetsApp小部件创建的其他小部件下面插入小部件，或用于完全替换导航器 this.onGenerateTitle, // 如果非空，则调用此回调函数来生成应用程序的标题字符串，否则使用标题。 this.locale, // 此应用程序本地化小部件的初始区域设置基于此值。 this.localizationsDelegates, // 这个应用程序本地化小部件的委托。 this.localeListResolutionCallback, // 这个回调负责在应用程序启动时以及用户更改设备的区域设置时选择应用程序的区域设置。 this.localeResolutionCallback, // this.supportedLocales = const &lt;Locale&gt;[Locale('en', 'US')], // 此应用程序已本地化的地区列表 this.debugShowMaterialGrid = false, // 打开绘制基线网格材质应用程序的网格纸覆盖 this.showPerformanceOverlay = false, // 打开性能叠加 this.checkerboardRasterCacheImages = false, // 打开栅格缓存图像的棋盘格 this.checkerboardOffscreenLayers = false, // 打开渲染到屏幕外位图的图层的棋盘格 this.showSemanticsDebugger = false, // 打开显示框架报告的可访问性信息的覆盖 this.debugShowCheckedModeBanner = true, // 在选中模式下打开一个小的“DEBUG”横幅，表示应用程序处于选中模式}) Scaffold而 Scaffold 则是方便 MaterialApp 使用的布局组件，实现了基本的 Material Design 可视化布局结构。 12345678910111213141516const Scaffold({ Key key, this.appBar, // 标题栏 this.body, // 用于显示当前界面主要内容的Widget this.floatingActionButton, // 一个悬浮在body上的按钮，默认显示在右下角 this.floatingActionButtonLocation, // 用于设置floatingActionButton显示的位置 this.floatingActionButtonAnimator, // floatingActionButton移动到一个新的位置时的动画 this.persistentFooterButtons, // 多状态按钮 this.drawer, // 左侧的抽屉菜单 this.endDrawer, // 右侧的抽屉菜单 this.bottomNavigationBar,// 底部导航栏。 this.bottomSheet, // 显示在底部的工具栏 this.backgroundColor,// 内容的背景颜色 this.resizeToAvoidBottomPadding = true, // 控制界面内容 body 是否重新布局来避免底部被覆盖，比如当键盘显示的时候，重新布局避免被键盘盖住内容。 this.primary = true,// Scaffold是否显示在页面的顶部}) Scaffold常用属性： appBar 导航栏 body 内容页 bottomNavigationBar 底部tabbar drawer 左侧滑栏 123456appBar: AppBar( title: Text('首页'), // 内容 centerTitle: true, // 是否居中 backgroundColor: Colors.white, // 背景色 brightness: Brightness.dark, // 状态栏类型 ), 1234567891011bottomNavigationBar: BottomNavigationBar( items: [ BottomNavigationBarItem(title: Text('首页'), icon: Icon(Icons.home)), BottomNavigationBarItem(title: Text('个人'), icon: Icon(Icons.person)), ], // tabbarItem实例 currentIndex: selectIndex, 当前选择 type: BottomNavigationBarType.fixed, // 类型 onTap: (index) { // 点击事件 selectIndex = index; }, ), 123drawer: Drawer( child: Text('drawer'), ), 项目配置文件pubspec.yamlpubspec.yaml详细文档 比较常见的几个标签： name 指的是包名 version 通常是 x.x.x+x的形式，version number + build number enviroment 环境配置，通常配置dart的版本信息 dependcies 项目依赖，会编译到项目中 dev_dependcies 项目依赖，仅仅是运行时期的包，不会编译到项目中 flutter Flutter的相关配置，包括asset和font这类静态资源的配置","link":"/2020/12/15/FlutterBase/"},{"title":"如何使用GitHub","text":"最近要给一个新人做一个GitHub的介绍。本次介绍内容主要为两点： 什么是GitHub； 为什么要用GitHub； 如何使用GitHubGit 和 Github首先，需要明白Git和GitHub的关系。现阶段，版本控制有两种常见的管理方式： 集中式，比如 SVN； 分布试，比如 Git. 集中式比较好理解，就是提供一台中央服务器，这台服务器存放代码和版本的相关信息。开发者可以随时将新代码提交给这台服务器，当然也可以通过更新操作获取服务器上的最新代码，从而保持与其他开发者所使用版本的一致性。 分布式则不一样，其更加强调个体，每个人可以在本机拥有一个git仓库的克隆，可以在本地修改和提交，然后将其修改推送给负责人或者其他协助开发者，反之也可以拉取其他人的修改，更新自己仓库的代码。 但是，为了和远程的多名同伴协助开发，即便是使用Git，通常也是需要一台服务器来储存代码，作为中央资料库。但是服务器的成本并不低，于是就有很多第三方公司来提供这个中央资料库来方便使用Git的人来托管代码。GitHub便是其中之一，因为其公共仓库的免费，很多人都将自己的开源项目在其托管，由于非常多的开源项目聚集，所以Github已经不仅是一个代码托管网站，同时也是方便大家学习的一个开源源码学习地。 2018年6月4日，微软收购来了GitHub托管平台。 Github 的使用首先，Github是一个托管网站，所以必须有一个属于自己的Github账户。 创建项目Github上面创建项目非常简单。点击一个非常明显的 NEW 按钮就可以进入创建界面。 然后依次输入自己的: 仓库名 Repository name 仓库描述 Description 仓库的属性 Public(所有人都能够看到) / Private(只有自己和同伴能看到) 是否添加一个readme文件 是否添加一个版本控制忽略文件gitignore 是否添加一个代码版权协议 完成上面的步骤后，一个Github仓库就创建好了，然后找到clone按钮，获取该仓库的克隆连接。将其clone到本机。 假设创建好的仓库的远程连接为 https://github.com/somebody/demo.git然后在确保本机已经拥有git环境的情况下，命令行进入准备存放仓库的文件夹中，然后输入：git clone https://github.com/coderZYGui/ZYLottery.git就可以将这个远程仓库克隆到本机制定的文件夹了。之后我们的开发就在这个本机的仓库中进行，然后将本地的修改推送到这个远程的GitHub仓库，或者拉取这个仓库，获取其他人提交的修改来同步代码。 查看代码在仓库首页，仓库名下方有个一排菜单，分别是 Code Issues Pull request Actions Projects Security Insights 在Code界面，可以看到当今的代码文件目录，和分支，通过切换不同的分支，来看不同的代码目录。 加粗的部分是比较常用的菜单。 Issues评论区，可以在这里对这个仓库评论，或者和其他开发者进行交流。 Pull request合并界面，在这个界面，你可以操作分支进行合并。比如你的同事将自己开发的分支，准备合并到主干分支上面去，你就可以在这个地方进行操作。 fork在查看其他的开源项目的时候，会方向右上角有着 What Star Fork 三个选项，前两个比较好理解，最后一个是什么意思呢？ fork通常在我们希望参与其他的开源项目的时候使用，我们使用fork后，GitHub会自动Clone出一个仓库放在我们自己的远程仓库中，然后这个仓库中也拷贝了一份我们fork对象的全部源文件。这个时候我们可以对其进行修改，然后将自己修改的内容通过请求合并给fork对象，以此来参与开源项目。 Git 操作指令图","link":"/2020/10/05/HowToUseGithub/"},{"title":"iOS-组件化","text":"当项目越来越复杂的时候，平时的通用方案就不太实用了，这个时候就需要对项目组件化了。 组件化这个东西其实并不复杂，本质上是一种app架构思路。 iOS-组件化 目录： 本地私有库 远程私有库 组件化方案 本地私有库创建一个文件夹，并在这个文件夹下执行命令： pod lib create XXXX (XXXX为你准备创建的库的名字) 然后完成选项，即可创建完一个本地库。 然后将需用的代码文件，添加到对应的文件夹中，并删除ReplaceMe.m文件 最后一步，cd 到库中的Example文件下，然后pod install下，更新Example项目的pod，步骤完成。 远程私有库找到库的podSpec文件，并完成相应的修改。 同时创建远程代码库(比如GitHub)，将相应的代码提交至这个代码库。 前往文件夹 ~/.cocoapods/repos打开终端，在终端切换到当前目录下，然后进行pod repo add操作在终端输入:pod repo add XHMSpec https://github.com/xxxx.git(远程Spec仓库的地址) 向私有的spec Repo远程仓库中提交podspec. 12# pod repo push [Repo名] [podspec 文件名字]$ pod repo push SEASpec Test.podspec 然后就可以在项目中使用了： 12source 'https://github.com/seabrea/SEASpec.git'pod 'LocalPrivateLibrary' 总结：设置两个远程库，一个作为Specs文件库，一个作为代码库，并处理好两者关系。项目使用时的Source使用的是Specs的git地址。 组件化方案由于项目开发时间变长后，项目各个业务，各个类直接的互相引用会增多。整个项目的也会变得越来越臃肿，结构也开始不清晰。这个时候则要开始对项目组件化了。 讲各个业务模块和基础课拆分成一个一个组件，每个组件是 独立的业务或者功能单位。组件则使用CocoPods来管理。 Target - Action那么，为了做到解耦，组件间的调用则是一个大问题。现在比较火热的方案则是 CTMediator CTMediator让组件之间放弃直接调用。同一个Mediator(中间件)来处理这个问题。 为了应对解耦问题，使用了Target - Action+runtime的方式。 以模块A调用模块B为例。 首先为被调用方(模块B)，添加一个类，用于target-action处理。 12345678910/* * 创建一个 Target_XXXX 的类 * 类中提供一个 Action_XXXXX 的方法用于外部接口 */ @interface Target_B : NSObject- (UIViewController *)Action_NavigationViewController:(NSDictionary *)params;@end 而在这个类中，可以自由的使用#import来获取需要的对象。**(模块内部-高内聚，模块外部-低耦合)** 12345678910#import &quot;Target_B.h&quot;#import &quot;BViewController.h&quot;@implementation Target_Shop- (UIViewController *)Action_NavigationViewController:(NSDictionary *)params { return [[BViewController alloc] init];}@end 随后为中间件添加一个分类，方便调用方调用。 12345678910111213#import &quot;CTMediator+BViewController.h&quot;NSString * const TargetVCName = @&quot;B&quot;;NSString * const TargetActionName = @&quot;NavigationViewController&quot;;@implementation CTMediator (BViewController)- (UIViewController *)mediator_ShopViewController { UIViewController *vc = [self performTarget:TargetVCName action:TargetActionName params:nil shouldCacheTarget:NO]; return vc;}@end 分类中，使用CTMediator来查询到Target-Action服务类，来完成调用模块B(本质上使用runtime找到target类，并向类中的action方法发送消息)。 总结： 优点：target-action方法的确可以做到高度解耦，完成组件化。 缺点：组件增多后，中间件会变得非常臃肿，使用上也会避免麻烦。 URL - Scheme在APP内模拟 URL-Scheme 跳转。 URL - Scheme 的方案实现非常简单，就是通过中间层注册URL，将URL和一个Block使用Key-Value的方式储存下来，Block中实现相关Class内容。 Protocol - ClassProtocol - Class方案的实现和 URL - Scheme 很像，都是通过中间层注册，但是该方案中，注册的Key-Value则是 Protocol 和 Class，然后把创建 Class 的相关函数写在协议中。这样避免了硬编码问题。","link":"/2018/11/02/IOS_ComponentBased/"},{"title":"iOS-学习基础和文章推荐","text":"文档用于更好的规划好自己的 iOS 学习, 准确的定位的目前所处的位置，以及文章的查找。 Objective-C 2.0 Swift 5.0 iOS-学习基础和文章推荐基础语言国内主流的 iOS开发 语言是Objective-C 和 Swift。Objective-C 熟悉语法是基本要求，同时也需要去了解它的对象模型，动态机制等特性。Swift 则作为现在苹果的官方推荐语言，更应该去好好的使用。 框架Objective-C 方面： 基本框架：Foundation / UIKit等， 苹果封装好的框架 HealthKit 等， 各种常用的第三方框架 SDWebImage AFNNetWorking YYKit等，并熟悉其内部的实现，尽可能的做到明白一个框架是怎么实现的再去用它。 `Swift 方面： 仍然是推荐使用苹果的基本框架：Foundation / UIKit等，但是注意避免使用Objective-C的相关内容，尽量使用Swift的Foundation内容。〖比如优先Array和String等，少用NSArray和NSString等〗 Swift的开源项目也越来越丰富，推荐使用以Swift推进的开源项目： SnapKit、Kingfisher、Alamofire 等。 网络客户端里最常见的对于网络的使用： 从网络拉取数据，存储到本地文件系统； 再从本地取出来放进内存，最后渲染出来。 所有的处理都在操作系统的进程和线程中执行。 熟悉http / https / dns等几个协议，了解 https 的原理，处理运营商劫持 dns 劫持等情况，另外需要处理好各种异常情况做好重试机制，iOS 作为移动端网络不稳定，要看情况优化弱网络下的连接，做好离线机制，以及注意避免耗费太多流量。还有客户端跟后台的通信协议，数据结构一般用 json ，由于客户端本地会保存一部分内容，很多 APP 都会需要做数据的增量更新。 储存sqlite，sqlite 作为存储引擎是大多数 APP 的核心，也是性能优化的关键点，最基本的需要知道主键索引事务等数据库基本概念，再深入需要了解具体的 存储机制 / 索引的实现 / sqlite的七层结构 等，才能在遇到问题时找到最佳的解决方案。客户端上 nosql 用得较少，除了 sqlite 一般就剩单文件存储，XML存文件或对象序列化成二进制存储，也是常用的存储方式，近期有 realm 这种新型数据库，也值得了解一下。 内存内存方面，需要了解 Objective-C 的引用计数、 ARC 机制、自动释放池等相关点，另外需要注意避免内存泄露，管理好客户端的缓存，避免缓存太多导致问题，或缓存命中率太低性能低下。 渲染渲染方面主要是文字和图像，基础上文字方面 UIKit 已封装得很好，CoreText也提供了更自由的排版渲染方式，图像渲染只需要注意解压时机，再深入需要了解 iOS 具体的渲染机制，像图层混合，渲染时机，离屏渲染等，才好做更多的优化。 线程线程和进程方面，iOS 开发只在做 Extension（扩展） 时才需要考虑到进程，一般只需处理好线程，需要了解主线程子线程，多线程并发锁竞争，死锁，GCD，Runloop 等知识点。 文章和博客组件化iOS 组件化方案探索 解读 iOS 组件化与路由的本质 iOS 组件化 - 私有库创建 Runloop解密 Runloop iOS - Runloop Runtime神经病院Objective-C Runtime出院第三天——如何正确使用Runtime 多线程iOS 如何高效的使用多线程 我所理解的 iOS 并发编程 iOS 多线程之线程安全 OC对象模型iOS底层原理总结 - 探寻OC对象的本质 Objective-C对象模型 内存管理iOS Memory 内存详解 Block我所理解的Block/ KVC\\KVOiOS底层原理总结篇– 深入理解 KVC\\KVO 实现机制 网络层设计谈谈 iOS 网络层设计 自己动手写一个 iOS 网络请求库 写给 iOS 开发者看的 HTTPS 指南 iOS应用架构谈 网络层设计方案 事件传递和响应史上最详细的iOS之事件的传递和响应机制-原理篇 实现一个优雅的iOS消息总线 混合开发自己动手打造基于 WKWebView 的混合开发框架 从零收拾一个hybrid框架（一）– 从选择JS通信方案开始 Hybrid 实战：如何完整下载一个 wap 页面 测试优化关于iOS 性能优化梳理 iOS调试进阶-更高效的使用Xcode和LLDB APPiOS 签名机制 SDWebImage分析","link":"/2019/01/30/HowToLearniOSBase/"},{"title":"iOS-剖析UIView","text":"UIView在iOS中则是在屏幕上用来管理一块矩形区域的对象，也是iOS开发中最为基础的UI控件。 iOS-剖析UIView Layer UIResponder UIView看起来很复杂，但是实际上功能却非常的明确： 绘制图案和动画 [CALayer] 在其矩形范围内，使用UIKit或者Core Graphics来绘制图画。 某些视图的属性可以设置新的动画状态 布局和子视图管理 视图可以作为父容器，包含多个子视图 视图可以调整子视图的大小和坐标 使用自动布局可以在大小坐标改变时自动适应新变化 内容交互和事件响应 [UIResponder] UIView继承自UIResponder，因此UIView具有响应触摸事件的能力 UIView也可以使用手势管理类来处理常见手势事件 Layer视图中用于渲染的核心动画层。 声明:@property(nonatomic, readonly, strong) CALayer *layer; CALayer直接继承自NSObject，所以它不具备事件能力，只用于绘制内容，而UIView则是Layer的代理，Layer依靠UIView提供的容器显示绘制内容。 常见属性： 1234567891011121314151617181920212223242526//宽度和高度@property CGRect bounds;//位置(默认指中点，具体由anchorPoint决定)@property CGPoint position;//锚点(x,y的范围都是0-1)，决定了position的含义@property CGPoint anchorPoint;//背景颜色(CGColorRef类型)@property CGColorRef backgroundColor;//形变属性@property CATransform3D transform;//边框颜色(CGColorRef类型)@property CGColorRef borderColor;//边框宽度@property CGFloat borderWidth;//圆角半径@property CGFloat cornerRadius;//内容(比如设置为图片CGImageRef)@property(retain) id contents; CALayer 在iOS中等同一个纹理。CALayer中的content属性就指向了一个缓存区，用于放置bitmap。 隐式动画：同时，每个UIView都有一个rootLayer来显示绘制内容。但是，当对非RootLayer的部分属性进行修改时，默认会自动产生一些动画效果而这些属性称为AnimatableProperties(可动画属性)。 UIResponderUIResponder是所有事件响应的基石，为整个事件查找过程提供了处理能力, UIView继承自UIResponder, 也就拥有相关的事件处理能力。 12345678910111213//常见事件类型typedef enum { //多点触摸事件 UIEventTypeTouches, //行动事件 UIEventTypeMotion, //远程控制事件 UIEventTypeRemoteControl, } UIEventType; 事件链 首先是点击View后会产生 Event，Event会向底层传递并被Application接收到后加入事件队列。之后在开始在视图中 自上而下 开始查询 UIWindow接受到事件开始进行最优响应视图查询的过程(逆序遍历subviews，即优先查询后addsubview的子视图) 如果在hitTest &amp; pointInside过程中查询到最优响应视图则后续对于其他subviews遍历查询则会停止 123456//判断当前点击事件是否存在最优响应者(First Responder）- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;//判断当前点击是否在控件的Bounds之内- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; 响应者链响应者链 其实是由一个个UIResponder的子类构成的，UIResponder是系统一个负责接受和处理事件的类。而 响应者链 就是由最优先响应视图和一系列“下一个响应者”组成。 与查询最优先响应者不同，响应者链是 自下而上 的。 如果最优先响应者能响应处理事件，则传递结束，不能就会传递到下个响应者，通常为视图的SuperView。 但是也有特例，比如比如UIViewController的根视图self.view的nextResponder是其所在UIViewController。而如果UIViewController如果是UIWindow的根控制器，那么它的nextResponder就是UIWindow，但如果UIViewController是另外一个 UIViewController present出来的话，那么它的nextResponder就是之前所执行present操作的那个UIViewController。 总之： 事件分发与传递:自上而下 事件响应:自下而上","link":"/2018/10/30/IOS_UIview/"},{"title":"如何更好的自主学习？","text":"自主学习是教育的最高境界，而一些方法则可以帮助有效的自主学习 记笔记 预习 规范方法 记录的方法 集中精神 不要在学习的时候同时做多件时期 选择一个环境 注意时间 记忆 回忆 别死磕 番茄时间 记笔记第一点预习通常在教育中(非自学)中使用，目标并不是学会准备学习的内容，而是大概了解即将学习的内容是什么，然后根据预习(或者教材)给内容定一个简单的目录和分类，用作学习的时的笔记。 123456789example:1. XXX定义2. XXX的分类3. XXX的用途4. XXX的原理5. XXX的例子 第二点注意归档通常在讲解一个东西的时候，注意按一定的归档方法，将内容记录下来。 123456789术语和定义：首先记录下东西的定义。(具体是个什么东西)实现思想：然后记录下这个东西的思想是什么？(什么思想做出来的，MVC？面向对象？)具体例子: 能够方便理解和复习的一个例子回顾总结: 总结内容，并思考其对于自己的作用 第二点记录的方法 大纲法：将内容分门别类的记录下来， 列好一级内容，二级内容，类似API文档的那一张。(个人比较常用) 康奈尔法：将内容分为三部分，1.课上讲的内容；2.自己想到的但是不明白的内容；2.复习时解决并总结的内容。(感觉这个对于现阶段的我不怎么实用，这个更加实用还在读书的同学们) 思维导图: 这个没什么说的了(我个人比较喜欢这个) 集中精神不要在学习的时候同时做多件时期我们的大脑实际上更像是一个 单核单线程 的CPU，当我们在同时做多件时期的时候，实际上是一个并发过程，并非并行。大脑通过来回的调度来实现多线程(参考并发原理)，这样，虽然我们虽然能通过多线程完成任务，但是实际上我们的效率和学习时间都受到了影响。在学习的角度上讲，这是一个不划算的事情。而且多线程有加剧CPU温度和Crash的危险(此时大脑变得疲劳 和 此时完全不想学习了的危险) 选择一个环境选择一个 能导向你的注意力 去往 一个你想要的方向 的环境。这句话有点绕，简单点：就是你让你的学习环境让你感觉需要学习。 举个例子： 如果你想要健身，就可以去健身房，因为在健身房里，你会下意识的选择健身而不是玩手机 如果你想要学习，你就可以去图书馆，因为那里的气氛会督促你向学习的方向走 但是这些环境不是绝对，每个人都有自己的适应环境，有些人喜欢咖啡厅，有些人喜欢地下室，反正找一个能让自己进入状态的环境就可以了。(PS. 说句实话，对于我这种在外漂泊的汉子来说，这个环境设置是挺麻烦的，因此我只能选一个尽量让自己不会分心的环境，比如断网) 注意时间人的大脑和人的肌肉一样，都是在使用后会疲劳的，因此无休止的学习和强制集中注意力是效果很不好的，应该给自己设置一个时间，在时间结束后，就应该选择休息。让大脑舒缓下来。网上的专注学习时间的推荐是25~30分钟，这个看个人的习惯而定，但是休息是必要，请不要忽略。 记忆记忆是最重要的学习技能之一，但是也是最简单的。因为记忆毫无道理可言，你付出了多少才会收货多少。 回忆回忆是加强记忆的一种最好的方法之一，如果在学习了某项事物之后，每隔一段时间最好进行复习，这样才能加强记忆。而这个间隔的时间在刚开始的时候设置的毕竟短，然后随着时间的流逝，这个间隔的时间逐步加长。类似现在流行的一些学习 英文单词APP 的使用的方法。在各个领域都挺好用的。 别死磕这个适合于平时学习一些理科知识的时候很好用，当前你可能发现某个公式异常的学习痛苦，在使用了各种方法后毫无进展，在时间允许的情况下可以先放下，等个两三天后再来学习，就会突然发现柳暗花明。 番茄时间流程如下： 确定任务，并将其分割(工作编码时分割模块任务) 设定时间，通常为工作25分钟，休息5分钟，为一个单位(在25分钟中期间集中注意力，抵制分心冲动) 单位不可分割，不存在半个单位，一个单位开始就必须完成(除非意外，比如开会) 四个单位完成后可以进行一次长时间休息,通常可设定为半个小时(视个人情况而定) 参考: YouTube CrashCourse","link":"/2017/12/09/Howtotakenotes/"},{"title":"Objective-C对象模型","text":"在OC中，每一个对象都有一个名为 isa 的指针，指向该对象的类。这个类描述了一系列它的实例相关内容，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。 Objective-C中对象的定义123456typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY;}; 通过看NSObject.h文件可以知道，基本上包括Class isa指针的都可以被称为对象 经典OC对象模型图 Objective-C中对象的初始化 如何初始化 Class *obj = [[Class alloc] init]alloc申请下一块内存给对象(alloc不只分配在虚拟内存，同时会在物理内存建立映射)init初始化相关的信息 123Class *obj = [Class alloc];obj = [obj init]; 12345678- (instancetype)init { self = [super init]; if(self) { //此次完成相关自定义的初始化信息 } return self;} OC对象在内存中的结构OC对象在内存中的三个部分 isa结构体指针 类型信息 函数指针 父类的部分 父类的成员变量 自己类的部分 自己类的成员变量 C++对象(对比)一样的分为三部分 虚函数表 父类部分 自己的部分 ps: SEL: SEL对象，SEL对象包含方法的编号，放在SEL表中; IMP: 保存了方法地址的函数指针，放在IMP表中; SEL通过对应关系，在IMP表中找到相应的函数指针. OC对象结构分析首先，在OC中大部分事物都是对象，包括类也是一种对象。就像我们可以调用[NSObject alloc]一样，这其实就是向类(对象)发送alloc消息。既然类也是对象，所以类也有自己的isa指针，指向的则是元类(metaclass)。同时，元类也是对象，元类的isa指针则指向的是根元类(root metaclass)。而根元类(root metaclass)的isa指针则指向本身。到此，OC的对象结果完成了一次闭环 实例对象，类，父类，元类 的关系图 : 由图可知，对象的类定义了对象的方法，类的元类定义了类的类方法。每个对象都有自己的类，每个类都有自己的元类。并且，因为类具有继承关系的同时，父类的类方法子类也可以调用，而类方法是在类的元类中定义的。所以实际上 类的元类 和 父类的元类 也是继承关系的。OC中的对象都是继承自NSObject，而NSObject的类方法 alloc 方法则是又NSObject的元类所定义的。但是NSObject的子类都是可以使用类方法 alloc 的，所以NSObject的子类的元类也必然是继承自NSObject的元类的。 备注：元(meta)的概念来着”元小说”，本质上是讲读者从作者构造好的”盒子”(文章)中脱离出来，在文章中谈论文章本身(比如在文章中谈论这篇文章是怎么写的)。在游戏中类似的作品为《史丹尼的预言》, 在现在，&quot;元&quot; 的概念通常表示本质和根源 OC中类的成员变量成员变量以图下的方式排列在对象中。 图例: 出于验证，我创建了三个类， grandfather(继承自NSObject) , father(继承自grandfather) , child(继承自father).并分别添加各种的变量。然后实例化child后，打印child： 1234567(chid) $0 = { father = { grandfather = (_grandfather_mv = 0) _father_mv = 0 } _chid_mv = 0} 其中_&lt;类名&gt;_mv是我自定义的变量名。可以发现其结构与图例基本一致。但是没有打印出NSObject层级的isa指针。但是我单独打印NSObject时是有的，可能是xcode做过什么处理吧。 Objective-C对象模型的应用动态创建类1234567891011121314- (void)start { //创建一个类 Class newClass = objc_allocateClassPair([chid class], &quot;newTestClass&quot;, 0); //给这个类添加一个方法 class_addMethod(newClass, @selector(addtestM), (IMP)addm, &quot;v@:&quot;); //注册这个类，使其能使用 objc_registerClassPair(newClass); id test = [[newClass alloc] init]; 调用这个方法 [test performSelector:@selector(addtestM)];} object_getClass和[&lt;对象&gt; class] 的区别，两者在对象都是实例对象的时候是没有区别的，但是在对象是类的时候，object_getClass是获取元类的地址，而[&lt;对象&gt; class]仍然是获取当前的类，根据查找的一些blog提供的内容，object_getClass实际上就是获取的isa指针的内容，但是isa是可被修改的,所以object_getClass获取class是不安全的做法 为了测试之前关于元类的内容，输出一下类和元类的数据： 1234567891011121314void addm(id self, SEL _cmd) { NSLog(@&quot;对象：%@&quot;,self); NSLog(@&quot;类:%@(%p) || 父类:%@(%p)&quot;,[self class], [self class], [self superclass], [self superclass]); Class curClass = [self class]; for (int i = 1; i &lt; 5; ++i) { NSLog(@&quot;当前isa指针指向的是：%p&quot;,curClass); curClass =object_getClass(curClass); } Class objectClass = [NSObject class]; NSLog(@&quot;NSObject地址：%p&quot;,objectClass); NSLog(@&quot;NSObject元类地址：%p&quot;,object_getClass(objectClass));} 结果： 123456789test Start!对象：&lt;newTestClass: 0x100618010&gt;类:newTestClass(0x100617e20) || 父类:chid(0x100003ca8)当前isa指针指向的是：0x100617e20当前isa指针指向的是：0x100617e50当前isa指针指向的是：0x7fff9f7310f0当前isa指针指向的是：0x7fff9f7310f0NSObject地址：0x7fff9f731140NSObject元类地址：0x7fff9f7310f0 以此，我们可以看出，对象的类的元类，最后都根元类，其isa指针都是指向的NSObject的元类指针。同时NSObject的元类的根元类指向的是它自己 KVOkvo是一种动态的修改isa的技术。具体参考runtime. isa swizzlingisa swizzling是一种动态的替换类方法和实例方法的功能。 原理上则是修改 IMP和SEL 的关系对应表。 官方提供了三种实现方式： method_exchangeImplementations(两个方法交换) class_replaceMethod(会先检查一次新方法是否存在，不存在的话会创建一个方法并交换) method_setImplementation(为一个SEL设置IMP) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#import &quot;methodSwizzlingTest.h&quot;#import &lt;objc/message.h&gt;@implementation methodSwizzlingTest- (void)start { [self sel1]; [self sel2]; [self sel3]; [self exchangeMethod]; [self sel1]; [self sel2]; [self sel3];}#pragma mark - 原方法- (void)sel1 { NSLog(@&quot;sel1&quot;);}- (void)sel2 { NSLog(@&quot;sel2&quot;);}- (void)sel3 { NSLog(@&quot;sel3&quot;);}#pragma mark - 替换方法- (void)imp1 { NSLog(@&quot;imp1 替换了 sel1&quot;);}- (void)imp2 { NSLog(@&quot;imp2 替换了 sel2&quot;);}- (void)imp3 { NSLog(@&quot;imp3 替换了 sel3&quot;);}#pragma mark - 交换功能- (void)exchangeMethod { static dispatch_once_t onceToken; Class curclass = [self class]; dispatch_once(&amp;onceToken, ^{ //method_exchangeImplementations method_exchangeImplementations( class_getInstanceMethod(curclass, @selector(sel1)), class_getInstanceMethod(curclass, @selector(imp1))); //class_replaceMethod class_replaceMethod(curclass, @selector(sel2), [curclass instanceMethodForSelector:@selector(imp2)], &quot;@:&quot;); //method_setImplementation method_setImplementation(class_getInstanceMethod(curclass, @selector(sel3)), [curclass instanceMethodForSelector:@selector(imp3)]); });}@end 参考 参考文献：《iOS开发进阶》(唐巧) isa指针详解元类是什么","link":"/2017/11/04/Inside_The_OC_Object_Model/"},{"title":"知识产权简单了解","text":"知识产权是人类在社会实践中创造的智力劳动成果的专有权利。 知识产权为什么需要了解知识产权 一个方面，信息是昂贵的。 另一方面，现在社会是信息自由 现代社会已经进入信息时代，知识和分享和获取变得极为简单。而信息时代所提倡的也是 信息自由，但是这个和知识产权所要求的又有些矛盾。所以，作为互联网的从业人员，也应该对知识产权有一定的了解，用自己的眼睛去理解这个信息社会。在科学技术和知识产权之间找到平衡点。 版权版权保护作者的原创作品。主要类型包括： 文字作品 口述作品 表演艺术 美术作品 摄影作品 影视作品 计算机软件 建筑作品 法律、行政法规规定的作品 作品分类通常是概念模糊的，是为了预防未来出现的新创新类型没有被包涵。 值得注意的一点，如果你有一个想法，这个想法是不受版权保护的，只有你把这个想法写了下来，这个你写了下来的书才是受版权保护的.同时其他人看了你的书后，引用你表达的思想可以的，但是引用你书中的句子才是违背版权的。 同时，虽然理论上你创造了作品，就拥有其版权，但是为了保障其能得到法律保护和执行，就必须去进行版权的注册。 版权权利发表权，署名权，修改权，保护作品完整权，复制权，发行权，出租权，展览权，表演权，放映权，广播权，信息网络传播权，摄制权，改编权，翻译权，汇编权，应当由著作权人享有的其他权利 版权时限 公民个人作品：公民一生加上死后的第五十年的12月31日； 法人或者其他组织的作品：作品首次发表后的第五十年的12月31日；(50年内未发表，之后不再被保护) 影视作品：同上第二条 雇佣作品当一个公司的员工在雇佣时间内(工作时间),或者是被公司所要求创作出的作品。这个作品则是雇佣作品。雇佣作品的创作者没有经济版权，雇佣作品的作者也能会被注明为公司。 举个例子：迪士尼准备做个新电影，让内部员工写了个新剧本，并把电影拍了出来，那迪士尼拥有这个电影的故事的版权，而不是写剧本的人。 版权例外合理利用：侵权者出示合理利用的证据可以一定程度上抵消版权保护。比较常见的就是 促进学习。 当某篇文章被用作学习用途的时候，一定程度上会被认为成没有违法。但是这都取决于法院的判断。 常见合理利用的判断因素： 使用的目的和性质 创作性的高低(高创新的作品被保护的程度高，比如小说等；功能性强的作品则偏低，比如报纸等) 对作品的使用程度(数量和质量方面考虑，数量上比如引用了一篇文章的内容占引用文章的比例，质量上比如引用了一篇文章的核心内容) 衍生作品是否侵犯了原作品的赚钱能力 专利定义：专利一般是由政府机关或者代表若干国家的区域性组织根据申请而颁发的一种文件，这种文件记载了发明创造的内容，并且在一定时期内产生这样一种法律状态，即获得专利的发明创造在一般情况下他人只有经专利权人许可才能予以实施。在我国，专利分为发明、实用新型和外观设计三种类型。 条件 授予专利权的发明和实用新型，应当具备新颖性、创造性和实用性。(本法所称现有技术，是指申请日以前在国内外为公众所知的技术.) 新颖性，是指该发明或者实用新型不属于现有技术；也没有任何单位或者个人就同样的发明或者实用新型在申请日以前向国务院专利行政部门提出过申请，并记载在申请日以后公布的专利申请文件或者公告的专利文件中。 创造性，是指与现有技术相比，该发明具有突出的实质性特点和显著的进步，该实用新型具有实质性特点和进步。 实用性，是指该发明或者实用新型能够制造或者使用，并且能够产生积极效果。 授予专利权的外观设计，应当不属于现有设计；也没有任何单位或者个人就同样的外观设计在申请日以前向国务院专利行政部门提出过申请，并记载在申请日以后公告的专利文件中。 授予专利权的外观设计与现有设计或者现有设计特征的组合相比，应当具有明显区别。 授予专利权的外观设计不得与他人在申请日以前已经取得的合法权利相冲突。 申请专利的发明创造在申请日以前六个月内，有下列情形之一的，不丧失新颖性： 在中国政府主办或者承认的国际展览会上首次展出的； 在规定的学术会议或者技术会议上首次发表的； 他人未经申请人同意而泄露其内容的。 以下条件不授予专利： （一）科学发现； （二）智力活动的规则和方法； （三）疾病的诊断和治疗方法； （四）动物和植物品种； （五）用原子核变换方法获得的物质； （六）对平面印刷品的图案、色彩或者二者的结合作出的主要起标识作用的设计。 对前款第（四）项所列产品的生产方法，可以依照本法规定授予专利权 注意一点，申请专利的文档必须完整而清晰，其它人使用文档可以完成所发明物品的再现。 商标定义：商标是用来区别一个经营者的品牌或服务和其他经营者的商品或服务的标记。我国商标法规定，经商标局核准注册的商标，包括商品商标、服务商标和集体商标、证明商标，商标注册人享有商标专用权，受法律保护，如果是驰名商标，将会获得跨类别的商标专用权法律保护。 国际知识产权法简单的讲，众多国家(包括中国)会去签订一个条约(事实上是很多条约，关系错综复杂),只要是签约国都会履行条约内容。而条约会保障外国人在本国可以执行同等权利的知识产权。 IP问题现代社会 常出现侵权问题，比如你的视频在别人的视频中被使用，其他人以此获利。这种问题很难被禁止，级别是大型视频网站也不能做到完美的审核。于是这就形成了一片空区，即便他们是违法的。 总结不能让过时的规定影响技术发展，也不能忽略创造者的利益。两者平衡才是正常的发展之路。至于怎么平衡，国家的事了。 参考：《CrashCourse - 知识产权》百度百科","link":"/2017/12/12/Intellectual-property-right/"},{"title":"MD5","text":"MD5是一种消息摘要算法,可以产生出一个哈希值,通常时128位（16字节）的二进制数(32位16进制数)，用于验证信息传输是否被修改。 实际上MD5并不能看成一个严格意义上的加密算法，因为md5是没有正规的解密途径的。 MD5通常作为处理请求数据，用来生产密钥，作为数字签名使用。 MD5特性MD5 有两个特性: 输入任意长度的内容,都会被处理成一段唯一的32位16进制哈希值; MD5是不可逆的,一旦生成后,一般不能被反推出输入内容.(实际上随着技术的反正，通过撞库和彩虹表之类的方法是可以反推的) 场景例子老师准备将自己在家批改玩的试卷成绩传给学校的服务器，但是为了避免有不法的学生通过网络修改成绩以应付家长，所以采用了一种方案。 １. 首先，老师将学生的的分数,用一种和学习约定的拼接规则,拼成一个字符串,并用对其使用MD5加密,生产一个Sign(密钥) Sign = MD5( 学校提供的一串KeyCode + 学生的相关信息 + 学生的成绩 + 老师的编号 ) 将相关用于生产Sign的参数和密钥一起发送给学校后台 请求参数: 1234567 params = { keyCode: d8adasd9, studentInfo: wangxiaoming, mark: 40, teacher: 007, sign: qkfisnfl0s873skvodn8c0c6asa61ijn7} 学校收到请求后,将获得参数按照之间的约定生成一个Sign,然后用这个Sign和老师传过来的Sign做比较,如果完全一致,则表示中途没有被修改,如果不一致,则说明参数有修改,这个数据是不安全的数据. 这过程一般叫做验签 原理 填充原文 设置初始值 循环加工 拼接结果 填充原文原文长度(bit)对512求余，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。 之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。 设置初始值MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。 MD5的官方实现中，A、B、C、D的初始值如下（16进制）： A = 0x01234567 B = 0x89ABCDEF C = 0xFEDCBA98 D = 0x76543210 循环加工 哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环由处理后的原文长度（512 x N）决定. 则： 处理后的原文长度 = M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 循环中使用的函数： F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z) G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 拼接结果这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。 现实实际上，随着撞库，彩虹表等方式的兴起，MD5 变得越来越不安全了，所以现阶段我们开发除了 MD5 外，SHA1 也变得的越来越常用了。 但是在安全要求高的场合还是最好不要使用MD5。 参考 漫画：什么是MD5算法？ MD5值算法原理 MD5-wiki","link":"/2020/05/17/MD5/"},{"title":"JavaScript 学习总结","text":"JavaScript是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。JavaScript虽然非常灵活，但是制定相对应的编程规范，可以增强代码的阅读性，提高代码的质量，避免因为灵活性而导致代码过于杂乱。 文件规范文件名脚本文件名推荐全部小写，中间可以使用下划线作为连接。 例如main_camera.js。 但是需要优先考虑项目风格统一问题，所以优先按项目风格来命名。 编码方式源文件通常使用UTF-8编码。 代码内容模块导入和导出导入推荐使用import而不是require import '../utils/helper.js'; 可以对导入的模块重命名： 12import * as myModule from '/modules/my-module.js';myModule.helper(); 导出模块导出必须命名，不能使用默认导出，避免不同模块命名不一样。 代码命名 Package 驼峰法 myPackageName Class 首字大写 MyClassName Method 驼峰法 myFunctionName Enum 首字大写 MyEnumName 常量 全大写 CONSTANT_CASE 参数 驼峰法 myParameterName 变量 驼峰法 myVariableName 对象和数组的赋值推荐使用 块状结构，这样阅读更加的清晰。 1234567891011const list = [ 0, 1, 2];const someone = { a: 0, b: 1, c: 2}; 语句换行注意完整性换行需要保证语句的完整性。 1234567// errorlet result = this.add() + Floor( 50 * 2 - 60);// rightlet result = this.add() + Floor(50 * 2 - 60); 代码缩进提倡用** 4 个空格**来进行缩进，并在同一产品中采用同一种缩进标准。不支持用 TAB 键进行缩进。这是因为直到现在还没有统一的标准来定义 TAB 键所代替的空白大小。 代码空行 函数和类的第一行和最后一行不要是空行 1234func() { this.add(); this.leave();} 变量声明结束后 1234let value = 10;funcTest() {}; 注释前空行，但当注释在代码块的第一行时，则无需空行 1234567funcTest() {/* 第一行 */fitstLine();/* 第二行 */secondLint();}; 代码块后 12345func1() { //...}func2(); 文件最后保留一个空行 1234class({ //....}); 函数的参数过长时注意换行1234567891011121314// badfunc(topNumber, rightNumber, leftNumber, bottomNumber) { //...}// rightfunc( topNumber, rightNumber, leftNumber, bottomNumber) { //...} 分号 变量声明 let a = 10; 表达式 value = a &gt; 0 ? 1: 3; return return result; throw throw new Error(&quot;404 Not Found!&quot;); break break; continue continue; do-while do { } while(true); 以上语句的末尾都需要加上分号。 虽然在js中不加分号，也没有问题，但是加上分号更加的方便阅读。 let 和 constlet表示声明变量，而const表示声明常量，两者都为块级作用域；const 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了；但是如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行. 局部变量不要使用var关键字，var关键字的声明会提升到函数或全局内的最顶部，那么其变量的作用域就相当于整个函数或全局。 总结一下: var 是修饰全局变量 let 是修饰局部变量 const 是修饰不可更改的常量,但是修饰对象时，对象的属性时可变的 12345678func() { // bad var a = 1; // right let b = 2; const c = 3;} 从安全性讲,在开发中使用： const &gt; let &gt; var 。 变量声明不要合在一起123456// rightlet a;let b;// badlet a, b; 使用字面值而不是Array构造函数12345// badconst list = new Array(1, 2, 3);// rightcosnt arr = [1, 2, 3]; null 和 undefinde 区别 null 是对象 undefinde 是为定义 123let a = null; // a is objectlet b; // b未赋值，所以 b is undefinde Number需要注意的是，JavaScript没有什么浮点型之类的数据类型，JavaScript 只有一种数字类型Number。 在JavaScript中，数字不分为整数类型和浮点型类型，所有的数字都是由 浮点型类型。JavaScript 采用 IEEE754 标准定义的 64 位浮点格式表示数字，它能表示最大值为 ±1.7976931348623157e+308，最小值为 ±5e-324。 12let a = 1;let b = 2.3; this的指向函数中的this一般指的是当前对象本身，如果是箭头函数的话，就是函数之外的作用域了。 123456789101112131415161718192021func() { this.name = 'Tom'; return { name: 'Jerry'; method() { return this.name; } };}// 实际return值：Jerryfunc() { this.name = 'Tom'; return { name: 'Jerry'; method: () =&gt; { return this.name; } };}// 实际return值：Tom 字符串拼接常见两种写法： 1234567const content = 100;let str = &quot;前缀&quot; + content + &quot;后缀&quot;; // &quot;前缀100后缀&quot;const content = 200;let str = &quot;前缀${content}后缀&quot;; // &quot;前缀200后缀&quot;;let lenght = str.length; // str字符串的长度; Enums枚举模板： 123456789/** * URL Sign * @enum {string} */const DefineWebUrlContent = { SCHEME: &quot;https&quot;, ERROR_WEBGL: &quot;WebGL&quot;, BACK: &quot;back&quot;,}; 纯字符串可以使用单引号在浏览器中单引号的解析速度更快； 在查找资料时，有种说法：双引号会搜索引号内的内容是不是有变量，有则输出其值，没有则输出原有内容。所以输出纯字符串的时候用单引号比双引号效率高，因为省去检索的过程。 但是在法语中，本身就有带单引号的单词，所以具体情况具体分析。 如果是要考虑HTML的前端文件，可以推荐使用单引号；如果是单纯的JS脚本，使用双引号也没有影响。 遍历推荐使用常规 for循环；如果希望使用更加方便的新语法的话，推荐 for-of； for-in 效果很差，应该避免使用 值得注意的是，只有实现了迭代器（迭代协议）的对象才可以使用 for-of，js中所有的集合对象(数组、Set集合及Map集合)和字符串都是可迭代对象，这些对象中都有默认的迭代器。 比较JS 中的比较推荐使用： === 和 !== 但是，如果是与 null undefined 来对比就需要使用== 123456789let a = 0;let b = 2;if (a === b) { //...}if (a == null) { //...} 注释规范注释规范通常推荐使用 JSDoc 的规则。 JSDoc 是一个根据 JavaScript 文件中注释信息，生成 JavaScript 应用程序或模块的API文档的工具。 JSDoc注释一般应该放置在方法或函数声明之前，它必须以 /** 开始，以便由JSDoc解析器识别。 常用模板: 1234567891011121314151617181920/** * RoomInfo类，代房间信息. * @constructor * @param {number} roomId - 房间ID. * @param {string} roomUser - 房间拥有者. */roomInfo(roomId, roomUser) { // ...}/** * @return {Number} 返回值描述 * @example * let id = this.getRoomId('Test'); */getRoomId(roomUser) { return roomId;} @constructor 表示这是一个构造函数 @param {xx} yy 表示这是一个名为yy的参数，类型是xx @return {xx} zzz 表示返回值类型是xx，返回值描述是zzz @example 为举例的标识符，通常另起一行来写例子 JSDoc 的插件有很多，很多编辑器都是支持的，只需要通过插件生成就可以了。 附录 Google JavaScript Style Guide 浅谈 JavaScript 编程语言的编码规范 JSDoc中文文档 Code Guide by @AlloyTeam","link":"/2020/06/20/JavaScriptSummary/"},{"title":"MarkDown使用","text":"Markdown是约翰·格鲁伯发明的轻量级标记语言，方便用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）。 MarkDown学习整理标题一共6个级别 Code: 12345678910111213大标题=小标题-# 题目1## 题目2### 题目3#### 题目4##### 题目5###### 题目6 Preview: 大标题小标题题目1题目2题目3题目4题目5题目6 引用Code: 12&gt; 赛博朋克是未来主义背景下科幻小说的一个子类，专注于“低生活和高科技的结合”，其中包括先进的技术和科学成就，如人工智能和控制论，与一定程度秩序崩溃的社会，通常是后工业化的反乌托邦。工业集团和政治组织不再以国家划分，而是在信息网络控制的全球一体；社会高度繁荣，贫富差距社会问题也十分严重，灯光璀璨的繁华的外表之下是拥挤混乱肮脏潮湿的贫民世界。 Preview: 赛博朋克是未来主义背景下科幻小说的一个子类，专注于“低生活和高科技的结合”，其中包括先进的技术和科学成就，如人工智能和控制论，与一定程度秩序崩溃的社会，通常是后工业化的反乌托邦。工业集团和政治组织不再以国家划分，而是在信息网络控制的全球一体；社会高度繁荣，贫富差距社会问题也十分严重，灯光璀璨的繁华的外表之下是拥挤混乱肮脏潮湿的贫民世界。 嵌套引用Code: 123456&gt; 赛博朋克是未来主义背景下科幻小说的一个子类,&gt; &gt; &gt;专注于“低生活和高科技的结合”，其中包括先进的技术和科学成就，如人工智能和控制论，与一定程度秩序崩溃的社会，通常是后工业化的反乌托邦。&gt; &gt; 工业集团和政治组织不再以国家划分，而是在信息网络控制的全球一体；社会高度繁荣，贫富差距社会问题也十分严重，灯光璀璨的繁华的外表之下是拥挤混乱肮脏潮湿的贫民世界。 Preview: 赛博朋克是未来主义背景下科幻小说的一个子类, 专注于“低生活和高科技的结合”，其中包括先进的技术和科学成就，如人工智能和控制论，与一定程度秩序崩溃的社会，通常是后工业化的反乌托邦。 工业集团和政治组织不再以国家划分，而是在信息网络控制的全球一体；社会高度繁荣，贫富差距社会问题也十分严重，灯光璀璨的繁华的外表之下是拥挤混乱肮脏潮湿的贫民世界。 引用内部也可以使用其它markdown语法Code: 123456789101112131415&gt; ## 赛博朋克是未来主义背景下科幻小说的一个子类&gt; &gt; 专注于“低生活和高科技的结合”，&gt; &gt; 1. 其中包括先进的技术和科学成就，&gt; 2. 如人工智能和控制论，&gt; 3. 与一定程度秩序崩溃的社会，&gt; 4. 通常是后工业化的反乌托邦。&gt; &gt; `工业集团和政治组织不再以国家划分，而是在信息网络控制的全球一体`；&gt; &gt; * 社会高度繁荣，&gt; * 贫富差距社会问题也十分严重，&gt; * 灯光璀璨的繁华的外表之下是拥挤混乱肮脏潮湿的贫民世界。 Preview: 赛博朋克是未来主义背景下科幻小说的一个子类 专注于“低生活和高科技的结合”， 其中包括先进的技术和科学成就， 如人工智能和控制论， 与一定程度秩序崩溃的社会， 通常是后工业化的反乌托邦。 工业集团和政治组织不再以国家划分，而是在信息网络控制的全球一体； 社会高度繁荣， 贫富差距社会问题也十分严重， 灯光璀璨的繁华的外表之下是拥挤混乱肮脏潮湿的贫民世界。 列表点显示列表共三种写法 Code: 12345678910* 第一次工业革命(*)* 第二次工业革命(*)+ 第三次工业革命(+)+ 第四次工业革命(+)- 第五次工业革命(-)- 第六次工业革命(-) Preview: 第一次工业革命(*) 第二次工业革命(*) 第三次工业革命(+) 第四次工业革命(+) 第五次工业革命(-) 第六次工业革命(-) 数字显示列表Code: 123451. 第一次工业革命2. 第二次工业革命3. 第三次工业革命4. 第四次工业革命 Preview: 第一次工业革命 第二次工业革命 第三次工业革命 第四次工业革命 列表显示子区间Code: 1234567891011121314151. 第一次工业革命 &gt; 引用2. 第二次工业革命 * 二级 * 三级3. 第三次工业革命 内容4. 第四次工业革命 Preview: 第一次工业革命 引用 第二次工业革命 二级 三级 第三次工业革命 内容 第四次工业革命 分割线Code: 123456* * *********- - ----------------------------------------___ Preview: TableViewCode: 123456789101112| Left | Center | Right ||:-----|:------:|------:||aaa |bbb |ccc ||ddd |eee |fff | A | B | C---|---|---qwe|456|;.; A | B---|---123|456 Preview: Left Center Right aaa bbb ccc ddd eee fff A B C qwe 456 ;.; A B 123 456 LINKCode: 12345[百度](https://baidu.com)点击[我的博客](https://seabrea.xyz)看看&lt;https://baidu.com&gt; Preview: 百度 点击我的博客看看 https://baidu.com 图片Code: 1![图片备注](https://s2.ax1x.com/2020/03/09/89Rjy9.md.jpg) Preview: 文本属性Code: 1234567891011_斜体1___粗体1__*斜体2***粗体2*****粗斜体***~~删除~~ Preview: 斜体1 粗体1 斜体2 粗体2 粗斜体 删除 代码使用三个 ` 来标记代码，在代码顶部和底部都写上即可。 单行代码块则只需要用一个 ` 将其收尾保住即可。 Preview: 123456/// 多行代码块/// 顶部和底部都加上三个 `func init() { return 0;} 单行代码块(前后都各自加上一个)","link":"/2018/12/15/MarkdownLangure/"},{"title":"计算机网络","text":"计算机网络是网络时代的基石，从大型计算机到个人电脑，再到手机，计算机网络已经成为了互联网时代的不可缺少的一部分。 计算机网络局域网&amp;广域网计算机如果按照网络规模来划分，主要可分为 局域网 和 广域网。 局域网：主要是在一个偏小的区域内，比如一个家庭、社区或者公司，其内形成私人网络，除了这个区域的终端外， 其他终端均无法访问其内容； 广域网：广域网算是局域网的集合，当局域网的规模扩大，并且都互相保持访问，慢慢的这样一个巨大的集合体变成了广域网。 网络协议计算机网络的顶层核心之一就是网络协议,网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合.通过这些规则，我们可以在网络上轻松的发送按这些规则组装好的数据，和解析所接收的数据。 常见的协议模型有两种： 第一个则是 ISO参考模型： (国际标准，但是复杂并且发展缓慢) ISO七层模型 作用 应用层 针对相关应用的协议，比如邮件、视频等 表示层 对应用层提供底层协议支持，比如加密、压缩等 会话层 管理通信的协议 传输层 管理两个节点之间的数据传输 网络层 地址和路由的管理 数据链路层 设备之间的数据帧传送 物理层 传送数据的物理功能和规范 第二个则是 TCP/IP协议簇：(这个更加的常用) TCP/IP 应用层 应用程序 HTTP，DNS，FTP，SSH，TELNET 传输层 操作系统 UDP,TCP 网络互连层 操作系统 ARP，IP,ICMP 网络接口层 设备驱动,网络接口 以太网，WIFI，PPP 硬件层 设备驱动,网络接口 TCP/IP协议簇 与 ISO参考模型 的区别： 对于TCP/IP协议簇来说，应用层、表示层和会话层的服务很接近，所以合并成一个层次： 应用层； 网络层 和 数据链路层 也是同理，被合并到： 网络接口层。 TCP/IP模型的工作过程 通常我们平时接触的网络应用都被应用层所承担。在需要数据传输时，应用层的将数据在传输层(端口)加上 TCP或者UDP数据头，进行包装； 包装后的数据进入网络层中,网络层根据IP协议，加上IP数据头再次对数据进行包装； 包装后的数据被投入到链路层中，加上包含MAC地址的以太网数据头，最后正式进入以太网； 当目标收到这些数据后，再通过逆向操作一步步还原成应用层的数据。 IP协议 (Internet Protocol 互联网协议)IP协议 是 TCP/IP协议簇 的核心，处于网络层，用于将传输层的数据包装(加上IP数据头)，方便其在链路层中处理，最后再投入以太网中。IP协议方便多个单独的网络连接成一个互联网，提高的网络的可扩展性，减少了顶层网络和底层网络之前的耦合。 IP地址 IP地址由32位二进制数据组成，分为主机标识 和 网络标识 同时提供了一套子网掩码，对应位置为“1”的时候是网络标识，“0”为主机标识 举个例子啊：一个IP地址： 192.103.0.1 (11000000.01100111.00000000.00000001) 子网掩码：255.255.255.0(11111111.11111111.11111111.00000000) 根据1 对应网络标识0 对应主机标识 则 11000000.01100111.00000000(192.103.0) 为网络标识00000001(1) 是主机标识 以上通常简化为 192.103.0.1/24 (前24位是网络标识) ARP协议 (Address Resolution Protocl 地址解析协议)ARP协议是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议(根据IP地址来获取MAC物理地址)。我们知道，在实际通信中，要给另一个主机通信，必须知道对方主机的MAC地址，但是在现有的TCP/IP协议中，网络层和传送层通常只关心目标的主机的IP地址, 因此在链路层的数据中，数据实际上只有目标的IP地址没有MAC地址，而ARP协议的作用就是在数据发送帧前根据这个IP地址来获取对应的MAC地址，以完成数据传输。 值得一提的是，ARP协议获取到的MAC地址，并不一定是目标的IP的真实地址，因为两个主机并不一定在同一个局域网内，所以通常解析出来的是一台可以通往局域网外的路由器的MAC地址(此后发送主机发往目的主机的所有帧，都将发往该路由器)。这种通过情况通常也被称为 委托ARP或ARP代理(ARP Proxy)。 ARP协议常用于IPv4中，在IPv6中邻居发现协议(NDP)用于代替地址解析协议(ARP)。 ICMP协议 (Internet Control Message Protocol 互联网控制消息协议)ICMP协议通常用于返回的错误信息或是分析路由，可以看作错误检查和回报机制。方便我们检查网络状况和连线准确性。 通常不由网络程序直接使用,除了 ping 和 traceroute。 TCP协议 (Transmission Control Protocol 传输控制协议)TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP/IP协议的核心之一，在传输层提供服务。 特别： 满启动、拥塞控制、快速重传、可恢复。 运作方式 seq：顺序码ack: 响应码 创建连接：三次握手 客户端–发送带有SYN标志的数据包–一次握手–服务端 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端 客户端–发送带有带有ACK标志的数据包–三次握手–服务端 发送数据：ACK ack=1+22 的原因，是因为服务端需要根据这个知道客户端收到的数据大小 关闭连接：四次挥手 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送 服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号 服务器-关闭与客户端的连接，发送一个FIN给客户端 客户端-发回ACK报文确认，并将确认序号设置为收到序号加1 UDP协议 (User Datagram Protocol 目标数据包报协议)TCP/IP中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份。 特点：实效性好，工作效果高，不可恢复，不可靠性 Header构成： 校验和：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。 FTP协议 (File Transfer Protocol 文件传输协议)应用层协议，共分为两个部分： 服务端：用于储存文件 客户端：用于访问FTP服务器上面的文件 FTP的传输效率不错，通常用于大文件的传输。 DNS (Domain Name System 域名系统协议)应用层协议，是互联网的一种服务，作为将域名和IP地址相互映射的一个分布式数据库系统。 比如将访问 www.google.com 的时候，会先通过DNS服务器，将这个域名解析获取到对应的IP地址，然后通过IP地址来访问。 其实PC在命令行中可以直接通过 dig 工具来获取域名对应的IP，而dig就会展示一次DNS解析域名的流程。在命令行中输入:dig xxxx.com 就可以看到流程了，如果只希望知道结果，不想看流程，可以输入：dig +short xxxx.com。 网络传输在计算机网络中，一份数据是如何在网络上传输的呢？比如平时发送的一张图片一个文本，是如何传输出去的呢？ 网络传输场景在以太网中，比较常见的一个情况是: PC —双绞线—&gt; 交换机 —&gt; 光纤 —&gt; 交换机 —双绞线—&gt; PC PS. 网线并非直接连接PC的，而知连接 网卡 的。 每一块 网卡 都有设备商设定的唯一标识符，这个标识符就是 MAC地址(物理地址) 格式如：00-01-6C-06-A6-29 MAC 地址是可以被修改的 假如有一辆汽车，从成都寄到新加坡，如果这个流程发生在网络传输上，是怎么实现的 第一步：获取目标地址 路由和寻址 第二步：找到一条可以走到目标地址的路 数据链路 第三步：东西太大了，只能分拆成一个一个零件运过去 分片 第四步：为了防止零件丢失，需要给每个零件标上编号 序列号 第五步：将零件放到一个包装箱里面方便打包运输 封装 第六步：小心处理运输途中的堵车等事故 拥塞控制 第七步：检查包装箱里面的零件是否正常或者是否有丢失 错误检测和校正 第八步：补发有问题的零件 数据重发 第九步：拆开包装，重新组合零件 拆包和重组 然后，我们就在新加坡收到一辆汽车了。 为了这个运输过程能过正常运行，人们制定了一套规范来，控制整个流程，比如如何获取地址，如何拆分零件，如何包装和组合等等。而这个规范，就是 网络协议 寻址和传输在数据传输中：同网络下的简单传输： PC —&gt; 交换机 —&gt; PC PC的数据被包装后，通常包含各个协议相关的数据头，其中包含了 源IP地址 | 源MAC地址 和 目标IP地址。此时的目标MAC地址时不知道的。 接着网关会向交换机发送一个 ARP Request ARP Request的格式如下： 源 IP地址 XXX.XXX.X.X MAC地址 XX-XX-XX-XX-XX-XX 目标 IP地址 XXX.XXX.X.X MAC地址 ？ 交换机本身有一个MAC地址表。当收到 ARP Request 后就会先更新这个MAC地址。 同时开始在连接入这个交换机的PC中发送这个 ARP Request 。当有个PC发现这个 ARP Request 的目标与自己是符合的时候，变会将自己的MAC地址填入这个 ARP Request 中，然后送回交换机。 交换机发现新的MAC地址继续更新MAC地址表。 目标MAC地址和IP地址都知道了，就可以直接将数据顺利的从PC传输到目标PC 在复杂的网络环境中(真实网络) PC —&gt; 交换机 —&gt; 路由1 —&gt; 路由2 —&gt; … —&gt; 路由n-1 —&gt; 路由n —&gt; 交换机 —&gt; PC 此时的传输则是一步一步传输的，每一个PC/路由 —&gt; PC/路由 都进行了一次简单传输中类似的步骤。 有些不一样的是，路由本身有一份路由表，路由表则会记录下一个传输对象(非自连就传给目标路由，直连就传给目标交换机) 在数据发送中，通常数据都是体积很大的，所以需要分片发送，然后最后在目标PC中重组。 常用端口常见保留端口： 端口 名次 作用 21 FTP 文件传输 22 SSH 命令行远程登录 25 SMTP 邮件发送服务 80 HTTP WEB服务 110 POP3 邮件接收服务 139 SMB SAMBA共享 143 IMAP 邮件接收服务 443 HTTPS 加密网站服务 3306 MySQL 数据库服务 3389 RDP 远程桌面服务 6379 Redis 缓存服务器 8080 Proxy 代理服务器 HTTP/HTTPSHTTPHttp协议是建立在TCP协议基础之上的，当客户端需要从服务器获取数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接(无状态连接 即 每次都是一个新连接，数据完了后就释放相关内容，不保留状态)。 HTTPSHTTPS是基于SSL层的HTTP,为HTTP的安全版。 与HTTP的不同点： HTTPS需要到CA申请认证证书，通常均为收费证书。 HTTPS是SSL加密传输，非HTTP那种明文传输。 使用的端口号也不同，HTTPS是443端口，HTTP是80端口。 HTTPS的安全SSL：Secure Sockets Layer (安全套接层) TLS：Transport Layer Security (传输层安全) SSL和TLS在传输层之上对网络连接加密从而提供网络安全 在HTTPS中，在HTTP封装后，会在 SSL&amp;TLS 中间层加密，之后才会进入TCP层。 HTTP结构 HTTPS结构 HTTP HTTP TCP SSL&amp;TLS IP TCP IP 而SSL则混合使用了 非对称加密 和 对称加密 技术对内容进行了加密。 公钥/私钥属于非对称加密中的术语。 在非对称加密中，使用公钥对明文加密，然后使用私钥对其解密，常见算法有RSA。 对称加密： (使用同一个秘钥的对称加密)","link":"/2020/11/24/Network/"},{"title":"iOS内存管理与多线程","text":"在iOS中我们如何进行内存管理 iOS内存管理与多线程自动引用计数（ARC）OC内存管理在OC中，内存管理的引用技术采用ARC（自动引用计数），MRC（手动引用计数）的老版本现在不再使用。 OC的内存管理主要分为四个步骤： 创建 [ new / alloc / copy / mutableCopy ] 持有 [ retain ] 释放 [ release] 废弃 [ dealloc ] 事实上，在OC的内存管理中，是不用去考虑 计数 问题的，OC对象的内存管理，只需要注意几点就可以了: 对象的创建者持有对象 非对象的创建者也可以持有对象 不需要持有对象的时候需要释放对象 非自己持有的对象是无法去释放的 在iOS开发中，上述内存管理的方法均不是来自OC自身，而是来自苹果官方的的 Cocoa框架 内的 Foundation框架类 中的 NSObject, NSObject 中包含 + alloc类方法, - retain - release - dealloc实力方法 与其他语言的引用计数不同的是，OC的采用的是散列表作为引用计数的管理，其中内存块地址作为键值。这种设计能够保证即使内存块被损坏，只有这张表还在，就能顺通摸瓜找到对应的内存块地址 autoRelease（自动释放池）作用类似C语言的 局部变量 autoRelease的使用：首先生成NSAutoReleasePool对象，而这个对象的属性则类似C语言的局部变量，调用对象的autoRelease实例方法，在NSAutoReleasePool结束生存周期后，所有调用过autoRelease实例方法的对象都将执行release操作。 autoRelease常用于处理大量数据时，避免出现内存不足而闪退的现象。例如APP中同时处理大量图片等。 OC中，实际上对象调用autoRelease都是调用的NSObject类的实例方法，会将对象加入正在运行的NSAutoReleasePool种。 ARC规则OC中，通常编译单位可设置ARC有效/无效，因此项目中可以出现 ARC有效/无效 混合的情况。新项目中，通常均会使用ARC有效。 xcode4.2及其以上版本中，文件会默认ARC有效的 修饰符ARC有效时，对象类型必须附加所有权修饰符： __strong __weak __unsafe_unretained __autoreleasing __strong __strong是对象在不明确所有权修饰符时的默认修饰符。与strong一样，表示强引用，在ARC中，使用__strong后，则不必考虑retain和release的问题了，它自动做好处理的。因为默认会使用__strong，使用通常创建对象时可以不加上__strong。 __weak（iOS5及其以上） __strong并不能做到完美的内存管理，当两个对象互相强引用对方的时候，就会造成 循环引用，同用一个对象强引用自身的时候也会造成自引用(也是循环引用)，循环引用会导致对象不能正常得到释放而产生内存泄露，这个时候就需要__weak来解决了。__weak为对象提供弱引用，弱引用不能持有对象实例，因此不会产生循环引用的问题。 另外，__weak在持有对象的被废弃的时候，弱引用会自动失效并被赋值为nil，可以通过检验弱引用是否为nil,就可以知道那个对象是否有效。 __unsafe_unretained 在作用上与__weak类似，在低于iOS5的版本也被用于代替__weak。但是__unsafe_unretained赋值给__strong对象时，是必须保证__strong对象存在的，不然会导致崩溃。 __autoreleasing 在iOS中，ARC有效时，会使用@autoreleasepool块来表示autoRelease： 123@autoreleasepool { id __autoreleasing test = [[NSObject alloc] init];} 而__autoreleasing的作用则是 [test autorelease]。 规则ARC有效时，必须遵循以下规则： 禁止retain、release，autoRelease，retainCount [ARC会自动处理] 禁止NSAllocateObject、NSDeallocateObject [使用alloc] 遵守内存管理的命名规则 禁止显式调用dealloc [ARC会自动调用dealloc] 使用@autoreleasepool{}代替NSAutoReleasePool 禁止NSZone [iOS有着更好的处理] 对象类型变量不能成为C语言结构体成员 不要显式转换id 和 void * [不得不用就要加上 __brdige] ARC属性ARC有效时，属性声明的属性与所有权修饰符的对应关系 assign ===&gt; __unsafe_unretained unsafe_unretained ===&gt; __unsafe_unretained retain ===&gt; __strong strong ===&gt; __strong copy ===&gt; __strong weak ===&gt; __weak ARC实现简单理解， __autoreleasing则是 [test autorelease] __strong则是在对应地方插入好相应的retain和release方法； __weak,使用weak表，将赋值对象的地址作为key值，weak修饰对象的地址作为value值，储存在表中，当对象被释放后，则将weak修饰对象赋值nil然后从表中移除。（使用weak修饰对象会比较消耗cpu资源，所以请在正确的地方使用） Block匿名的内联代码集合体，常用在代码回调上 功能上与其他语言的 闭包 , lambda表达式 相似 Block的使用基本结构如下： 123returnType (^blockName)(parameterTypes) = ^(parameters) { statements}; Block的创建方式1234567891011121. 申明Block并创建typedef void (^testBlock)(int);testBlock _block;2. 属性定义Block@property (nonatomic, copy) void (^testBlock)(int);3. 局部Blockvoid (^testBlock)(int) = ^(int x) { NSLog(@&quot;test&quot;);}; Block作为一个函数的参数12345678910111213141. 先定义typedef void (^parameterBlock)(int);- (void)test:(parameterBlock)blk { //statements}2. 省略定义- (void)test:(void (^)(int))blk { //statements} Block截取变量 截取局部变量 Block截取局部变量是直接进行了 值拷贝 操作，因此其截取的值是无法被修改的.如果企图修改，XCode会报错， 但是可以用__Block修饰准备在Block中改变一个变量的值 1234_block int x = 0;void (^myBlock)() = ^{ ++x;} 这样修饰后，这个值就可以被修改了。原因是Block直接复制了其内存地址 全局变量和静态变量 截取全局变量和静态变量时是直接对对象进行引用，因此可以直接修改变量。 Block循环引用Block在使用的时候很容易出现循环引用。如图： 简单解释就是：某个对象持有了Block，但是Block又在代码块中调用了那个对象。 通常的解决方案为 打破互相的强引用 下面是Self-Block循环引用解决方法例子： 123456__weak typeof(self) weakSelf = self;^ { weakSelf.xxxxxx; [weakSelf yyyy];}; 为了防止Block可能出现先于对象被释放的情况时，可以再加上一层strong。 1234567__weak typeof(self) weakSelf = self;^ { __strong typeof(self) strongSelf = weakSelf; weakSelf.xxxxxx; [weakSelf yyyy];}; Block对象模型Block数据结构 isa指针 用于实现对象相关功能 invoke 函数指针，代码块实际上是个函数 descriptor Block的描述信息，比如size等等 variable Block所截取的对象 Block用三种，在Block创建的时候，isa指针指向对应的类全局Block(_NSConcreteGlobalBlock)，栈Block(_NSConcreteStackBlock)，堆Block(_NSConcreteMallocBlock)(isa指向的三个类) Block外部变量的复制在没用_block修饰的外部变量或者对象，Block内部截取时，是直接进行了”值拷贝”，直接复制其数据结构存在新的内存地址中，并用被其内存结构中的variable所引用。如果是对象，则复制其指针。 如果是用_block修饰了的外部变量和对象被Block截取的时候。Block会直接复制其对象或者值的引用地址，直接对其内存数据进行操作。 多线程进程 创建进程：创建所有必要的管理信息，创建完成后才会加入下一步 就绪：获得了一切需要资源和管理信息 运行：运行状态进程数小于等于系统处理器的总数 阻塞：等待，睡眠 终止：进程结束运行 线程 线程是进程的基本执行单元，进程的任务都是在线程中执行的。其中主线程负责主要的进程任务，在iOS开发中，主线程通常为UI线程。 多线程 多线程常用地方： 网络请求 图片加载 任务执行方式： 串行 并行 多线程执行原理 单核操作系统主要是通过时间片来实现的，两个线程在不同的时间片上交替执行，完成多线程。 多核操作系统是把线程分配给不同的处理器来执行，完成真正的并行。 优缺点 优点： 简化了编程模型：高效的处理大型任务或者零散任务 更加轻量级 提高了效率和资源利用率 缺点： 加强了程序设计的复杂性 占用内存空间（不要乱用多线程） 增加了CPU的调度开销，增加了CPU占有率 iOS中多线程的实现技术方案 pThread NSThread GCD NSOperation pThread多平台的多线程操作API，基于C语言的。 12345678910void *fun(void *data) { NSLog(@&quot;fun&quot;); return NULL;}- (void)test { //创建线程 pthread_t t; pthread_create(&amp;t, NULL, fun, NULL);} ps:pThead在iOS中并不常用 NSThread经过苹果封装，完全面向对象。 三种创建方式： 方式一 123//单独设置NSThread变量是因为方便调试跟踪 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; 方式二 123456[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];//也可以直接使用Block[NSThread detachNewThreadWithBlock:^{ [self run];}]; 方式三 1234//这个函数来自NSObject[self performSelectorInBackground:@selector(run) withObject:nil];[self performSelector:@selector(run) onThread:([NSThread new]) withObject:nil waitUntilDone:nil]; 设置优先级： setThreadPriority的值是在0~1之间的double值。值越高，执行该线程的概率越高。 123NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread setThreadPriority:0.5]; NSThread锁 12345@synchronized(self){ // Everything between the braces is protected by the @synchronized directive.} @synchronized，代表这个方法加锁, 相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程例如B正在用这个方法，有的话要等正在使用synchronized方法的线程B运行完这个方法后再运行此线程A,没有的话,直接运行。它包括两种用法：synchronized 方法和 synchronized 块。 1234//ticketsCondition 为一个NSCondition对象[ticketsCondition lock];//content[ticketsCondition unlock]; NSCodition是一种特殊类型的锁，我们可以用它来同步操作执行的顺序。等待某个NSCondition的线程一直被lock，知道其他线程给那个condition发送了信号。 NSOperation对于GCD的封装。 使用方式: NSInvocationOperation 12NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:SEL object:nil];[operation start]; NSBlockOperation 1234NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@&quot;test&quot;);}];[operation start]; NSBlockOperation用于添加异步操作 1234567891011 NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@&quot;operation&quot;); }]; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:operation]; NSLog(@&quot;main&quot;); result:DEMO[8360:12240295] mainDEMO[8360:12240397] operation 自定义NSOperation创建一个子类继承于NSOperation setMaxConcurrentOperationCount最大线程数 1[queue setMaxConcurrentOperationCount:1] GCD iOS开发中比较常用的多线程技术，苹果官方说法为：异步执行任务的技术之一。 首先明白 线程，任务，队列 的区别 常见GCD使用 简单使用DEMO 1234567dispatch_async(dispatch_get_global_queue(0, 0), ^{ // get Data dispatch_async(dispatch_get_main_queue(), ^{ //Update UI });}); dispatch_get_main_queue 由系统提供的主线程 dispatch_get_global_queue 由系统提供的全局并发队列 12345678910// long identifier ： 优先级// 系统提供了三个优先级列举// #define DISPATCH_QUEUE_PRIORITY_HIGH 2// #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0// #define DISPATCH_QUEUE_PRIORITY_LOW (-2)////// unsigned long flags : 通常填 0 或者 NULL//dispatch_get_global_queue(long identifier, unsigned long flags) dispatch_queue_create 创建队列 12dispatch_queue_t queue = dispatch_queue_create(&quot;name&quot;, DISPATCH_QUEUE_CONCURRENT);//DISPATCH_QUEUE_CONCURRENT，则这个队列是并发队列 12dispatch_queue_t queue = dispatch_queue_create(&quot;name&quot;, DISPATCH_QUEUE_SERIAL);//DISPATCH_QUEUE_SERIAL，则这个队列是串行队列，一次在一个线程只执行一个任务。 当需要用多行程处理的数据会造成数据竞争的时候就使用DISPATCH_QUEUE_SERIAL更加安全。但是DISPATCH_QUEUE_SERIAL每次都会生成一个新的线程去处理程序，会造成计算压力。如果不是处理一些互不竞争的数据则正常使用DISPATCH_QUEUE_CONCURRENT吧 dispatch_set_target_queue 作用有二： 用于改变队列的优先级，将目标队列与指定的队列优先级一致。 让指定队列来成为目标队列的执行阶层 更改优先级 123456789101112131415161718192021222324252627dispatch_queue_t queue_1 = dispatch_queue_create(&quot;queue_1&quot;, NULL); dispatch_queue_t queue_2 = dispatch_queue_create(&quot;queue_2&quot;, NULL); dispatch_async(queue_1, ^{ NSLog(@&quot;queue_1&quot;); }); dispatch_async(queue_2, ^{ NSLog(@&quot;queue_2&quot;); }); dispatch_set_target_queue(queue_1, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)); dispatch_async(queue_1, ^{ NSLog(@&quot;1&quot;); }); dispatch_async(queue_2, ^{ NSLog(@&quot;2&quot;); }); /* 结果： queue_1 queue_2 2 1 */ 让指定队列来成为目标队列的执行阶层 12345678910111213141516171819202122232425262728293031323334353637383940414243dispatch_queue_t queue_1 = dispatch_queue_create(&quot;queue_1&quot;, NULL); dispatch_queue_t queue_2 = dispatch_queue_create(&quot;queue_2&quot;, NULL); dispatch_queue_t queue_3 = dispatch_queue_create(&quot;queue_2&quot;, NULL); dispatch_async(queue_1, ^{ NSLog(@&quot;queue_1&quot;); }); dispatch_async(queue_2, ^{ NSLog(@&quot;queue_2&quot;); }); dispatch_async(queue_3, ^{ NSLog(@&quot;queue_3&quot;); }); dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, NULL); dispatch_set_target_queue(queue_1, queue); dispatch_set_target_queue(queue_2, queue); dispatch_set_target_queue(queue_3, queue); dispatch_async(queue_1, ^{ NSLog(@&quot;queue_1&quot;); }); dispatch_async(queue_2, ^{ NSLog(@&quot;queue_2&quot;); }); dispatch_async(queue_3, ^{ NSLog(@&quot;queue_3&quot;); }); /* 结果： queue_3 queue_2 queue_1 queue_1 queue_2 queue_3 让无序的三个串行队列变成有序的队列，可以有效避免几个串行队列的并行计算 */ dispatch_groupd 用于处理并发线程时，完全结束时的逻辑处理 1234567891011dispatch_queue_t queue = dispatch_queue_create(&quot;dispachTest&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^{ //todo1});dispatch_group_async(group, queue, ^{ //todo2});dispatch_group_notify(group, queue, ^{ //finish}); dispatch_barrier_async 插入任务 常用于并发队列中避免出现数据竞争的情况。比如在多线程读取数据，这时同时也需要写入数据，此时就有可能造成数据问题，因此使用dispatch_barrier_async就可以有效避免这个问题，并发队列会先等待dispatch_barrier_async执行完成后再继续执行。 12345678910111213141516dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT); __block NSInteger x = 0; dispatch_async(queue, ^{ NSLog(@&quot;%ld&quot;,x); }); dispatch_async(queue, ^{ NSLog(@&quot;%ld&quot;,x); }); dispatch_barrier_async(queue, ^{ x += 1; NSLog(@&quot;%ld&quot;,x); //此时写入数据，其它队列会等待这个写入完成。 }); dispatch_async(queue, ^{ NSLog(@&quot;%ld&quot;,x); }); dispatch_suspend dispatch_resume 12345//线程队列挂起 dispatch\\_suspend(queue); //线程队列恢复 dispatch\\_resume(queue); dispatch_after 延迟多少秒执行，但是这个并不是准确的时间，可用于大致的情况下。 123456//该方法的第一个参数是开始时间，第二个参数是多少时间后，第三个参数是要执行的block。 //dispatch_after的真正含义是在多少秒后把任务添加进队列中，并不是表示在6秒后执行 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ // }); dispatch_semaphore 信号量 就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 // create(value) 中的value表示最大允许的线程数量 dispatch_semaphore_t semaphore = dispatch_semaphore_create(3); dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT); // 信号量 先 “降” 后 “升” dispatch_async(queue, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run 1&quot;); sleep(2); NSLog(@&quot;finish 1&quot;); dispatch_semaphore_signal(semaphore); }); dispatch_async(queue, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run 2&quot;); sleep(2); NSLog(@&quot;finish 2&quot;); dispatch_semaphore_signal(semaphore); }); dispatch_async(queue, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run 3&quot;); sleep(2); NSLog(@&quot;finish 3&quot;); dispatch_semaphore_signal(semaphore); }); dispatch_async(queue, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run 4&quot;); sleep(2); NSLog(@&quot;finish 4&quot;); dispatch_semaphore_signal(semaphore); });}结果： run 2 run 1 run 3 finish 2 finish 1 finish 3 run 4 finish 4 // 因为线程最好只允许3个，所以在1，2，3执行完成后才会执行4. 相关使用范例异步加载图片1234567891011121314151617self.imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];[self.view addSubview:self.imageView];NSString *url = @&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot;;dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@&quot;开始异步下载图片&quot;); NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]]; UIImage *image = [[UIImage alloc] initWithData:data]; sleep(3); if(image) { dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;主线程显示图片&quot;); [self.imageView setImage:image]; }); }}); 创建单例123456789101112static SingleTest *instanceObj = nil;+ (instancetype)instance { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instanceObj = [[SingleTest alloc] init]; }); return instanceObj;}","link":"/2018/11/08/OC_HighLevel_Progamming/"},{"title":".bash_profile在zsh中生效","text":".bash_profile在zsh中生效今天给新电脑的Go设置环境的时候，发现写在.bash_profile文件中的环境变量始终不能生效。 纠结了半天之后才发现，我用的zsh而不是bash,因为前段时间改为zsh后，再加上终端的主题也隐藏了我在使用什么shell,导致出了问题。 当然，知道问题了就好解决了。 zsh 的配置文件是 .zshrc,如果 .bash_profile 里面的内容不多的话，可以将内容重新写入 .zshrc 。 当然还有一个更加简单的方式 ：在.zshrc 中添加 这句代码 source ~/.bash_profile,然后在终端中执行source ~/.zshrc,则可以直接规避以后可能会出现的类似的问题。","link":"/2019/06/21/Path_Setting_Bug/"},{"title":"小狗钱钱","text":"在童话中理解什么是金钱。 《小狗钱钱》是一本以童话故事为基础，用于对儿童科普金钱概念的儿童读文，但是我这种非经济专业的人来说，对于金钱这个行业，又和儿童有什么区别呢？","link":"/2020/05/04/PuppyMoney/"},{"title":"C# 快速入门","text":"随着业务的不断变化，开始在不同的编程语言之间左右横跳，今天又要搞搞C#了，写一篇快速入门的博客来做做记录。 C# 快速入门CLR公共语言运行时，类似LVVM，CLR 会将 C# 代码先编译成 IL Code（中间语言），然后再根据对应的运行平台编译成对于平台能识别的机器码。（但是C#无法像JAVA那样去跨平台） 类C# 的类和大多数高级语言是一样的，都是由 属性 和 方法 组成，或者说 类 是 属性和方法的容器。 123456789class World{ string name; int age = 10; int score() { return minScore; }} namespace简单的理解就是 类 的容器。通常一个 包 包含多个 namespace ，一个 namespace 包含多个类。 1234567namespace Hello{ class World { }} 变量 &amp; 常量在 C# 中，既可以使用 类型 + 变量名 的方式，也可以使用var + 变量名的方式 123string name;int age = 10;var minScore = 100; 而常量则通常使用 const 而不是像Swift一样使用let 123const float BASE_SCORE = 1.2;var finalScore = BASE_SCORE * 10; 数据类型在转换隐式转换123byte bNum = 20;int iNum = bNum; // iNum = 20float fNum = iNum; // fNum = 20.00 显示转换（强制转换）12float fNum = 10.00f;int iNum = (int)fNum; // iNum = 10 而通过这种强制转换的方法，是不能把 string 转为 int 的。而这个时候就可以使用转换类的解析方法。 123string s = &quot;100&quot;;int i = Convert.ToInt32(s); // Convert是.NET框架的一部分int n = int.Parse(s); 运算符绝大多数运算符都和其他语言是一致的，比较值得注意的一点是自增自减问题： 1234var a = 1;b = ++a;// b = 2, a = 2// 因为a在赋值给b之前，完成了自加。 1234var a = 1;b = a++;// b = 1, a = 2// 因为a会先赋值给b，然后再进行自加 方法C#的方法使用非常简单，按照 返回类型 方法名（参数类型 参数名） 123int main(string[] arg) { return 0;} 条件语句 &amp; 循环语句1234567int a = 10;if (a == 10) { // true}else { // false} 1234567891011int i = 0;while (i &lt; 100) { // i &gt;= 100 时会跳出循环 i++;}int j = 0;do { // do-while相比while，第一次会先执行一次do里面的内容。 j++} while (j &lt; 100) C#的数据结构Array12345678int[] arr = new int[3]{2,3,1};Console.write(arr[1]) // 3int[] list = new int[3];Console.write(list[1]) // 0list[2] = 20;Console.write(list[2]) // 20 数组最好不要去修改的 List用法类似动态数组。 1234List&lt;int&gt; arr = new List&lt;int&gt;();arr.Add(2); // 添加一个元素arr.Rmove(2); // 删除一个元素arr.RemoveAt(2); // 根据索引删除一个元素 Dictionary1234Dictionary&lt;string, int&gt; dic = new Dictionary&lt;string, int&gt;();dic.Add(&quot;key_0&quot;,10);dic.Add(&quot;key_1&quot;,20);dic.clear(); Queue123456// 创建内容为Int的队列Queue&lt;int&gt; que = new Queue&lt;int&gt;();que.Enqueue(10); // 该队列加入一个元素que.Dequeue(); // 该队列删除一个元素que.Clear()； // 清除队列的所有数据que.Peek()； // 查询队列的所有数据 先进先出 Stack12345Stack&lt;int&gt; stack = new Stack&lt;int&gt;();stack.Push(69);stack.Pop();stack.Clear();stack.Peek(); 后进先出 委托与事件 主要作用： 把方法当作参数进行传递，通常和闭包配合。 通过委托，实现模块解耦。 常见类型： Action Func Delegate Event ActionAction是C#最简单的一种委托，适用于无返回值的函数 12345678910111213void initProgram(Action action) { aciotn();}void TestAction() {}// 当参数类型是Action的时候，就可以直接传入一个函数initProgram(TestAction);// 或者使用匿名函数initProgram(()=&gt;{ // Content...}); 如果需要参数： 12345678910111213141516Action&lt;int&gt; mainAction;void TestAction(int a) { Console.Write(&quot;TestAction:&quot; + a);}void ResultAction(int a) { Console.Write(&quot;ResultAction:&quot; + a);}// 只有一个对象赋值的时候就直接等号，多个对象就加等mainAction += TestAction;mainAction += ResultAction;mainAction(10);// 结果：TestAction：10 ResultAction：10 1234567891011// Func泛型中的三个参数，前两个是参数类型，最后一个返回值类型void initProgram(Func&lt;int, int, string&gt; callBack) { if (callBack != null) { var result = callBack(10, 23); Console.Write(result); }}initProgram((a, b)=&gt;{ return &quot;String:&quot; + (a + b);} Func Func 是对于 Action 的补充，在支持 Action 的基础功能，还支持返回值。Func 的泛型中必须有类型：Func,其中类型中的类型的最后一个便是返回值类型。 1234567891011// Func泛型中的三个参数，前两个是参数类型，最后一个返回值类型void initProgram(Func&lt;int, int, string&gt; callBack) { if (callBack != null) { var result = callBack(10, 23); Console.Write(result); }}initProgram((a, b)=&gt;{ return &quot;String:&quot; + (a + b);} Delegate Delegate 在 C# 中不如 Objective-C 中那样常用。因为有着更加灵活的 Action 和 Func。但是在用法上和功能上都和OC非常的类似，比如有需要使用函数指针或者代理的时候等等。 123456789101112131415161718192021222324252627282930313233343536373839404142namespace Learn { class LearnDelegate { // 创建一个 delegate 函数 public delegate string DelegateHandler(int a); // 用这个函数申明一个对象 public DelegateHandler handler; public void ExecuteDelegateHandler() { if (handler != null) { // 在需要执行这个函数的地方使用 handler(99); } } }}namespace Learn{ class Program { static void Main(string[] args) { var file = new Program(); file.initProgram(); } void initProgram() { var delegateHandler = new LearnDelegate(); delegateHandler.handler = ResultAction; // 在实现这个委托的类里面写一个符合这个委托格式的函数，并赋值。 delegateHandler.ExecuteDelegateHandler(); } string ResultAction(int a) { Console.WriteLine(); Console.Write(&quot;ResultAction:&quot; + a); return &quot;ResultAction:&quot; + a; } }} EventEvent 在 C# 中就是特色的 Delegate，在代码层面的区别很小： 123delegate string DelegateHandler(int a);event DelegateHandler handler;// 创建方式和Delegate一样，只是需要添加event关键字 使用方式和Delegate也是一样的，但是区别在于，Event 只能在本类中调用，不能在类外调用。 同时类外注册的时候，必须通过 += 的方式，而不是 = 123delegateHandler.handler = ResultAction; // ErrordelegateHandler.handler += ResultAction; // Right 多线程12345678910111213void initProgram() { // 使用ThreadStart委托注册一个threadStartFunc函数 var ts = new ThreadStart(threadStartFunc); var thr = new Thread(ts); var thr1 = new Thread(ts); thr.Start(); // 执行 thr1.Start(); Console.Write(&quot;initProgram\\n&quot;);}void threadStartFunc() { Console.Write(&quot;threadStartFunc:\\n&quot;);} 参考 快速入门C#C#教程","link":"/2020/04/24/QuickLearningCSharp/"},{"title":"Router 路由","text":"路由是前端单页面应用实现的核心机制之一 React 路由什么是路由路由是一种 Key-Value 映射 通过 Key-Value ，路径 Path 作为 Key， 具体的组件作为 Value，在使用路由跳转的时候，实际上是刷新路由对应的组件。 需要注意的是，路由并不是只是存在于前端，实际上客户端和后端都有使用路由，因此路由中的 value 并不是只可以用组件，函数和类同样可以作为路由的 value。 路由的作用通过路由实现页面的局部刷新，方便单页面(SPA)应用的实现 无论 Vue 还是 React 都是单页面应用，整个项目，通常只有一个 HTML 文件，所有能看到的页面都是在这个HTML上面的组件，通过刷新组件来实现不同页面的效果。 如果没有理由，一个项目中不同的页面就需要不同的Html来展示，比如： 1234http://test.com/page/home.html // 首页http://test.com/page/about.html // 关于// 两个HTML页面的切换 如果是路由: 1234http://test.com/page/home // 首页http://test.com/page/about // 关于// 一个HTML页面，两个路由路径的切换 路由的分类前端路由前端路由通常是value绑定组件(Component)，当浏览器的path变化后，当前页面的组件就会更新为path所对应的那个组件。 比如： 123/page/home 绑定 &lt;Home /&gt;如果当前浏览器路径为 www.xxxx.com/page/home 的时候，页面会直接更新后 &lt;Home /&gt; 的内容 后端路由通常后端路由中的value绑定的是一个函数，当后端接受到一个请求路径的时候，通过这个path，找到对应的value所指的函数，来出现相关的请求，并返回对应的响应数据。 比如： 123/page/homelist 绑定 getHomeList() 函数如果前端请求 http://xxxx.com/page/homelist 的时候，后端就会调用 getHomeList() ，并返回对应的数据。 前端路由原理路由是基于浏览器的历史记录history 来实现的。 而浏览器的历史记录，通过 BOM (浏览器对象) 来获取 DOM 文档对象模型： 用于处理网页内容相关，比如获取网页内容中的阶段、内容点击事件等 BOM 浏览器对象模型： 用于处理浏览器相关，比如历史记录、窗口信息、浏览器版本信息等 如何通过路由来实现呢页面A跳转到页面B呢？ 123456789101112131415161718192021222324// 首先我们有一个Html，上面渲染的是一个 组件A// 然后先注册好 组件A 和 组件B 注册(path: '/page/A', value: '&lt;A /&gt;')注册(path: '/page/B', value: '&lt;B /&gt;')当前状态： 浏览器路径: /page/A 展示画面: &lt;A /&gt; // 然后在 &lt;A /&gt; 中有一个按钮，按钮中有一句跳转代码history.push('/page/B');// history.push 的意思是在历史记录数组中推入一条历史记录，这条历史记录为 '/page/B'// 这样话，‘/page/B’ 就是浏览器最新的一条数据，在浏览器顶部显示的路径也会变成 '/page/B'当前状态： 浏览器路径: /page/B 展示画面: &lt;A /&gt; // 浏览器路径的改变，// 因为监听到路径的变化(被前端路由器监听)，通过之前注册的 `key-value` 表，去寻找新路径所对应的内容// 我们知道了 当 key 为 /page/B 时，表所对应的 value 为 组件B: &lt;B /&gt;// 因此，修改页面上的 组件 &lt;A /&gt; 改为 &lt;B /&gt;当前状态： 浏览器路径: /page/B 展示画面: &lt;B /&gt; 由此完成了一次路由跳转。 在代码中，可以通过 window 来操作 BOM，BOM 有个history属性来处理历史记录相关内容： window.history.push() 浏览器中，历史记录是一个栈结构，因此后push进去的数据就是最新的数据。 如果不想产生历史记录，可以使用 replace() 而不是 push() ，就可以直接替换最新的记录，而不是添加一个新记录。 值得一提的是，history 是 H5 才有的API，在不支持H5的时候，通常使用hash值来代替 history模式: http://xxxx.com/page/a 好用，美观 hash模式: http://xxxx.com#/page/a 不美观，但是兼容性好 React Router (React 路由器)React 通常使用 react-router 这个插件库来实现 React 项目的路由，也是 React 实现 SPA 的核心。 react-router 是一个基于 React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。 React Router 是建立在 history 上面的，history 解析浏览器URL，从中URL中获取到相关的path，再通过 path 作为 key 获取到 对应的 value。 **但是react-router 有多个版本给不同的开始对象使用(web , mobile等)**， 通常web开发，使用 react-router-dom 这个web专用的路由插件库。 项目中，全局一般只有一个路由器，所有路由相关组件应该都在路由器的children中使用 路由组件既不用直接渲染的组件，比如 &lt;HomeHeader /&gt; 是直接写在代码里面的， 就是直接渲染的组件， 123&lt;div&gt; &lt;HomeHeader /&gt;&lt;/div&gt; 而路由组件不是， 1&lt;Route path=&quot;/home&quot; component={Home} /&gt; 他是用Route注册的，不会直接显示，直到path匹配后才会渲染。 路由的匹配是支持模糊匹配的 123&lt;Route path=&quot;/home&quot; component={Home} /&gt;&lt;Link to='/home/123'&gt; // 这样调用也是能匹配到 &lt;Home /&gt; 的 如果拒绝模糊匹配，则需要开启严格匹配，需要注意的是尽量避免使用严格匹配，因为严格匹配会影响到二级路由 1&lt;Route exact={true} path=&quot;/about&quot; component={About} /&gt; 通常项目中会有两个文件夹 pages 和 components ，pages 放路由组件，components 放普通组件 路由组件会默认受到一些路由相关的props属性，而普通组件不会 另外在路由组件的最外层使用&lt;Switch&gt;&lt;/Switch&gt;包裹起来，这样可以实现switch的效果，不会遍历所有路由，提高效率 代码跳转虽然React Router 提供了 和 两个理由标签来使用路由组件，但是如果要直接在编码中调用路由，则需要其他方式了。 所有的路由组件中，props中会默认被参入几个参数。 history 用于操作历史记录(路由操作)的对象 location 用于操作当前路由数据 match 匹配路径参数的对象 这样的话，就可以直接使用这个history就能进行跳转操作了。 12props.history.push('/home');props.history.replace('/home'); 路由参数 params 参数 通过 /:参数 的方式注册路由，然后通过 props.match.params 来获取传入的参数对象 12345678910// 注册&lt;Route path=&quot;/home/:curentID&quot; component={Home} /&gt;// 跳转props.history.push(`/home/${2}`);// 使用console.log(props.match.params);// 输出{curentID： 2} 需要注意的是 /: 参数 是可以传入多个的，比如 /home/:id/:title/:name,这样收的参数对象为: {id='', title='', name=''} search 参数 通过 /?参数名=参数&amp;参数名2=参数2 这种格式来使用 1234567891011// 注册，使用search参数在注册时无需使用特色方式&lt;Route path=&quot;/home&quot; component={Home} /&gt;// 跳转props.history.push(`/home/?id={2}&amp;title={'name'}`);// 使用console.log(props.location.search);// 输出'?id=2&amp;&amp;title=name' // 然后去解析即可 state参数 state参数不会出现在浏览器path中，如果不需要别人在浏览器上面看到参数的话就可以使用这种方式. state参数，如果清除历史记录后就不能使用，保证state参数刷新后仍然能使用是因为state参数会在history中留下记录，如果使用hash路由就不能保存。 12345678910// 注册&lt;Route path=&quot;/home&quot; component={Home} /&gt;// 跳转props.history.push(`/home`, {id:2, title:'name'});// 使用console.log(props.location.state);// 输出{id:2, title:'name'} 路由参数的使用优先级为 1 &gt; 2 &gt; 3. withRouter如何让普通组件也和路由组件一样可以通过props使用history对象, 则使用 withRouter 就可以了。 12345678910111213141516import React, { Component } from 'react'import { withRouter } from 'react-router-dom'export class TextView extends Component { render() { window.console.log(this.props); return ( &lt;div&gt; &lt;p&gt;这是一个文字组件&lt;/p&gt; &lt;/div&gt; ) }}export default withRouter(TextView) 用withRouter包裹需要使用的组件即可。","link":"/2021/10/27/ReactRouter/"},{"title":"正则表达式","text":"正则表达式(Regular Expression)，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 正则表达式元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 字符转义字符“ \\ ”用来取消特殊字符的含义 比如：&quot;\\\\&quot; &quot;\\*&quot; 重复 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 1234匹配手机号码例子：^((13[0-9])|(15[^4,\\\\D])|(14[57])|(17[0])|(17[7])|(18[0,0-9]))\\\\d{8}$","link":"/2017/02/09/RegularExpression/"},{"title":"SQL 小计","text":"SQL是访问和处理关系数据库的计算机标准语言 SELECT * FROM NoteList SQL Note基本查询格式：SELECT * FROM &lt;表名&gt;; 例子： 1SELECT * FROM students; SELECT [关键字] 表示 发起选择 FROM [关键字] 从什么地方查询 表示 所有列 students 从一个叫“students”的表中查询 虽然SELECT可以用作计算SELECT 100+200;，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接 条件查询格式：SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;; 例子: 12345678SELECT * FROM students WHERE score &gt;= 80 AND gender = 'M';SELECT * FROM students WHERE score &gt;= 80 OR gender = 'M';SELECT * FROM students WHERE NOT class_id = 2;SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = 'M'; WHERE [关键字] 条件关键字 如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。 投影查询格式：SELECT 列1, 列2, 列3这种仅返回指定列的操作称为投影 例子: 1SELECT id, score points, name FROM students WHERE gender = 'M'; score points, score是选择的列，points是给这个列重新取了一个别名 排序格式：XXXX + ORDER BY + XXXX 例子: 123SELECT id, name, gender, score FROM students ORDER BY score;SELECT id, name, gender, score FROM students ORDER BY score DESC; ORDER BY score [ASC] 以score为条件的升序排序(ASC 关键字可省略) ORDER BY score DESC 以score为条件的降序排序 分页查询分页实际上就是从结果集中“截取”出第M~N条记录。 格式：LIMIT &lt;M&gt; OFFSET &lt;N&gt; 例子: 12SELECT score FROM students ORDER BY score DESCLIMIT 5 OFFSET 0; 结果集从0号记录开始，最多取5条 聚合查询格式：SELECT COUNT(*) FROM &lt;表&gt; 例子: 1SELECT COUNT(id) boys FROM students WHERE gender = 'M'; COUNT(id) boys : COUNT(*)表示查询所有列的行数,boys是为这个值取的别名 常见聚合函数: COUNT( ) : 所有列的行数 SUM( ) : 计算某一列的合计值，该列必须为数值类型 AVG( ) : 计算某一列的平均值，该列必须为数值类型 MAX( ) : 计算某一列的最大值 MIN( ) : 计算某一列的最小值 多表查询格式：SELECT * FROM &lt;表1&gt; &lt;表2&gt; 例子: 1SELECT * FROM students, classes; 也可以给表设置别名:FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt; 例子： 1SELECT s.id, c.cores FROM students s, classes c; 连接查询确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上 1234SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id; 确定主表SELECT &lt;内容&gt; FROM &lt;表&gt; 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法 之后确定连接条件，使用ON &lt;条件...&gt; 之后还可以继续加上WHERE之类的条件子句 修改数据 INSERT 插入内容 UPDATE 更新内容 DELETE 删除内容 INSERT格式： INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); 例子： 1INSERT INTO students (class_id, name, score) VALUES (99, 'Bob', 95); 例子的意思是，向students表 插入(class_id, name, score)三个字段的内容，其内容为(99, 'Bob', 95) 当然，如果需要添加多个内容，则在内容那么添加多个，并有逗号隔开： 1234INSERT INTO students (class_id, name, score) VALUES(99, 'Bob', 95),(59, 'Tom', 55),(19, 'Tim', 90); 即可。 UPDATE格式： UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 例子： 123UPDATE students SET name='Bob', score=80UPDATE students SET score=score+10 where score&lt;60 DELETE格式： DELETE FROM &lt;表名&gt; WHERE ...; 例子: 1DELETE FROM students WHERE class_id=1 例子的意思是：删除class_id为1的学生","link":"/2019/06/18/SQL_Note/"},{"title":"Shell Script","text":"12#!/bin/bashecho &quot;Hi Bob !&quot; Shell 脚本（shell script），是一种为 shell 编写的脚本程序。 Shell Script初识#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。echo 命令用于向窗口输出文本。 12#!/bin/bashecho &quot;Hi Bob !&quot; 变量定义变量var_name=&quot;Helle world&quot; 使用变量echo $var_name 也可以使用花括号作为界限区分echo &quot;This is ${var_name}&quot; 如果想设置一个只读变量，可以使用关键字readonly 12345#!/bin/shvar_name=&quot;Helle world&quot;readonly var_namevar_name=&quot;Hi&quot;echo $var_name 允许则会报错:testShell.sh: line 4: var_name: readonly variable 除了只读，我们还可以删除变量unset var_name使用了该语句的后面的内容，将无法使用var_name。 字符串1234567#!/bin/shvar_name=&quot;Hello world&quot;echo ${#var_name}echo ${var_name:3:7} echo $","link":"/2021/06/27/ShellScript/"},{"title":"SourceTree 使用记录","text":"SourceTree 是 Windows 和Mac OS X 下免费的 Git 和 Hg 客户端管理工具，支持创建、克隆、提交、push、pull 和合并等操作。SourceTree拥有一个精美简洁的界面，大大简化了开发者与代码库之间的Git操作方式，这对于那些不熟悉Git命令的开发者来说非常实用。 SourceTree 使用记录在切换分支的时候，切换后的分支代码被修改 在切换分支的时候，如果我们还未提交修改就切换到其他分支，这种修改也会带到其他分支的。所以切换分支前注意提交代码。 删除当前分支报错 删除分支时，要保证HEAD不在要删除的分支上，不然会报错。 Tag标签的常见作用Tag标签通常用于表示版本，其基本功能和分支是类似的。比如要发版的一个版本v1.0.1，那么可以给这个发版的代码设置一个Tag标签v1.0.1。 贮藏有时候，我们需要切换其他分支的代码，但是当前的分支没有改完，不能提交，这个时候就可以使用 贮藏 ，贮藏 可以保存当前所有的修改，使用贮藏功能后，会让当前分支的工作区恢复到上一次提交的时候，从而使当前工作区变得干净。修改完其他分支后，就可以通过贮藏恢复之前工作的修改。当有新添加文件或删除文件时，这些文件的贮藏会失败，所以这个时候应该先把这些文件加入暂存区，让这些文件加入Git管理。就可以了（保留暂存的更改选项通常不选） 换行符兼容不同平台使用的换行符不一样，导致win或者mac或者Linux下，同样的代码因为换行符问题而错误识别为有新更新，甚至不能通过编译的情况。建议在git项目根目录下，创建一个.gitattributes文件，并且添加一句* text eol=lf;在命令行运行命令git config --global core.autocrlf false和git config --global core.safecrlf true;并且，建议把编辑器（IDE）的换行符统一更换成Unix格式。 Git 分支设计规范(参考) 分支 名称 环境 master 主分支 生产环境 release 预上线分支 用户验收测试环境，用于生产环境下的软件测试者测试使用 hotfix 紧急修复分支 开发者调试环境 develop 测试分支 功能验收测试环境，用于测试环境下的软件测试者测试使用。 feature 需求开发分支 用于开发者调试使用 参考 SourceTree使用教程","link":"/2020/01/20/SourceTree_Using/"},{"title":"Swif学习总结","text":"Swift 作为 Objective-C 的新世代，已经成为了苹果首推的iOS开发语言，而且 Swift 的相关开发内容已经逐渐成熟，使用 Swift 开发的项目也越来越多，Swift5.0 后 Swift 也基本趋于稳定，因此Swift已经成为了iOS开发人员的必备能力了。 Swif学习总结基础类型数据类型和集合类型Swift新提供了一套新的数据类型 整型: Int 浮点: Double Float 布尔型: Bool 字符串: String 数组: Array 字典: Dictionary 组合: Set 常量和变量Swift使用 let 和 var 来最为常量和变量的修饰符 常量和变量在Swift中，如果要使用，必须先声明 123let testNum = 1var testStr = &quot;test&quot; 在开发过程中，如果是不会别修改的变量，也需要用let声明为常量。 Swift 使用了 let 和 var 关键字直接用于区分是否可变。可变会更容易出错，所以尽量采用不可变设计，等到需要改变才改为 var 吧。 分号Swift中换行是不需要分号的，但是如果一行里写多句代码，分号还是需要的 12345let testString = &quot;Test&quot;print(testString)let testNum = 0; print(&quot;\\(testNum)&quot;) 数据类型的范围Swift中可以使用minValue或者maxValue来获取当前数据的类型的最小最大值 整型Swift 提供了 8，16，32 和 64 位编码的有符号和无符号整数Int8,UInt8 ... Int64,UInt64 而 Int 和 UInt 则和CPU有关， 在 32位平台上， Int和UInt的长度 等于 Int32 和 UInt32在 64位平台上， Int和UInt的长度 等于 Int64 和 UInt64 浮点数 Double 至少15位数字的精度(64位的浮点数) Float 6位数字的精度(32位的浮点数) 通常情况下，Double和Float都可以使用的时候，推荐使用Double 整数和浮点数转换Swift中，整数和浮点数类型的转换必须显式地指定类型 123456789let num1 = 1let num2 = 1.1// 显式的将浮点数转换为整数let num3 = num1 + Int(num2) // 显式的将整数转换为浮点数let num4 = Double(num1) + num2 在用浮点数初始化一个新的整数类型的时候，数值会被截断。也就是说 1.95 会变成 1 ， -3.5 会变为 -3 类型别名 typealiastypealias修饰词的作用类似Objective-C中的typedef，可以为已经存在的类型定义了一个新的可选名字 123typealias NewType = UIntvar maxNewType = Newtype.maxValue 元组元组把多个值合并成单一的复合型的值。元组内的值可以是任何类型，而且可以不必是同一类型。 元组 也是Swift 比较推荐使用的方式 1234567891011121314151617181920212223// 创建一个简单的元组let postCode1 = (44,&quot;OK&quot;,3.1415)//创建一个命名元组let postCode2 = (x: 5, y: 3)// 不同的类型let postCode3 = (name: &quot;Carl&quot;, age: 78, pets: [&quot;Bonny&quot;, &quot;Houdon&quot;, &quot;Miki&quot;])// 访问元组元素postCode1.0 // 44postCode1.1 // &quot;OK&quot;postCode2.x // 5postCode2.y // 3//元组拆解let (x, y, z) = postCode1print(&quot;\\(x)&quot;,&quot;\\(y)&quot;,&quot;\\(z)&quot;) // 44,&quot;OK&quot;,3.1415let (h, _, _) = postCode1 // 不需要的数据可以直接用&quot;_&quot;来代替print(&quot;\\(h)&quot;) // 44 元组适合于简单的数据组合，复杂的数据组合还是使用使用类或者结构体 需要临时组合一些相关值的时候，元组非常有用。如果数据结构需要在临时范围之外仍然存在。那就把它抽象成类或者结构体 可选项Swift的可选项用来处理一些可能为nil的值，来保证安全性，提示这个值可能为nil. 1let newNum = Int(&quot;哈哈哈哈&quot;) “哈哈哈哈”并不能被Int转换成一个整数，所以这次转换可能会失败,newNum可能会为nil，所以Int()会返回一个 Int？，而Int？后面的？号代表这时一个可选项 nilSwift 中的 nil 和 Objective-C 中的 nil 是不一样的，OC 中的 nil 是一个指向不存在对象的指针，只有对象可以设置为 nil。在 Swift中， nil 不是指针，他是值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象类型 同样的，如果Swift中要给一个变量设置为 nil， 则需要使用 可选项 var newString: String? = nil 可选值的强制展开因为可选项的存在，可选值可能为空，所以在使用可选值的时候必须进行判断 1234if newString != nil { print(“newString”)} 但是有的时候，我们已经知道这个值是一定不为空的，不需要再做多余的判断了，就可以直接使用 “！” 来强制展开， 12print(newString!) 因为强制展开可选值的要求严格，如果强制展开了一个nil，则会导致崩溃，所以小心使用. ！遇到 nil 时会 crash（包括 as! 进行强制转换）。可以使用 if let/guard let/case let 配合 as? 将可选值消化掉。所以能不用！就不要用！ 可选项绑定因为强制展开充满了危机，所以我们可以使用 if语句 和 变量常量 的结合，进行可选项绑定，来安全处理可选值 12345678if let newNum = Int(unknownString) { print(&quot;\\(newNum)&quot;)}else { print(&quot;error&quot;)} if let newNum = Int(unknownString)中，如果Int(unknownString)不为nil，则newNum则是展开后的值，为空则进入else语块 同时也支持变量if var newNum = Int(unknownString),方便在if代码块中操作newNum。 隐式展开可选项当一个值在使用的时候一定不为nil，但是在初始化的时候是可能为nil的，就可以使用隐式展开可选项 在iOS中，有个很简单的例子，就是ViewController中的View，在初始化的过程中，并不是一定有值，可能为nil。但是在我们使用的过程中，View是一定有值，所以这个时候，用的是就是 view!(隐式展开可选项) 因此我们在创建一个初始化可能为nil，但是使用的时候一定有值得 变量或者常量的时候就可以使用了。 如果你在隐式展开可选项没有值的时候还尝试获取值，会导致运行错误。结果和在没有值的普通可选项后面加一个叹号一样。 错误处理相比于可选项的通过值是否缺失来判断程序的执行正确与否，而错误处理机制能允许你判断错误的形成原因，在必要的情况下，还能将你的代码中的错误传递到程序的其他地方。 123456789101112131415// 可能会抛出异常的函数func testFunction() throws { // ...} // 通过 do-try-catch 块来处理异常 do { try testFunction() // 查看函数是否异常 testFinish() // 无异常则调用此函数 } catch Error.OutOfCleanDishes { // 异常满足此条件，则调用这个catch块中的内容 testShowError()} catch Error.MissingIngredients(let ingredients) { testShowErroContent(ingredients)} OC 中很多返回 NSError 的函数在，Swift中都改为了使用throws，所以出现throws时务必使用 do-catch 处理。 断言调试(assert)使用全局函数 assert(::) 函数来写断言。向 assert(::) 函数传入一个结果为 true 或者 false 的表达式以及一条会在结果为 false 的时候显式的信息： 1234func assert(@autoclosure condition: () -&gt; Bool, @autoclosure _ message: () -&gt; String = default, file: StaticString = default, line: UInt = default) 断言只会在 Debug 模式下起作用，在 Release 版本中是被忽略的。 例子： 12let testNum = 3assert(testNum &lt; 0, &quot;Num Error !&quot;) testNum &lt; 0 为false，断言被触发，应用终止。 先决条件(precondition)precondition 在使用和作用上和 assert 类似 precondition 与 assert 的区别在于： assert只在debug环境下生效，而precondition是debug和release都生效 ( 断言是在测试期间的理性检查，而前提条件是防御的事情，如果发生，意味着你的程序只是不能合理地进行 ) 基本运算符X元运算符 一元运算符对一个目标进行操作（比如 -a ）。一元前缀运算符在目标之前直接添加（比如 !b ），同时一元后缀运算符直接在目标末尾添加（比如 c! ）。 二元运算符对两个目标进行操作（比如 a + b ）同时因为它们出现在两个目标之间，所以是中缀。 三元运算符操作三个目标：三元条件运算符（ a ? b : c ）。 赋值运算符赋值运算符 “=” ，可以将右侧内容更新左侧内容。 但是 Swift 的赋值符号自身不会返回值,所以类似 12if x = y {} 这样的使用的禁止的 算术运算符 加 ( + ) 减 ( - ) 乘 ( * ) 除 ( / ) 求余数 ( % ) （考虑负数运算，所以不是取模） 合并空值运算符合并空值运算符 （ a ?? b ）如果可选项 a 有值则展开，如果没有值，是 nil ，则返回默认值 b 。表达式 a 必须是一个可选类型。表达式 b 必须与 a 的储存类型相同。 a ?? b =====&gt; (a != nil) ? a! : b 区间运算符 闭区间运算符: a…b(a &lt;= b) , 定义了a到b，同时包含a和b的一系列数据 半开区间运算符: a..&lt;b(a &lt; b) , 定义了从 a 到 b 但不包括 b 的区间，即 半开 单侧区间: 闭区间有另外一种形式来让区间朝一个方向尽可能的远, array[a…](a到该数组末尾，[…a]则相反为数组开始到a) 逻辑运算符 逻辑 非 ( !a ) 逻辑 与 ( a &amp;&amp; b ) 逻辑 或 ( a || b ) Swift 语言中逻辑运算符 &amp;&amp; 和 || 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的子表达式。 字符串字符串字面量即为常见的双引号内的内容： let a: String = “字符串字面量内容” 初始化一个空字符串Swift中，通常在创建一个字符串变量时要先初始化：其中： 12var testStr = &quot;&quot;var testString = String() 是一样的。 对 String 判空时优先采用 isEmpty。Swift 里面的 String 的 index 和 count 不是一一对应的（兼容 Unicode），所以 stirng.count == 0 的效率不如 string.isEmpty。 字符串可变性Swift 和 OC 的字符串有着很大的不同，在 OC 中字符串的是否可变是有 (NSString , NSMutableString) 来确定的。而Swift则统一由 “let” 和 “var” 来确定 12345let test1 = &quot;test1&quot;var test2 = &quot;look &quot;test2 += test1 // look test1 字符串是值类型Swift 的 String类型是一种值类型。如果你创建了一个新的 String值， String值在传递给方法或者函数的时候会被复制过去，还有赋值给常量或者变量的时候也是一样。每一次赋值和传递，现存的 String值都会被复制一次，传递走的是拷贝而不是原本。Swift 的默认拷贝 String行为保证了当一个方法或者函数传给你一个 String值，你就绝对拥有了这个 String值，无需关心它从哪里来。你可以确定你传走的这个字符串除了你自己就不会有别人改变它。 CharacterSwift 中，String 可以看做一个 Character 的集合， 而且 Character 值能且只能包含一个字符 123456789101112131415let char1: Character = &quot;1&quot;let char2: Character = &quot;+&quot;let char3: Character = &quot;1&quot;let str: String = String([char1,char2,char3]) // 1+2for character in &quot;1+2&quot; { print(character)}// 1// +// 2 字符串插值使用 ： \\(a) 来进行字符串插值 12345let a = 10let b = &quot;5 + 5 = \\(a)&quot;print(b) // &quot;5 + 5 = 10&quot; UnicodeSwift 的 String 和 Characte r类型是完全 Unicode 兼容的 字符串字面量中的特殊字符 转义特殊字符 \\0 (空字符)， \\ (反斜杠)， \\t (水平制表符)， \\n (换行符)， \\r(回车符)， &quot; (双引号) 以及 ' (单引号)； 任意的 Unicode 标量，写作 \\u{n}，里边的 n是一个 1-8 个与合法 Unicode 码位相等的16进制数字。let dollarSign = &quot;\\u{24}&quot; // $ 字符串的相关操作字符统计Swift中，Sting 的 count 属性可以获取该字符串的 Character值 的总数。 通过 count属性返回的字符统计并不会总是与包含相同字符的 NSString中 length属性相同。 NSString中的长度是基于在字符串的 UTF-16 表示中16位码元的数量来表示的，而不是字符串中 Unicode 扩展字形集群的数量。 字符串索引String.Index，它表示每个 Character 在字符串中的位置。 ( startIndex属性来访问 String中第一个 Character的位置。 endIndex属性就是 String中最后一个字符后的位置 ) 不同的字符会获得不同的内存空间来储存，所以为了明确哪个 Character 在哪个特定的位置，你必须从 String的开头或结尾遍历每一个 Unicode 标量。因此，Swift 的字符串不能通过整数值索引 123456789101112let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// ! 给的索引的前一个greeting[greeting.index(after: greeting.startIndex)]// u 给的索引的后一个let index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// a 给的索引的位移后的一个 endIndex索引对应的并不是一个有效字符，只是一个结束标识符，不能被访问 同样的，如果需要获取字符串的所有的索引，则可以使用indices属性 123456789let str = &quot;hello word&quot;for itemIndex in str.indices { print(str[itemIndex])}//hello word 插入和删除 插入 insert(_:at:) 插入字符 insert(contentsOf:at:) 插入字符串 12345var testStr = &quot;Hello, playground&quot;testStr.insert(&quot;!&quot;, at: testStr.endIndex) // &quot;Hello, playground!&quot;testStr.insert(contentsOf: &quot;Niko: &quot;, at: testStr.startIndex) // // &quot;Niko: Hello, playground!&quot; 删除 remove(at:) 特定索引位置移除字符 removeSubrange(_:) 移除一小段特定范围的字符串 12345var testStr = &quot;Niko: Hello, playground!&quot;testStr.remove(at: testStr.index(before: testStr.endIndex)) // Niko: Hello, playgroundtestStr.removeSubrange(testStr.startIndex...testStr.index(testStr.startIndex, offsetBy: 5)) // Hello, playground 子字符串Swift中获取自字符串也比较简单，直接通过索引获取就行了 12345var testStr = &quot;Niko: Hello, playground!&quot;let subTestStrTmp = testStr[testStr.startIndex...testStr.index(testStr.startIndex, offsetBy: 6)]print(String(subTestStrTmp)) // Niko: H Swift 中截取出的子字符串并不是 String 类型，因为处于优化的原因，SubString 并不不会单独用内存保存着组成这个字符串的字符，而是共享 被截取的String 的内存中的那些数据,所以如果你需要保存这个子字符串，则需要用 String 去初始化一下。 字符串比较两个 String值（或者两个 Character值）如果它们的扩展字形集群是规范化相等，则被认为是相等的。如果扩展字形集群拥有相同的语言意义和外形，我们就说它规范化相等，就算它们实际上是由不同的 Unicode 标量组合而成。 使用逻辑运算符中的 “==” 和 “！=” 即可 前缀和后缀相等性 hasPrefix(_:) 比较前缀相等 hasSuffix(_:) 比较后缀相等 12345let testStr = &quot;Niko: Hello, playground!&quot;print(testStr.hasPrefix(&quot;Niko&quot;)) // trueprint(testStr.hasSuffix(&quot;word!&quot;)) // false 集合数组初始化12345var list1 = [Int]()var list2 = [] 集合类Array初始化123var list1 = [Int]()var list2 = [] 数组的操作 array.count count属性可以查看数组的元素数量 array.isEmpty isEmpty可以直接查看数组是否为空 append(_:) 可以添加元素: array.append(&quot;元素&quot;) “+=” 可以直接加数组: array1 += [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;] insert(_ : at :) : 数组插入元素 : array.insert(&quot;元素&quot;, at: 0) remove(_:at:) 数组删除元素 ：array.remove(&quot;元素&quot;, at: 0) 数组下标: array[0]获取某个元素，或者array[0...2]获取某段数组 last 和 first 可以直接获取首尾的元素，这样可以避免使用count属性 for in 遍历数组的元素, for (index, value) in array.enumerated() 可以获取元素和索引 Set合集(Set) 将同一类型且不重复的值无序地储存在一个集合当中。当元素的顺序不那么重要的时候你就可以使用合集来代替数组，或者你需要确保元素不会重复的时候。 所有能储存在合集中的元素必须是可哈希的，所以如果需要自定义数据结构支持Set，就必须实现Swift的hashtable协议 初始化123456var valueTest = Set&lt;String&gt;()valueTest.insert(&quot;test&quot;)var sets: Set = [&quot;1&quot;,&quot;3&quot;,&quot;2&quot;] 合集的操作 array.count count属性可以查看合集的元素数量 array.isEmpty isEmpty可以直接查看合集是否为空 remove() 和 removeAll() 合集删除元素 ：array.remove(&quot;元素&quot;) array.removeAll() contains(_:) 检查合集中是否包含某个元素,返回布尔值：list.contains(&quot;元素&quot;) for in 遍历合集 合集的交并集 使用 intersection(_:)方法来创建一个只包含两个合集共有值的新合集； 使用 symmetricDifference(_:)方法来创建一个只包含两个合集各自有的非共有值的新合集； 使用 union(_:)方法来创建一个包含两个合集所有值的新合集； 使用 subtracting(_:)方法来创建一个两个合集当中不包含某个合集值的新合集。 使用“相等”运算符 ( == )来判断两个合集是否包含有相同的值； 使用 isSubset(of:) 方法来确定一个合集的所有值是被某合集包含； 使用 isSuperset(of:)方法来确定一个合集是否包含某个合集的所有值； 使用 isStrictSubset(of:) 或者 isStrictSuperset(of:)方法来确定是个合集是否为某一个合集的子集或者超集，但并不相等； 使用 isDisjoint(with:)方法来判断两个合集是否拥有完全不同的值。 Dictionary字典的初始化123456var namesOfIntegers = [Int: String]()var numsOfIntegers = [:]var namesDic = [&quot;name&quot;:&quot;1&quot;,&quot;sex&quot;:&quot;girl&quot;,&quot;age&quot;:&quot;19&quot;] 字典的操作 dic.count count属性可以查看字典的元素数量 dic.isEmpty isEmpty可以直接查看字典是否为空 可以直接添加新key来添加值： dic[&quot;新Key&quot;] = &quot;test&quot; removeValue(forkey:) 删除元素“ dic.removeValue(forKey: &quot;key&quot;) for (ley, value) in dic 遍历字典的键值对 控制流 推荐优先使用内置高阶函数。 for - infor - in 可以遍历集合类型的元素 123456789let list = [0,1,2,3]for item int list { print(&quot;\\(item)&quot;)}// 0 1 2 3 Whilewhile 循环通过判断单一的条件开始。如果条件为 true ，语句的合集就会重复执行直到条件变为 false 12345while x &lt; y { print(&quot;test&quot;)} repeat-while功能上等同于do-while if-elseif - else 和 OC 的条件语句的功能差不多，但是 Swift 中小括号不是必写的 SwitchSwift 的 Switch 与 OC 不一样，break不再是必须的情况，因为Swift中，进入case，执行完case内的语句后，接直接结束Switch语句了，不需要单独的break来结束，但是break在Swift中仍然有效，可根据习惯来写。 如果需要 OC 的Switch属性(case后会进入下个case，而不会直接结束)，则需要在case语句中，在末尾加入fallthrough而不是break就可以了 Switch 的灵活运用Swift 的 Switch 非常灵活 区间匹配1234567891011121314switch 15 {case 0: print(&quot;0&quot;)case 1...10: print(&quot;1&quot;)case 11..&lt;16: // right print(&quot;2&quot;)default: print(&quot;3&quot;)} 多条件1234567891011switch 3 {case 0,1,2: print(&quot;0&quot;)case 3,4,5: print(&quot;1&quot;) // rightdefault: print(&quot;3&quot;)} 元组123456789101112131415switch (1,9) {case (0,0): print(&quot;0&quot;)case (1,0): print(&quot;2&quot;)case (1,1): print(&quot;3&quot;)case (1,_): print(&quot;4&quot;) // rightdefault: print(&quot;5&quot;)} 值绑定123456789101112switch (9,0) {case (let x, 0): print(&quot;1&quot;) // rightcase (0, let y): print(&quot;2&quot;)default: print(&quot;3&quot;)} Where1234567891011121314switch (9,0) {case let (x, y) where x == y: print(&quot;0&quot;)case let (x, y) where x &lt; y: print(&quot;1&quot;)case let (x, y) where x &gt; y: print(&quot;2&quot;) // rightdefault: print(&quot;3&quot;)} guardguard 语句，类似于 if 语句，是 if 的反义词，基于布尔值表达式来执行语句。使用 guard 语句来要求一个条件必须是真才能执行 guard 之后的语句。与 if 语句不同， guard 语句总是有一个 else 分句—— else 分句里的代码会在条件不为真的时候执行 推荐优先使用 guard 1234567891011let test = &quot;test&quot;guard test == &quot;value&quot; else { print(&quot;0&quot;)}print(&quot;1&quot;)// 0 函数1234func usingFunctionName(name: String, age: Int) -&gt; Int { return 0} 在例子的函数中，如果不需要的部分都可以省略不写的： 1234567func usingFunctionName() { }// 省略的返回值和形参，表示不需要返回值和输入参数 在设计接口时，不要为每一个形参是否需要而编写一个方法了，减少方法数。同时，尽量使用默认形参，简化接口设计。 闭包闭包的表达式12345{ (parameters) -&gt; (return type) in statements } 闭包作为参数12345678910111213let testStr = [0,1,2,3,4,5,6,7,8,9]func testFunction(handler: @escaping () -&gt; String) { print(handler())}testFunction { () -&gt; String in return &quot;test&quot;}// test 通常在参数中用 (type) -&gt; retuntype 来作为闭包的表达式，并且需要加上 @escaping 来指明 @escaping 是表示这个闭包是逃逸闭包，允许在函数返回之后被调用 通常推荐 闭包做初始化。 1234567let testView: UIView = { let view = UIView() view.frame = CGRect.Zero return view}() 枚举枚举为一组相关值定义了一个通用类型，从而可以让你在代码中类型安全地操作这些值。 Swift 枚举语法用 enum关键字 来定义一个枚举，然后将其所有的定义内容放在一个大括号{}中 123456789101112enum nTest { case left case right case uppset case bottom}print(&quot;\\(nTest.left)&quot;)// left 遍历枚举情况Swift 中需要在枚举名字后面写上 CaseIterable 来允许枚举被遍历 1234567891011121314151617enum nTest: CaseIterable { case left case right case uppset case bottom}for item in nTest.allCases { print(&quot;\\(item)&quot;)}// left// right// uppset// bottom Swift 中枚举也可以嵌套 1234567891011enum nTest { case left case right enum mTest { case uppset case bottom }} 关联值定义 Swift 枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同。枚举其他语言中的 discriminated unions, tagged unions, 或者 variants 类似 123456789101112131415161718enum nTest { case name(String) case ageSix(Int, String)}var showDetail = nTest.name(&quot;name&quot;)showDetail = nTest.ageSix(19, &quot;boy&quot;)switch showDetail {case let .ageSix(x, y): print(&quot;\\(x) \\(y)&quot;)case let .name(z): print(&quot;\\(z)&quot;)}// 19 boy 原始值123456enum nTest { case name = &quot;lucy&quot; case age = &quot;girl&quot;} 可以给枚举值给予一个 默认的值。 如果只给其中一个枚举赋予了默认值，那么其他枚举会有一个隐式的默认值 比如: 12345678enum nTest { case left = 0 case right // 1 case upset // 2 case bottom // 3} 枚举用于用于命名空间声明Swift 的 Enum 比较适合用于命名空间的定义，能嵌套，且不存在初始化方法不会被用于其他作用。 123456789enum Event { enum Hander { static let login = &quot;event.handler.login&quot; }}// Event.Name.login ResultSwift也提供了一些非常好用枚举。比如说 Result，包含成功或者失败的枚举值，并持有相应成功或者失败的值，通过范型确定类型信息。因为成功和失败是互斥的，这样就可以避免多个可选参数返回。 类和结构体类和结构体是一种多功能且灵活的构造体。通过使用与现存常量、变量、函数完全相同的语法来在类和结构体当中定义属性和方法以添加功能. Swift不需要你为自定义类和结构体创建独立的接口和实现文件。在 Swift 中，你在一个文件中定义一个类或者结构体， 则系统将会自动生成面向其他代码的外部接口 值得注意的是： 类是引用类型 结构体和枚举是值类型 多定义 struct，少定义 class struct 是值类型，class 是引用类型。类类型分配在堆区，默认浅拷贝，容易被不经意间被改变，而值类型分配在栈区，默认深拷贝。 因此，即使是使用 class 时，也仅在必要时（如桥接到 ObjC，使用 Runtime 一些特性）继承自 NSObject。 定义12345678910111213class Test { var height = 100}struct TestStruct { var width = 200} 实例化12345let item = Test()let itemStruct = TestStruct() 属性访问12345item.heightitemStruct.width === 和 !==利用这两个恒等运算符来检查两个常量或者变量是否引用相同的实例 12345if obj_a === obj_b { print(&quot;obj_a 和 obj_b 都是同一个对象的引用&quot;)} 类和结构体之间的选择结构体实例总是通过值来传递，而类实例总是通过引用来传递 符合以下内容就使用结构体： 结构体的主要目的是为了封装一些相关的简单数据值； 当你在赋予或者传递结构实例时，有理由需要封装的数据值被拷贝而不是引用； 任何存储在结构体中的属性是值类型，也将被拷贝而不是被引用； 结构体不需要从一个已存在类型继承属性或者行为。 反之使用类 Swift 的 String , Array 和 Dictionary类型是作为结构体来实现的，这意味着字符串，数组和字典在它们被赋值到一个新的常量或者变量，亦或者它们本身被传递到一个函数或方法中的时候，其实是传递了拷贝。 这种行为不同于基础库中的 NSString, NSArray和 NSDictionary，它们是作为类来实现的，而不是结构体。 NSString , NSArray 和 NSDictionary实例总是作为一个已存在实例的引用而不是拷贝来赋值和传递。 在官方的推荐中，能用 Swift 标准库类型，尽量不用对应的 Foundation 类型。 属性属性可以将值与特定的类、结构体或者是枚举联系起来。存储属性会存储常量或变量作为实例的一部分，反之计算属性会计算（而不是存储）值。计算属性可以由类、结构体和枚举定义。存储属性只能由类和结构体定义。 存储属性存储属性是一个作为特定类和结构体实例一部分的常量或变量。存储属性要么是变量存储属性（由 var 关键字引入）要么是常量存储属性（由 let 关键字引入） lazy延迟存储属性的初始值在其第一次使用时才进行计算。你可以通过在其声明前标注 lazy 修饰语来表示一个延迟存储属性。 与 OC 中的懒加载很像 ，但是不用像 OC 一样重写 getter 方法 1234567891011121314class Test { lazy var num = 1 func fuction() { print(&quot;\\(num)&quot;) }}let tst = Test()tst.fuction() getter - setter （计算属性）与 OC 不同，Swift的getter和setter是 计算属性 ， 计算属性并不会存储属性的值。因此在每次调用计算属性时，都要计算该值。 12345678910111213141516171819class Test { var calNum = 0 var curNum: Int { get { return calNum } set { calNum = newValue } }}let tst = Test()tst.curNum = 1print(&quot;\\(tst.curNum)&quot;) 计算属性总是需要一个 getter。如果缺少 setter，则该属性被称为只读属性。 属性观察者属性观察者会观察并对属性值的变化做出回应。每当一个属性的值被设置时，属性观察者都会被调用，即使这个值与该属性当前的值相同。 willSet 会在改值被存储之前被调用 didSet 会在新值被存储后被调用 1234567891011121314151617181920class Test { var curNum: Int = 0 { willSet { print(&quot;newValue : \\(newValue)&quot;) } didSet { print(&quot;oldValue : \\(oldValue)&quot;) } }}let tst = Test()tst.curNum = 100print(&quot;\\(tst.curNum)&quot;)// newValue : 100// oldValue : 0// 100 继承一个类可以从另一个类继承方法、属性和其他的特性。当一个类从另一个类继承的时候，继承的类就是所谓的子类，而这个类继承的类被称为父类。 在 Swift 中类可以调用和访问属于它们父类的方法、属性和下标脚本，并且可以提供它们自己重写的方法，属性和下标脚本来定义或修改它们的行为。Swift 会通过检查重写定义都有一个与之匹配的父类定义来确保你的重写是正确的。 类也可以向继承的属性添加属性观察器，以便在属性的值改变时得到通知。可以添加任何属性监视到属性中，不管它是被定义为存储还是计算属性。 12345class SomeSubclass: SomeSuperclass { // subclass definition goes here} 重写 overideoverride 关键字会执行 Swift 编译器检查你重写的类的父类(或者父类的父类)是否有与之匹配的声明来供你重写。这个检查确保你重写的定义是正确的。 阻止重写 final你可以通过标记为终点来阻止一个方法、属性或者下标脚本被重写。通过在方法、属性或者下标脚本的关键字前写 final 修饰符(比如 final var ， final func ， final class func ， final subscript )。 初始化初始化是为类、结构体或者枚举准备实例的过程。这个过需要给实例里的每一个存储属性设置一个初始值并且在新实例可以使用之前执行任何其他所必须的配置或初始化。 init()初始化器在创建特定类型的实例时被调用。在这个简单的形式中，初始化器就像一个没有形式参数的实例方法，使用 init 关键字 1234567var test: Intinit() { // 初始化 test = 0} convenience 遍历构造器使用convenience修饰的构造函数叫做便利构造函数 required 必要初始化器在类的初始化器前添加 required 修饰符来表明所有该类的子类都必须实现该初始化器 当子类重写父类的必要初始化器时，必须在子类的初始化器前同样添加 required 修饰符以确保当其它类继承该子类时，该初始化器同为必要初始化器。在重写父类的必要初始化器时，不需要添加 override 修饰符 初始化过程Swift 的类初始化是一个两段式过程。在第一个阶段，每一个存储属性被引入类为分配了一个初始值。一旦每个存储属性的初始状态被确定，第二个阶段就开始了，每个类都有机会在新的实例准备使用之前来定制它的存储属性。 两段式初始化过程的使用让初始化更加安全，同时在每个类的层级结构给与了完备的灵活性。两段式初始化过程可以防止属性值在初始化之前被访问，还可以防止属性值被另一个初始化器意外地赋予不同的值。 初始化器的自动继承子类默认不会继承父类初始化器。但是在特定的情况下父类初始化器是可以被自动继承的 如果你的子类没有定义任何指定初始化器，它会自动继承父类所有的指定初始化器。 如果你的子类提供了所有父类指定初始化器的实现——要么是通过规则1继承来的，要么通过在定义中提供自定义实现的——那么它自动继承所有的父类便捷初始化器。 反初始化在类实例被释放的时候，反初始化器就会立即被调用。你可以是用 deinit 关键字来写反初始化器，就如同写初始化器要用 init 关键字一样。反初始化器只在类类型中有效. 12345deinit { // perform the deinitialization} 自动引用计数Swift 使用自动引用计数(ARC)机制来追踪和管理你的 App 的内存。 这点上，Swift 和 OC 非常相似。 引用计数只应用于类的实例。结构体和枚举是值类型，不是引用类型，没有通过引用存储和传递。 循环强引用因为可能导致，两个类实例互相强引用的情况，这样的话，两个对象的引用计数就永远不能为0，也就是说对象不会被销毁，内存不能释放。这种情况被称为 循环强引用。 而解决方法就是打断这个引用链，使用 ”weak“ 修饰其中某条引用即可。 12345test(){ [weak self] in guard let self = self else { return }} [weak self] 等同于 __weak typeof(self) weak_self = self; let self = self 等同于 __typeof__(self) strong_self = weak_self; 可选链可选链是一个调用和查询可选属性、方法和下标的过程，它可能为 nil 。如果可选项包含值，属性、方法或者下标的调用成功；如果可选项是 nil ，属性、方法或者下标的调用会返回 nil 。多个查询可以链接在一起，如果链中任何一个节点是 nil ，那么整个链就会得体地失败。 类型转换类型转换可以判断实例的类型，也可以将该实例在其所在的类层次中视为其父类或子类的实例。Swift 中类型转换的实现为 is 和 as 操作符. 类型检查 is使用类型检查操作符 （ is ）来检查一个实例是否属于一个特定的子类。如果实例是该子类类型，类型检查操作符返回 true ，否则返回 false 123456789var num:String = &quot;0&quot;if num is String { print(&quot;right&quot;)}// right 向下类型转换 as由于向下类型转换能失败，类型转换操作符就有了两个不同形式。条件形式， as? ，返回了一个你将要向下类型转换的值的可选项。强制形式， as! ，则将向下类型转换和强制展开结合为一个步骤。 Any 和 AnyObject AnyObject 可以表示任何类类型的实例。 Any 可以表示任何类型，包括函数类型。 Any类型表示了任意类型的值，包括可选类型。如果你给显式声明的Any类型使用可选项，Swift 就会发出警告。 内嵌类型若要在一种类型中嵌套另一种类型，在其支持类型的大括号内定义即可。可以根据需求多级嵌套数个类型。 123456789101112class Test { enum typeNum { case : one case : two }}let value = Test.typeNum.one 扩展功能与 OC 中的分类差不多，但是不会像 分类 一样有一个命名 扩展可以向一个类型添加新的方法，但是不能重写已有的方法 12345extension SomeClass { // add new methods} 扩展还可以添加 计算属性。 123456789101112extension SomeClass { var height: Int { return 100 } var width: Int { return 200 }} 扩展可以添加新的计算属性，但是不能添加存储属性，也不能向已有的属性添加属性观察者。 异变实例方法 mutating增加了扩展的实例方法仍可以修改（或异变）实例本身。结构体和枚举类型方法在修改 self 或本身的属性时必须标记实例方法为 mutating ，和原本实现的异变方法一样。 Swift中protocol的功能比OC中强大很多，不仅能再class中实现，同时也适用于struct、enum。但是struct、enum都是值类型，每个值都是有默认的，所以在实例方法中不能改变，因此就要用mutating关键字，这个关键字可以让在此方法中值的改变，会返回到原始结构里边 12345678910111213extension Int { mutating func add() { self = self + self }}var num = 1num.add() // 2 协议 protocol12345protocol SomeName {} 属性协议可以要求所有遵循该协议的类型提供特定名字和类型的实例属性或类型属性。协议并不会具体说明属性是储存型属性还是计算型属性——它只具体要求属性有特定的名称和类型。协议同时要求一个属性必须明确是可读的或可读的和可写的。 属性要求定义为变量属性，在名称前面使用 var 关键字。可读写的属性使用 { get set } 来写在声明后面来明确，使用 { get } 来明确可读的属性。 123456789protocol SomeProtocol { var num: Int { get set }}struct Test: SomeProtocl { var num: Int = 0} 异变方法 mutating有时一个方法需要改变（或异变）其所属的实例。例如值类型的实例方法（即结构体或枚举），在方法的 func 关键字之前使用 mutating 关键字，来表示在该方法可以改变其所属的实例，以及该实例的所有属性。 在TestPro协议的定义中， test() 方法使用 mutating 关键字标记，来表明该方法在调用时会改变遵循该协议的实例的状态： 12345protocol TestPro { mutating func test()} 初始化器协议可以要求遵循协议的类型实现指定的初始化器。和一般的初始化器一样，只用将初始化器写在协议的定义当中，只是不用写大括号也就是初始化器的实体： 12345protocol SomeProtocol { init(someParameter: Int)} 将协议作为类型实际上协议自身并不实现功能。不过你创建的任意协议都可以变为一个功能完备的类型在代码中使用。 在函数、方法或者初始化器里作为形式参数类型或者返回类型； 作为常量、变量或者属性的类型； 作为数组、字典或者其他存储器的元素的类型。 123456789class Test { var item: SomeProtocol }// item 的类型是 协议SomeProtocol，这样所有实现了SomeProtocol协议 的类的实例都可以赋值 item 委托委托是一个允许类或者结构体放手（或者说委托）它们自身的某些责任给另外类型实例的设计模式。这个设计模式通过定义一个封装了委托责任的协议来实现，比如遵循了协议的类型（所谓的委托）来保证提供被委托的功能。委托可以用来响应一个特定的行为，或者从外部资源取回数据而不需要了解资源具体的类型。 效果等同于 OC 中的代理 类专用的协议通过添加 AnyObject 关键字到协议的继承列表，你就可以限制协议只能被类类型采纳（并且不是结构体或者枚举 12345protocol SomeClassOnlyProtocol: AnyObject,SomeInheritedProtocol { // class-only protocol definition goes here} 可选协议 optional可选要求使用 optional 修饰符作为前缀放在协议的定义中。可选要求允许你的代码与 Objective-C 操作。协议和可选要求必须使用 @objc 标志标记。注意 @objc 协议只能被继承自 Objective-C 类或其他 @objc 类采纳。它们不能被结构体或者枚举采纳 提供默认实现你可以使用协议扩展来给协议的任意方法或者计算属性要求提供默认实现。如果遵循类型给这个协议的要求提供了它自己的实现，那么它就会替代扩展中提供的默认实现。 1234567extension PrettyTextRepresentable { var prettyTextualDescription: String { return textualDescription }} 面向协议编程Swift 中对于 Protocol 的功能进行了极大的加强。一定程度上能替代 抽象类 的左右。所以推荐使用 Protocol 来代替抽象类。 泛型泛型代码让你能根据你所定义的要求写出可以用于任何类型的灵活的、可复用的函数。你可以编写出可复用、意图表达清晰、抽象的代码。 比如：Array 、 Dictionary就支持泛型(Array&lt;T&gt;) 内存安全性默认情况下，Swift 会阻止你代码中发生的不安全行为。 访问控制访问控制限制其他源文件和模块对你的代码的访问。这个特性允许你隐藏代码的实现细节，并指定一个偏好的接口让其他代码可以访问和使用。 Open 访问 和 public 访问 允许实体被定义模块中的任意源文件访问，同样可以被另一模块的源文件通过导入该定义模块来访问。在指定框架的公共接口时，通常使用 open 或 public 访问。 open 和 public 访问 之间的区别将在之后给出； Internal 访问 允许实体被定义模块中的任意源文件访问，但不能被该模块之外的任何源文件访问。通常在定义应用程序或是框架的内部结构时使用。 File-private 访问 将实体的使用限制于当前定义源文件中。当一些细节在整个文件中使用时，使用 file-private 访问隐藏特定功能的实现细节。 private 访问 将实体的使用限制于封闭声明中。当一些细节仅在单独的声明中使用时，使用 private 访问隐藏特定功能的实现细节。 元组类型的访问级别是所有类型里最严格的。例如，如果你将两个不同类型的元素组成一个元组，一个元素的访问级别是 internal，另一个是 private，那么这个元组类型是 private 级别的。 高级运算符取反 运算符 ~位取反运算符（ ~ ）是对所有位的数字进行取反操作： 与 运算符 &amp;位与运算符（ &amp; ）可以对两个数的比特位进行合并。它会返回一个新的数，只有当这两个数都是 1 的时候才能返回 1 或 运算符位或运算符（ | ）可以对两个比特位进行比较，然后返回一个新的数，只要两个操作位任意一个为 1 时，那么对应的位数就为 1 ： 异或 运算符 ^位异或运算符，或者说“互斥或”（ ^ ）可以对两个数的比特位进行比较。它返回一个新的数，当两个操作数的对应位不相同时，该数的对应位就为 1 ： 左移 和 右移运算符 &lt;&lt; &gt;&gt;位左移运算符（ &lt;&lt; ）和位右移运算符（ &gt;&gt; ）可以把所有位数的数字向左或向右移动一个确定的位数，但是需要遵守下面定义的规则。 位左和右移具有给整数乘以或除以二的效果。将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。 例如：11111111 &lt;&lt; 1 和 11111111 &gt;&gt; 1 1234var num = 2print(&quot;\\(num &lt;&lt; 1)&quot;) // 4 KVOSwift 为 KVO 增加了方便好用的闭包API。 1234567891011// 创建一个NSKeyValueObservation类型的值var observation: NSKeyValueObservation?// 对webView添加监听，监听estimatedProgress属性observation = webView.observe(\\WKWebView.estimatedProgress, options: .new) { [weak self] (wkwebview, change) in guard let self = self else { return } print(&quot;已经加载 \\(change.newValue! * 100)%&quot;) self.progressview.progress = Float(wkwebview.estimatedProgress) } CodableSwift4之后则拥有Codable来直接编码或者解码JSON。 public typealias Codable = Decodable &amp; Encodable 123456789101112131415// 设置CityInfo遵循Decodable解码协议struct CityInfo: Decodable {// 变量和JSON里面的key也必须是一致的 var city: String var citykey: Int var parent: String var updateTime: String}// 解码JSON对象data, 将其转化成CityInfo对象guard let jsonModel = try? JSONDecoder().decode(CityInfo.self, from: data!) else { fatalError(&quot;`JSON Decode Failed`&quot;)} print(&quot;data: \\(jsonModel)&quot;)","link":"/2019/03/27/SwiftKnowledge/"},{"title":"iOS有时候会用到的小技巧","text":"iOS有时候会用到的小技巧记录文档 iOS有时候会用到的小技巧获取某个view所在的控制器12345678910111213- (UIViewController *)viewController{ UIViewController *viewController = nil; UIResponder *next = self.nextResponder; while (next) { if ([nextisKindOfClass:[UIViewController class]]) { viewController = (UIViewController *)next; break; } next = next.nextResponder; } return viewController;} iOS跳转到App Store下载应用评分1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=APPID&quot;]]; iOS 获取汉字的拼音123456789101112+ (NSString *)transform:(NSString *)chinese { //将NSString装换成NSMutableString NSMutableString *pinyin = [chinese mutableCopy]; //将汉字转换为拼音(带音标) CFStringTransform((__bridgeCFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO); NSLog(@&quot;%@&quot;, pinyin); //去掉拼音的音标 CFStringTransform((__bridgeCFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO); NSLog(@&quot;%@&quot;, pinyin); //返回最近结果 return pinyin; } 判断view是不是指定视图的子视图1BOOL isView = [textView isDescendantOfView:self.view]; 修改UITextField中Placeholder的文字颜色和大小123[self.textFieldsetValue:[UIColorredColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];[self.textFieldsetValue:[UIFontboldSystemFontOfSize:16] forKeyPath:@&quot;_placeholderLabel.font&quot;]; NSDateFormatter的格式123456789101112131415161718G: 公元时代，例如AD公元yy: 年的后2位yyyy: 完整年MM: 月，显示为1-12MMM: 月，显示为英文月份简写,如 JanMMMM: 月，显示为英文月份全称，如 Janualydd: 日，2位数表示，如02d: 日，1-2位显示，如 2EEE: 简写星期几，如SunEEEE: 全写星期几，如Sundayaa: 上下午，AM/PMH: 时，24小时制，0-23K：时，12小时制，0-11m: 分，1-2位mm: 分，2位s: 秒，1-2位ss: 秒，2位S: 毫秒 验证移动手机号：123456+ (BOOL)isMobile:(NSString*)mobile{ NSString *regex = @&quot;^1+[34578]+\\d{9}&quot;; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex]; return [pred evaluateWithObject:mobile];} 邮箱验证：123456+ (BOOL)isEmail:(NSString*)email{ NSString *regex = @&quot;^[\\\\w-]+(\\\\.[\\\\w-]+)*@[\\\\w-]+(\\\\.[\\\\w-]+)+$&quot;; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex]; return [pred evaluateWithObject:email];} 整形验证12345+ (BOOL)isPureInt:(NSString*)string{ NSScanner* scan = [NSScanner scannerWithString:string]; int val; return[scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];} 浮点型验证12345- (BOOL)isPureFloat:(NSString*)string{ NSScanner* scan = [NSScanner scannerWithString:string]; float val; return[scan scanFloat:&amp;val] &amp;&amp; [scan isAtEnd];} 中文验证123456+ (BOOL)isChinese:(NSString*)chinese{ NSString *regex = @&quot;^[\\u4e00-\\u9fa5]&quot;; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex]; return [pred evaluateWithObject: chinese];} 网址URL验证123456+ (BOOL)isURL:(NSString*)url{ NSString *regex = @&quot;[a-zA-z]+://[^\\s]*&quot;; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex]; return [pred evaluateWithObject: url];} 身份证号验证12345678910111213141516171819202122232425262728293031323334353637+ (BOOL)verifyIDCardNumber:(NSString *)IDCardNumber { IDCardNumber = [IDCardNumber stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; if ([IDCardNumber length] != 18) { return NO; } NSString *mmdd = @”(((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)(0[1-9]|[12][0-9]|30))|(02(0[1-9]|[1][0-9]|2[0-8])))”; NSString *leapMmdd = @”0229”; NSString *year = @”(19|20)[0-9]{2}”; NSString *leapYear = @”(19|20)(0[48]|[2468][048]|[13579][26])”; NSString *yearMmdd = [NSString stringWithFormat:@”%@%@”, year, mmdd]; NSString *leapyearMmdd = [NSString stringWithFormat:@”%@%@”, leapYear, leapMmdd]; NSString *yyyyMmdd = [NSString stringWithFormat:@”((%@)|(%@)|(%@))”, yearMmdd, leapyearMmdd, @”20000229”]; NSString *area = @”(1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|82|[7-9]1)[0-9]{4}”; NSString *regex = [NSString stringWithFormat:@”%@%@%@”, area, yyyyMmdd , @”[0-9]{3}[0-9Xx]”];NSPredicate *regexTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex];if (![regexTest evaluateWithObject:IDCardNumber]){ return NO;}int summary = ([IDCardNumber substringWithRange:NSMakeRange(0,1)].intValue + [IDCardNumber substringWithRange:NSMakeRange(10,1)].intValue) *7+ ([IDCardNumber substringWithRange:NSMakeRange(1,1)].intValue + [IDCardNumber substringWithRange:NSMakeRange(11,1)].intValue) *9+ ([IDCardNumber substringWithRange:NSMakeRange(2,1)].intValue + [IDCardNumber substringWithRange:NSMakeRange(12,1)].intValue) *10+ ([IDCardNumber substringWithRange:NSMakeRange(3,1)].intValue + [IDCardNumber substringWithRange:NSMakeRange(13,1)].intValue) *5+ ([IDCardNumber substringWithRange:NSMakeRange(4,1)].intValue + [IDCardNumber substringWithRange:NSMakeRange(14,1)].intValue) *8+ ([IDCardNumber substringWithRange:NSMakeRange(5,1)].intValue + [IDCardNumber substringWithRange:NSMakeRange(15,1)].intValue) *4+ ([IDCardNumber substringWithRange:NSMakeRange(6,1)].intValue + [IDCardNumber substringWithRange:NSMakeRange(16,1)].intValue) *2+ [IDCardNumber substringWithRange:NSMakeRange(7,1)].intValue *1 + [IDCardNumber substringWithRange:NSMakeRange(8,1)].intValue *6+ [IDCardNumber substringWithRange:NSMakeRange(9,1)].intValue *3;NSInteger remainder = summary % 11;NSString *checkBit = @&quot;&quot;;NSString *checkString = @&quot;10X98765432&quot;;checkBit = [checkString substringWithRange:NSMakeRange(remainder,1)];// 判断校验位return [checkBit isEqualToString:[[IDCardNumber substringWithRange:NSMakeRange(17,1)] uppercaseString]];} 一般用户名的验证123456+ (BOOL) isUserName:(NSString *)name{ NSString *userNameRegex = @&quot;^[A-Za-z0-9]{6,20}+$&quot;; NSPredicate *userNamePredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,userNameRegex]； return [userNamePredicate evaluateWithObject:name];} 像safari一样滑动的时候隐藏navigationbar1self.navigationController.hidesBarsOnSwipe = YES; 去掉plan模式下tableView尾部的多余横线1self.tableView.tableFooterView = [UIView new]; 设置导航透明 和 隐藏导航下面的线条123[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];self.navigationController.navigationBar.shadowImage = [UIImage new];","link":"/2017/03/02/TipsForiOS/"},{"title":"Swift Tips 翻译和笔记","text":"Swift Tips 翻译和笔记相关Swift Tips 文中以 Swift 5 为准 文档地址:SwiftTipsAwesomeSwift Swift 中使用 weakSelf 和 strongSelf12345// Block 内容function(){ [weak self] (data) in guard let self = self else { return } print(data)} ! 很危险，少用使用 if let guard let 等方式，避免 ！。 struct 很强大struct 是值类型，class 是引用类型。类类型分配在堆区，默认浅拷贝，容易被不经意间被改变，而值类型分配在栈区，默认深拷贝。所以优先使用struct enum 来做 命名空间1234567891011121314enum Define { enum Name { static let Token = &quot;token&quot; } enum URL { static let RequestURL = &quot;https://www.baidu.com&quot; } static let UserData = &quot;UserData&quot;}// Define.Name.Token// Define.UserData 优先guard123guard let newValue = Test() else { return} 面向协议编程Swift 中对于 Protocol 的功能进行了极大的加强。一定程度上能替代 抽象类 的左右。所以推荐使用 Protocol 来代替抽象类。 12345// 协议定义抽象方法和属性，用来代替面向对象的抽象类protocol SomeProtocol { var num: Int { get set } func test()} 1234// item 的类型是 协议SomeProtocol，这样所有实现了SomeProtocol协议 的类的实例都可以赋值 itemclass Test { var item: SomeProtocol} 对了，Swift中，Protocol也是可以扩展的，而且扩展中实现了协议方法，那么这个方法就会称为这个协议的默认实现 1234567891011121314protocol SomeProtocol { func method()}extension SomeProtocol { func method() { print(&quot;Test&quot;) }}struct MyStruct: SomeProtocol {}MyStruct().method()// 输出：// Test 善用extensionextension 虽然在功能上类似 分类，但是却更加的灵活。除了分类的作用外，还可以对类进行方法分化 1234567891011121314151617class Test { init()}extension Test { // 实现私有方法 private func someFunc() {}}extension Test { // 实现对外接口 private func someFunc() {}}extension Test: SomeProtocol { // 实现相关协议方法} Swift 中的 KVO 闭包API1234567891011121314// 创建 NSKeyValueObservation 变量，这个变量必须有var observation: NSKeyValueObservation?fun observationFunc() { // 按照方法提示添加监听 observation = webView.observe(\\WKWebView.estimatedProgress, options: .new) { [weak self] (wkwebview, change) in // 必须使用weak self，不然很容易出现循环引用 guard let self = self else { return } print(&quot;已经加载 \\(change.newValue! * 100)%&quot;) self.progressview.progress = Float(wkwebview.estimatedProgress) }}","link":"/2020/03/24/SwiftTips/"},{"title":"如何从 Swift 过度到 TypeScript","text":"TypeScript具有类型系统，且是JavaScript的超集。 它可以编译成普通的JavaScript代码。 TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。 同时，TypeScript 也是 CocosCreator 的推荐脚本之一。 如何从 Swift 过度到 TypeScriptlogSwift： print(&quot;Hello, world!&quot;) TypeScript： console.log(&quot;Hello, world!&quot;); 变量 与 常量Swift： 12var myVariable = 42let myConstant = 50 TypeScript： 12var myVariable = 42;const myConstant = 50; 声明类型Swift： 1var myVariable: Int = 50 TypeScript： 1var myVariable: number = 50; 类型强制转换Swift： 12let newCount = 50let newString = String(newCount) TypeScript： 12let newCount = 50;let newString = String(newCount); String 中间插入Swift： 12let newCount = 50let newString = &quot;test \\(newCount)&quot; TypeScript： 12let newCount = 50;let newString = &quot;test&quot; + newCount; 遍历Swift： 12for index in 0..&lt;5 {} TypeScript： 12for (let index = 0 ; index &lt; 5 ; index++){} ArraySwift： 1var list = [&quot;1&quot;,&quot;2&quot;] TypeScript： 12var shoppingList: string[] = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;]; 参考 官方文档swift like typescript","link":"/2020/03/20/TypeScriptWithSwift/"},{"title":"Visual Studio Code 学习","text":"Visual Studio Code是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统且开放源代码的代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全、代码片段和代码重构等。 文章使用平台 macOS Catalina 10.15.3 Visual Studio Code 学习编辑器的基础点 快捷键 语言与框架支持 工作流的选择和支持 支持用户写插件来定制功能 前三点是下限，最后一点是上限 界面介绍 通过 F1 或者Cmd+Shift+P 可以打开 命令面板,然后在命令面板中快速搜索命令并且执行。 左边的竖栏则是文件管理、搜索、代码管理、debug、插件扩展等功能项。 在 命令面板 中，输入 shell，可以看到一个 installed code in PATH. 选项，选择安装后，就可以直接在 控制台 中用 code 指令完成相关 vscode 的快速操作了。而code的常见指令在code --help 中就可以看到。最简单的例子:code test.js，即创建一个test.js文件 快捷键 Option + 左右方向键 ： 把光标移动到当前单词的最前面。如果一直使用 Option 和方向键，那么光标移动的颗粒度就变成了单词，你就可以在文档中以单词为单位不停地移动光标了。 Option + 上下方向键 ： 将当前行，或者当前选中的几行代码，在编辑器里上下移动。 Cmd + 左右方向键 ：把光标移动到行首或者行末。 Cmd + 上下方向键 ：把光标移动到文件的顶部或者尾部。 组合 Shift ： 在Option和Cmd的很多控制光标位置的快捷键中，组合加上Shift键，则会添加选中功能。 组合 Delete ： 与Shift同理。 Cmd + Shift + \\ ：当在{ }中是，会移动到{ }的括号前方或者后方。 Cmd + Shift + K : 删除当前行。 Cmd + X ：剪切当前行。 Cmd + / ： 注释当前行。 Option + Shift + 上下方向键 ： 向上或下复制当前行。 Option + Shift + F ： 格式化代码。 Cmd + P ： 最近打开文件 + 搜索。 Cmd + Shift + O ： 查看文件中所有的函数或者代码块。 Cmd + 鼠标 ： 查看函数实现。 Ctrl + 减号 ： 返回上一次访问的文件 F1 ： 打开命令控制台 F2 ： 统一修改所有的 函数名 或者 类名，方便重构 自定义快捷键 ：命令面板输入keyboard shortcuts 即可。 codesnippet代码片段是对常用代码的一个抽象，它保留了大部分不变的代码，然后把需要经常变动的部分，换成变量，这样等下次调用它的时候，只需要把这些变量换成我们需要的就可以了。 在命令控制台中输入 Configure User Snippets，然后选择需要设置 代码片段 的语言。 然后按照以下格式添加 CodeSnippet 12345678&quot;Print to console&quot;: { &quot;prefix&quot;: &quot;log&quot;, &quot;body&quot;: [ &quot;console.log('$1');&quot;, &quot;$2&quot; ], &quot;description&quot;: &quot;代码片段描述&quot;} prefix 是在编辑器中打出 该字符 就可以打出对应的 代码片段 body 是代码片段 的内容 description 是描述 Print to console 是该 代码片段 的名字 参考 VSCode 官方文档 VSCode 开发者文档 极客时间-玩转VSCode","link":"/2020/03/28/VSCodeLearning/"},{"title":"UITxtView跟随KeyBoard弹起收回","text":"iOS开发中，经常需求点击输入框后，键盘弹起，而输入框也会出现在键盘上方，以UITxtView为例来实现。 UITxtView跟随KeyBoard弹起收回 效果展示键盘弹起后，自定义的输入框会出现在键盘上方，和键盘相吸。因为通常还有输入框高度自适应内容的需求，所以以UITxtView来处理这个问题的情况居多。 所以以评论框为例展示开发过程。 开发过程创建单例因为弹起状态的评论框通常是单个出现的，所以为了方便使用，我们可以设置成单例。 12345678910111213class CommentManager: NSObject {// 创建单例static let shared: CommentManager = { let manager = CommentManager() return manager }() // 私有化 init() private override init() { super.init() }} 设置子视图通常我们会包含两个子视图： 可点击的淡灰色背景 可输入内容的输入框 所以我们先创建好两个子视图: 12345678910111213var backgroudView: UIView = { let view = UIView(frame: UIScreen.main.bounds) view.backgroundColor = UIColor(red: 0, green: 0, blue: 0, alpha: 0.6) return view}()var textView: UITextView = { let view = UITextView(frame: CGRect(x: 0, y: DefineConst.HScreen, width: DefineConst.WScreen, height: 100)) view.backgroundColor = .white view.layer.borderColor = UIColor.lightGray.cgColor view.layer.borderWidth = 2 return view}() 配置视图在初始化中，我们配置好子视图所需要的相关设置： 123456789101112131415161718192021222324private override init() { super.init() // 在初始化中配置 configView() } deinit { // 取消通知 NotificationCenter.default.removeObserver(self) } private func configView() { // textView设置delegate，并且添加到backgroudView上面 textView.delegate = self backgroudView.addSubview(textView) // backgroudView添加点击手势 backgroudView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(backGroudTaphander))) // 添加键盘通知 NotificationCenter.default.addObserver(self, selector: #selector(keyboardFameChangeHander(notif:)), name: UIResponder.keyboardWillShowNotification, object: nil) } 处理相关事件主要是处理背景点击事件 和 键盘的通知事件 12345678910111213141516171819202122232425262728// 背景点击，取消焦点，并且删除backgroudView@objc private func backGroudTaphander() { textView.resignFirstResponder() backgroudView.removeFromSuperview()} @objc private func keyboardFameChangeHander(notif: Notification) { // 获取通知的 键盘弹出时间，和键盘Fram let duration = notif.userInfo?[UIResponder.keyboardAnimationDurationUserInfoKey] as! Float let keyFrame = notif.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as! CGRect // 键盘弹出时提供一个textView的弹出动画 if keyFrame.origin.y &gt;= backgroudView.bounds.height { UIView.animate(withDuration: TimeInterval(duration)) { self.textView.frame = CGRect(x: 0, y: DefineConst.HScreen, width: DefineConst.WScreen, height: 100) } } else { // 键盘不是弹出时，提供一个textView的回缩动画 textView.frame = CGRect(x: 0, y: DefineConst.HScreen, width: DefineConst.WScreen, height: 100) let curKeyboardFrameH = DefineConst.HScreen - keyFrame.size.height - textView.bounds.height UIView.animate(withDuration: TimeInterval(duration)) { self.textView.frame = CGRect(x: 0, y: curKeyboardFrameH, width: DefineConst.WScreen, height: 100) } }} 开放接口对外提供一个调用接口，方便直接使用。 123456789public func showCommentInputView() { // 将backgroudView添加到keywindow上面 let window = DefineConst.KeyWindow window?.addSubview(backgroudView) // textView获取焦点 textView.becomeFirstResponder()}","link":"/2018/11/01/UITextViewMakeKeyboardView/"},{"title":"iOS - Runloop","text":"iOS中的runloop简单的理解就是类似do-while循环的一个机制，用来保持线程处于长期运行状态，而不是让程序运行一次就直接结束了(对比网络的等待请求状态和APP的形成)，这类一般被称为Event Loop。 iOS - Runloop介绍OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef，用于管理这这类 Event Loop : CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 runloop 与 线程runloop 与 线程 在iOS中是一一对应的，其关系是保存在一个全局的 Dictionary 里。 并且只有主线程默认打开了Runloop，子线程需要手动打开 在线程创建时并不是同时创建runloop，runloop也不允许手动创建。只能通过API获取，通过[NSRunLoop currentRunLoop] - (面向对象API，不是是线程安全的)或者CFRunLoopGetCurrent() - (C语言函数API， 线程安全的)来获取。而runloop在获取runloop时会自动创建(主线程runloop除外，在程序开始时已经被创建了). 1234567CFRunLoopRef CFRunLoopGetMain() { return _CFRunLoopGet(pthread_main_thread_np());} CFRunLoopRef CFRunLoopGetCurrent() { return _CFRunLoopGet(pthread_self());} runLoop 的 相关类Core Foundation中关于RunLoop的5个类： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef CFRunLoopModeRefrunloop的运行模式 一个runloop有若干个model 每个model有若干个(Source/Timer/Observer) 每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode 如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。(这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。) 系统默认注册好了五个model。分别是： kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode 其中常用的是：kCFRunLoopDefaultModeUITrackingRunLoopModekCFRunLoopCommonModes CFRunLoopSourceRefrunloop的事件源 按照函数调用栈的分类: Source0: event事件，只含有回调(函数指针)，需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop Source1: 包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。 CFRunLoopTimerRefCFRunLoopTimerRef是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 GCD不受runloop的model影响 CFRunLoopObserverRef每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop}; 使用： 12345678910111213- (void)observer{ // 创建observer CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { NSLog(@&quot;----监听到RunLoop状态发生改变---%zd&quot;, activity); }); // 添加观察者：监听RunLoop的状态 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // 释放Observer CFRelease(observer);} CF的内存管理（Core Foundation） 凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release(比如CFRunLoopObserverCreate) release函数：CFRelease(对象); RunLoop 的 运行过程如图：runloop就是这样的一个do-while循环 Runloop 常用点仅仅谈谈我知道的内容 轮播广告使用NStimer控制轮播，然后model使用NSDefaultRunLoopMode，因为NSDefaultRunLoopMode的优先级比UITrackingRunLoopMode低，使用当手动滑动的时候会自动停止轮播，停止手动操作后自动还原。如果使用kCFRunLoopCommonModes则可以定时滚动不受影响 滑动列表界面图片加载控制当列表需要加载大量图片的时候，因为渲染在runloop中执行，所以图片一多质量一高就有可能会卡。方案： 先把显示代码保存在一个个block，然后存入数组中 监听runloop循环 每一次循环在数组中只取出一个block并执行，执行过的代码从数组中remove 一直持续到数组为空 参考 参考:深入理解RunLoop","link":"/2017/12/06/iOS_Runloop/"},{"title":"iOS编译原理","text":"iOS的编译,使用了基于LLVM的编译器。Clang(或者Swift)作为编译前端,LLVM作为后端,将代码文件编译为当前架构所对应的可执行文件 iOS编译原理编译编译指的是，将 一门语言(通常针对开发者) 所写的程序 转化为 目标语言(通常针对机器) 的程序 。而实现这个过程的工具则是编译器 编译器 通常分为 前端 和 后端。 前端: 分析代码，生成 后端 使用的中间码。 后端: 针对机器架构，生成对应的可执行机器码。 前后端分离: 这样设计的好处则是,支持新语言的时候,只需要修改前端;支持新底层架构,只需改后端了。 LLVMLLVM 是一个自由软件项目，它是一种以C++写成编译器基础设施。利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而当前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。 在基于LLVM的编译器中，前端将代码进行检查(语法检查等)和解析，并生产中间代码LLVM IR。该IR选择对应的类型，对代码进行优化，然后被发送到代码生成器，根据本机的架构生成对应的机器代码。 ClangClang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了LLVM作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。 Clang项目包括Clang前端和Clang静态分析器等. Clang作为编译前端，完成 语法分析，语义分析，生成中间代码 等工作。比如我们常见的语法警告和错误提示就在这一过程中完成。 编程语言类型 编译语言 编译语言在执行的时候，通过编译器生成机器码，机器码直接在CPU上执行。 例如: Objective-C, Swift, C/C++ 等 直译式语言 直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为CPU可以执行的代码。 例如: JavaScript iOS编译iOS 编译采用了 Clang+LLVM 的方式。Clang作为前端，LLVM作为后端。 简单的文件编译过程: (Swift的话，前端则不是Clang，而是Swift) 代码文件 =&gt; Clang 预处理(Preprocessor) 宏的替换, 头文件的导入, 删除注释等 词法分析(lexical anaysis) 读入源程序的输入字符，将它们组成词素，生成并输出一个词法单元序列(Token)的过程。 语法分析(semantic analysis) 将Token生成抽象语法树(AST) 对这个树进行分析，找出代码中的错误。 生成中间代码（LLVM IR） 将语法树自顶向下遍历逐步翻译成 LLVM IR(中间码) LLVM Optimizer 选择对应的类型 LLVM Code Generator 优化IR 生成Target相关汇编码 汇编器以汇编代码作为输入，将汇编代码转换为机器代码 连接器把编译产生的.o文件和（dylib,a,tbd）文件Link，生成一个mach-o文件 =&gt; Mach-O格式的可执行文件 mach-o文件 是记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。 Mach-O 文件包含三个区域: Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等 Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。 Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。 完整全过程: 编译信息写入辅助文件，创建文件架构 .app 文件 把Entitlements.plist写入到DerivedData里，处理打包的时候需要的信息（比如application-identifier）。 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名 xcode中的编译设置编译配置信息都存储在这个文件(.xcodeprog)里,例如CocoaPod就是通过修改(.xcodeprog)文件来完成相关第三方库的打包链接的。 Build Phases Target Dependencies 是用来指定编译顺序的。 是指需要先编译好Target Dependencies中的库， 才能编译当前Target。显式声明了依赖关系。 Compile Sources 需要编译的的代码文件(.m文件) Link Binary With Libraries 项目中的静态库和动态库,它们会和编译生成的目标文件进行链接 Copy Bundle Resources 打包资源文件(StoryBoard,Xib,Strings,Assets等) [CP]Check Pods Manifest.lock 用来检查cocoapod管理的三方库是否需要更新(在引入Pod后才有这个选项)[CocoaPod的自定义脚本,所有前面有CP的都是。] Build RulesBuild Rules 指定了不同的文件类型如何处理以及输出在哪。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。 Build SettingsBuild Settings 指定了在 build 的过程中各个阶段的选项的设置,配置每个任务的详细内容. Link Linker把编译器编译生成的多个文件，链接成一个可执行文件。 通常链接器的输入为： .o 文件 动态库 静态库 只包含符号的库文件(符号是一段代码或者数据的名称) Clang Module从上面的内容可知，我们在导入头文件的时候，通常预处理器在处理的时候会把这一行替换成对应头文件的文本。 但是这种直接替换，在某些时候会产生一定的问题: 当头文件过多的时候，会产生大量的预处理消耗 当头文件替换的时候，不同的头文件里面的宏定义可能会因为命名一样而被覆盖 边界不明显。拿到一组.a和.h文件，很难确定.h是属于哪个.a的，需要以什么样的顺序导入才能正确编译。 clang module不再使用文本模型，而是采用更高效的语义模型。clang module提供了一种新的导入方式:@import，module会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率。 在Target的build setting中，设置define module为YES，则可以启动Clang Module。 #import &lt;Foundation/NSString.h&gt;的时候，编译器会检查NSString.h是否在一个module里，如果是的话，这一行会被替换成@import Foundation。","link":"/2019/01/22/iOSCompilation/"}],"tags":[{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"二进制","slug":"二进制","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"计算机原理","slug":"计算机原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"字符编码","slug":"字符编码","link":"/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"自主学习","slug":"自主学习","link":"/tags/%E8%87%AA%E4%B8%BB%E5%AD%A6%E4%B9%A0/"},{"name":"知识产权","slug":"知识产权","link":"/tags/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83/"},{"name":"MD5","slug":"MD5","link":"/tags/MD5/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"经济","slug":"经济","link":"/tags/%E7%BB%8F%E6%B5%8E/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"}],"categories":[{"name":"Daily","slug":"Daily","link":"/categories/Daily/"},{"name":"Mobile","slug":"Mobile","link":"/categories/Mobile/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}