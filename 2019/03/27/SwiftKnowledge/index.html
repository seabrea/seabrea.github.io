<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Swif学习总结 - BLOG</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="BLOG"><meta name="msapplication-TileImage" content="img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="BLOG"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Swift 作为 Objective-C 的新世代，已经成为了苹果首推的iOS开发语言，而且 Swift 的相关开发内容已经逐渐成熟，使用 Swift 开发的项目也越来越多，Swift5.0 后 Swift 也基本趋于稳定，因此Swift已经成为了iOS开发人员的必备能力了。"><meta property="og:type" content="blog"><meta property="og:title" content="Swif学习总结"><meta property="og:url" content="http://seabrea.xyz/2019/03/27/SwiftKnowledge/"><meta property="og:site_name" content="BLOG"><meta property="og:description" content="Swift 作为 Objective-C 的新世代，已经成为了苹果首推的iOS开发语言，而且 Swift 的相关开发内容已经逐渐成熟，使用 Swift 开发的项目也越来越多，Swift5.0 后 Swift 也基本趋于稳定，因此Swift已经成为了iOS开发人员的必备能力了。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://s2.ax1x.com/2019/03/27/AaOaee.jpg"><meta property="og:image" content="https://cnswift.content-delivery.top/wp-content/uploads/2018/01/stringSubstring_2x.png"><meta property="og:image" content="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/setVennDiagram_2x.png"><meta property="og:image" content="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseNOT_2x.png"><meta property="og:image" content="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseAND_2x.png"><meta property="og:image" content="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseOR_2x.png"><meta property="og:image" content="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseXOR_2x.png"><meta property="og:image" content="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitshiftUnsigned_2x.png"><meta property="article:published_time" content="2019-03-27T06:00:00.000Z"><meta property="article:modified_time" content="2022-02-22T08:05:15.387Z"><meta property="article:author" content="Sea Brea"><meta property="article:tag" content="iOS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s2.ax1x.com/2019/03/27/AaOaee.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://seabrea.xyz/2019/03/27/SwiftKnowledge/"},"headline":"Swif学习总结","image":["https://s2.ax1x.com/2019/03/27/AaOaee.jpg","https://cnswift.content-delivery.top/wp-content/uploads/2018/01/stringSubstring_2x.png","https://cnswift.content-delivery.top/wp-content/uploads/2015/08/setVennDiagram_2x.png","https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseNOT_2x.png","https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseAND_2x.png","https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseOR_2x.png","https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseXOR_2x.png","https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitshiftUnsigned_2x.png"],"datePublished":"2019-03-27T06:00:00.000Z","dateModified":"2022-02-22T08:05:15.387Z","author":{"@type":"Person","name":"Sea Brea"},"publisher":{"@type":"Organization","name":"BLOG","logo":{"@type":"ImageObject","url":"http://seabrea.xyz/2019/03/27/SwiftKnowledge/img/avatar.png"}},"description":"Swift 作为 Objective-C 的新世代，已经成为了苹果首推的iOS开发语言，而且 Swift 的相关开发内容已经逐渐成熟，使用 Swift 开发的项目也越来越多，Swift5.0 后 Swift 也基本趋于稳定，因此Swift已经成为了iOS开发人员的必备能力了。"}</script><link rel="canonical" href="http://seabrea.xyz/2019/03/27/SwiftKnowledge/"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="BLOG" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seabrea"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-27T06:00:00.000Z" title="2019/3/27 下午2:00:00">2019-03-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-02-22T08:05:15.387Z" title="2022/2/22 下午4:05:15">2022-02-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Mobile/">Mobile</a></span><span class="level-item">an hour read (About 11091 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Swif学习总结</h1><div class="content"><blockquote>
<p><strong>Swift</strong> 作为 <strong>Objective-C</strong> 的新世代，已经成为了苹果首推的iOS开发语言，而且 <strong>Swift</strong> 的相关开发内容已经逐渐成熟，使用 <strong>Swift</strong> 开发的项目也越来越多，<strong>Swift5.0</strong> 后 <strong>Swift</strong> 也基本趋于稳定，因此<strong>Swift</strong>已经成为了iOS开发人员的必备能力了。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2019/03/27/AaOaee.jpg"></p>
<span id="more"></span>

<h1 id="Swif学习总结"><a href="#Swif学习总结" class="headerlink" title="Swif学习总结"></a>Swif学习总结</h1><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="数据类型和集合类型"><a href="#数据类型和集合类型" class="headerlink" title="数据类型和集合类型"></a>数据类型和集合类型</h3><p>Swift新提供了一套新的数据类型</p>
<ul>
<li>整型: <strong>Int</strong></li>
<li>浮点: <strong>Double</strong> <strong>Float</strong></li>
<li>布尔型: <strong>Bool</strong></li>
<li>字符串: <strong>String</strong></li>
<li>数组: <strong>Array</strong></li>
<li>字典: <strong>Dictionary</strong></li>
<li>组合: <strong>Set</strong></li>
</ul>
<h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><p>Swift使用 <code>let</code> 和 <code>var</code> 来最为常量和变量的修饰符</p>
<p>常量和变量在Swift中，如果要使用，必须先声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let testNum = 1</span><br><span class="line">var testStr = &quot;test&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在开发过程中，如果是不会别修改的变量，也需要用<code>let</code>声明为常量。</p>
<blockquote>
<p>Swift 使用了 let 和 var 关键字直接用于区分是否可变。可变会更容易出错，所以尽量采用不可变设计，等到需要改变才改为 var 吧。</p>
</blockquote>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>Swift中换行是不需要分号的，但是如果一行里写多句代码，分号还是需要的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let testString = &quot;Test&quot;</span><br><span class="line">print(testString)</span><br><span class="line"></span><br><span class="line">let testNum = 0; print(&quot;\(testNum)&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据类型的范围"><a href="#数据类型的范围" class="headerlink" title="数据类型的范围"></a>数据类型的范围</h3><p>Swift中可以使用<code>minValue</code>或者<code>maxValue</code>来获取当前数据的类型的最小最大值</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>Swift 提供了 8，16，32 和 64 位编码的有符号和无符号整数<code>Int8,UInt8 ... Int64,UInt64</code></p>
<p>而 Int 和 UInt 则和CPU有关，</p>
<p>在 32位平台上， Int和UInt的长度 等于 Int32 和 UInt32<br>在 64位平台上， Int和UInt的长度 等于 Int64 和 UInt64</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li>Double 至少15位数字的精度(64位的浮点数)</li>
<li>Float 6位数字的精度(32位的浮点数)</li>
</ul>
<p>通常情况下，Double和Float都可以使用的时候，推荐使用Double</p>
<h3 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h3><p>Swift中，整数和浮点数类型的转换必须显式地指定类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let num1 = 1</span><br><span class="line">let num2 = 1.1</span><br><span class="line"></span><br><span class="line">// 显式的将浮点数转换为整数</span><br><span class="line">let num3 = num1 + Int(num2)    </span><br><span class="line"></span><br><span class="line">// 显式的将整数转换为浮点数</span><br><span class="line">let num4 = Double(num1) + num2 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在用浮点数初始化一个新的整数类型的时候，数值会被截断。也就是说 1.95 会变成 1 ， -3.5 会变为 -3</p>
</blockquote>
<h3 id="类型别名-typealias"><a href="#类型别名-typealias" class="headerlink" title="类型别名 typealias"></a>类型别名 <em>typealias</em></h3><p>typealias修饰词的作用类似Objective-C中的typedef，可以为已经存在的类型定义了一个新的可选名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typealias NewType = UInt</span><br><span class="line">var maxNewType = Newtype.maxValue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组把多个值合并成单一的复合型的值。元组内的值可以是任何类型，而且可以不必是同一类型。</p>
<blockquote>
<p>元组 也是Swift 比较推荐使用的方式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个简单的元组</span><br><span class="line">let postCode1 = (44,&quot;OK&quot;,3.1415)</span><br><span class="line"></span><br><span class="line">//创建一个命名元组</span><br><span class="line">let postCode2 = (x: 5, y: 3)</span><br><span class="line"></span><br><span class="line">// 不同的类型</span><br><span class="line">let postCode3 = (name: &quot;Carl&quot;, age: 78, pets: [&quot;Bonny&quot;, &quot;Houdon&quot;, &quot;Miki&quot;])</span><br><span class="line"></span><br><span class="line">// 访问元组元素</span><br><span class="line">postCode1.0 // 44</span><br><span class="line">postCode1.1 // &quot;OK&quot;</span><br><span class="line"></span><br><span class="line">postCode2.x // 5</span><br><span class="line">postCode2.y // 3</span><br><span class="line"></span><br><span class="line">//元组拆解</span><br><span class="line">let (x, y, z) = postCode1</span><br><span class="line">print(&quot;\(x)&quot;,&quot;\(y)&quot;,&quot;\(z)&quot;) // 44,&quot;OK&quot;,3.1415</span><br><span class="line"></span><br><span class="line">let (h, _, _) = postCode1 // 不需要的数据可以直接用&quot;_&quot;来代替</span><br><span class="line">print(&quot;\(h)&quot;) // 44</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>元组</strong>适合于<strong>简单的数据组合</strong>，复杂的数据组合还是使用使用<strong>类或者结构体</strong></p>
<p>需要临时组合一些相关值的时候，元组非常有用。如果数据结构需要在临时范围之外仍然存在。那就把它抽象成类或者结构体</p>
</blockquote>
<h3 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h3><p>Swift的可选项用来处理一些可能为nil的值，来保证安全性，提示这个值可能为nil.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let newNum = Int(&quot;哈哈哈哈&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“哈哈哈哈”并不能被Int转换成一个整数，所以这次转换可能会失败,newNum可能会为nil，所以Int()会返回一个 Int？，而Int？后面的？号代表这时一个可选项</p>
</blockquote>
<h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>Swift 中的 nil 和 Objective-C 中的 nil 是不一样的，OC 中的 nil 是一个指向不存在对象的指针，只有对象可以设置为 nil。在 Swift中， nil 不是指针，他是值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象类型</p>
<p>同样的，如果Swift中要给一个变量设置为 nil， 则需要使用 可选项</p>
<p><code>var newString: String? = nil</code></p>
<h3 id="可选值的强制展开"><a href="#可选值的强制展开" class="headerlink" title="可选值的强制展开"></a>可选值的强制展开</h3><p>因为可选项的存在，可选值可能为空，所以在使用可选值的时候必须进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if newString != nil &#123;</span><br><span class="line">	print(“newString”)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是有的时候，我们已经知道这个值是一定不为空的，不需要再做多余的判断了，就可以直接使用 “！” 来强制展开，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(newString!)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为强制展开可选值的要求严格，如果强制展开了一个nil，则会导致崩溃，所以小心使用.</p>
<p>！遇到 nil 时会 crash（包括 as! 进行强制转换）。可以使用 if let&#x2F;guard let&#x2F;case let 配合 as? 将可选值消化掉。所以能不用！就不要用！</p>
</blockquote>
<h3 id="可选项绑定"><a href="#可选项绑定" class="headerlink" title="可选项绑定"></a>可选项绑定</h3><p>因为强制展开充满了危机，所以我们可以使用 if语句 和 变量常量 的结合，进行可选项绑定，来安全处理可选值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if let newNum = Int(unknownString) &#123;</span><br><span class="line">	print(&quot;\(newNum)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	print(&quot;error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>if let newNum = Int(unknownString)</code>中，如果Int(unknownString)不为nil，则newNum则是展开后的值，为空则进入else语块</p>
<p>同时也支持变量<code>if var newNum = Int(unknownString)</code>,方便在if代码块中操作newNum。</p>
</blockquote>
<h3 id="隐式展开可选项"><a href="#隐式展开可选项" class="headerlink" title="隐式展开可选项"></a>隐式展开可选项</h3><p>当一个值在使用的时候一定不为nil，但是在初始化的时候是可能为nil的，就可以使用<strong>隐式展开可选项</strong></p>
<p>在iOS中，有个很简单的例子，就是ViewController中的View，在初始化的过程中，并不是一定有值，可能为nil。但是在我们使用的过程中，View是一定有值，所以这个时候，用的是就是 <code>view!</code>(隐式展开可选项)</p>
<p>因此我们在创建一个初始化可能为nil，但是使用的时候一定有值得 变量或者常量的时候就可以使用了。</p>
<blockquote>
<p>如果你在隐式展开可选项没有值的时候还尝试获取值，会导致运行错误。结果和在没有值的普通可选项后面加一个叹号一样。</p>
</blockquote>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>相比于可选项的通过值是否缺失来判断程序的执行正确与否，而错误处理机制能允许你判断错误的形成原因，在必要的情况下，还能将你的代码中的错误传递到程序的其他地方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 可能会抛出异常的函数</span><br><span class="line">func testFunction() throws &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 通过 do-try-catch 块来处理异常 </span><br><span class="line">do &#123;</span><br><span class="line">    try testFunction() // 查看函数是否异常</span><br><span class="line">    testFinish() // 无异常则调用此函数		</span><br><span class="line">&#125; catch Error.OutOfCleanDishes &#123; // 异常满足此条件，则调用这个catch块中的内容</span><br><span class="line">    testShowError()</span><br><span class="line">&#125; catch Error.MissingIngredients(let ingredients) &#123;</span><br><span class="line">    testShowErroContent(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>OC 中很多返回 NSError 的函数在，Swift中都改为了使用throws，所以出现throws时务必使用 do-catch 处理。</p>
</blockquote>
<h4 id="断言调试-assert"><a href="#断言调试-assert" class="headerlink" title="断言调试(assert)"></a>断言调试(assert)</h4><p>使用全局函数 assert(<em>:</em>:)  函数来写断言。向 assert(<em>:</em>:) 函数传入一个结果为 true 或者 false 的表达式以及一条会在结果为 false 的时候显式的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func assert(@autoclosure condition: () -&gt; Bool,</span><br><span class="line">            @autoclosure _ message: () -&gt; String = default,</span><br><span class="line">                              file: StaticString = default,</span><br><span class="line">                              line: UInt = default)</span><br></pre></td></tr></table></figure>

<p>断言只会在 Debug 模式下起作用，在 Release 版本中是被忽略的。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let testNum = 3</span><br><span class="line">assert(testNum &lt; 0, &quot;Num Error !&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>testNum &lt; 0 为false，断言被触发，应用终止。</p>
</blockquote>
<h4 id="先决条件-precondition"><a href="#先决条件-precondition" class="headerlink" title="先决条件(precondition)"></a>先决条件(precondition)</h4><p>precondition 在使用和作用上和 assert 类似</p>
<p>precondition 与 assert 的区别在于：</p>
<ul>
<li>assert只在debug环境下生效，而precondition是debug和release都生效 ( <em>断言是在测试期间的理性检查，而前提条件是防御的事情，如果发生，意味着你的程序只是不能合理地进行</em> )</li>
</ul>
<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><h3 id="X元运算符"><a href="#X元运算符" class="headerlink" title="X元运算符"></a>X元运算符</h3><ul>
<li>一元运算符对一个目标进行操作（比如 -a  ）。一元前缀运算符在目标之前直接添加（比如 !b ），同时一元后缀运算符直接在目标末尾添加（比如 c! ）。</li>
<li>二元运算符对两个目标进行操作（比如 a + b  ）同时因为它们出现在两个目标之间，所以是中缀。</li>
<li>三元运算符操作三个目标：三元条件运算符（  a ? b : c ）。</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符 “&#x3D;” ，可以将右侧内容更新左侧内容。</p>
<p>但是 Swift 的赋值符号自身不会返回值,所以类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x = y &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的使用的禁止的</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul>
<li>加    ( + )</li>
<li>减    ( - )</li>
<li>乘    ( * )</li>
<li>除    ( &#x2F; )</li>
<li>求余数 ( % ) （考虑负数运算，所以不是取模）</li>
</ul>
<h3 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符"></a>合并空值运算符</h3><p>合并空值运算符 （ a ?? b ）如果可选项 a  有值则展开，如果没有值，是 nil  ，则返回默认值 b 。表达式 a 必须是一个可选类型。表达式 b  必须与 a  的储存类型相同。</p>
<p><code>a ?? b =====&gt;  (a != nil) ? a! : b</code></p>
<h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><ul>
<li>闭区间运算符: <strong>a…b</strong>(a &lt;&#x3D; b) , 定义了a到b，同时包含a和b的一系列数据</li>
<li>半开区间运算符: <strong>a..&lt;b</strong>(a &lt; b) , 定义了从 a  到 b  但不包括 b  的区间，即 半开</li>
<li>单侧区间: 闭区间有另外一种形式来让区间朝一个方向尽可能的远, <strong>array[a…]</strong>(a到该数组末尾，[…a]则相反为数组开始到a)</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>逻辑 非  ( !a )</li>
<li>逻辑 与  ( a &amp;&amp; b )</li>
<li>逻辑 或  ( a || b )</li>
</ul>
<blockquote>
<p>Swift 语言中逻辑运算符 &amp;&amp; 和 || 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的子表达式。</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>即为常见的双引号内的内容： <code>let a: String = “字符串字面量内容”</code></p>
<h3 id="初始化一个空字符串"><a href="#初始化一个空字符串" class="headerlink" title="初始化一个空字符串"></a>初始化一个空字符串</h3><p>Swift中，通常在创建一个字符串变量时要先初始化：<br>其中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var testStr = &quot;&quot;</span><br><span class="line">var testString = String()</span><br></pre></td></tr></table></figure>
<p>是一样的。</p>
<blockquote>
<p> 对 String 判空时优先采用 isEmpty。<br>Swift 里面的 String 的 index 和 count 不是一一对应的（兼容 Unicode），所以 stirng.count &#x3D;&#x3D; 0 的效率不如 string.isEmpty。</p>
</blockquote>
<h3 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h3><p>Swift 和 OC 的字符串有着很大的不同，在 OC 中字符串的是否可变是有 (NSString , NSMutableString) 来确定的。<br>而Swift则统一由 “let” 和 “var” 来确定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let test1 = &quot;test1&quot;</span><br><span class="line">var test2 = &quot;look &quot;</span><br><span class="line">test2 += test1 // look test1</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h3><p>Swift 的 String类型是一种值类型。如果你创建了一个新的 String值， String值在传递给方法或者函数的时候会被复制过去，还有赋值给常量或者变量的时候也是一样。每一次赋值和传递，现存的 String值都会被复制一次，传递走的是拷贝而不是原本。Swift 的默认拷贝 String行为保证了当一个方法或者函数传给你一个 String值，你就绝对拥有了这个 String值，无需关心它从哪里来。你可以确定你传走的这个字符串除了你自己就不会有别人改变它。</p>
<h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>Swift 中，String 可以看做一个 Character 的集合， 而且 Character 值能且只能包含一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let char1: Character = &quot;1&quot;</span><br><span class="line">let char2: Character = &quot;+&quot;</span><br><span class="line">let char3: Character = &quot;1&quot;</span><br><span class="line"></span><br><span class="line">let str: String = String([char1,char2,char3]) // 1+2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for character in &quot;1+2&quot; &#123;</span><br><span class="line">    print(character)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// +</span><br><span class="line">// 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>使用 ： <code>\(a)</code> 来进行字符串插值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a = 10</span><br><span class="line">let b = &quot;5 + 5 = \(a)&quot;</span><br><span class="line">print(b) // &quot;5 + 5 = 10&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Swift 的 String 和 Characte r类型是完全 Unicode 兼容的</p>
<h3 id="字符串字面量中的特殊字符"><a href="#字符串字面量中的特殊字符" class="headerlink" title="字符串字面量中的特殊字符"></a>字符串字面量中的特殊字符</h3><ul>
<li>转义特殊字符 \0 (空字符)， \ (反斜杠)， \t (水平制表符)， \n (换行符)， \r(回车符)， &quot; (双引号) 以及 &#39; (单引号)；</li>
<li>任意的 Unicode 标量，写作 \u{n}，里边的 n是一个 1-8 个与合法 Unicode 码位相等的16进制数字。<code>let dollarSign = &quot;\u&#123;24&#125;&quot; // $</code></li>
</ul>
<h3 id="字符串的相关操作"><a href="#字符串的相关操作" class="headerlink" title="字符串的相关操作"></a>字符串的相关操作</h3><h4 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a>字符统计</h4><p>Swift中，Sting 的 count 属性可以获取该字符串的 Character值 的总数。</p>
<blockquote>
<p>通过 count属性返回的字符统计并不会总是与包含相同字符的 NSString中 length属性相同。 NSString中的长度是基于在字符串的 UTF-16 表示中16位码元的数量来表示的，而不是字符串中 Unicode 扩展字形集群的数量。 </p>
</blockquote>
<h4 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h4><p>String.Index，它表示每个 Character 在字符串中的位置。 ( startIndex属性来访问 String中第一个 Character的位置。 endIndex属性就是 String中最后一个字符后的位置 )</p>
<blockquote>
<p>不同的字符会获得不同的内存空间来储存，所以为了明确哪个 Character 在哪个特定的位置，你必须从 String的开头或结尾遍历每一个 Unicode 标量。因此，Swift 的字符串不能通过整数值索引</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let greeting = &quot;Guten Tag!&quot;</span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line">// G</span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line">// !   给的索引的前一个</span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line">// u   给的索引的后一个</span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 7)</span><br><span class="line">greeting[index]</span><br><span class="line">// a   给的索引的位移后的一个</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>endIndex索引对应的并不是一个有效字符，只是一个结束标识符，不能被访问</p>
</blockquote>
<p>同样的，如果需要获取字符串的所有的索引，则可以使用indices属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let str = &quot;hello word&quot;</span><br><span class="line"></span><br><span class="line">for itemIndex in str.indices &#123;</span><br><span class="line">    print(str[itemIndex])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hello word</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><ul>
<li>插入<ul>
<li>insert(_:at:) 插入字符</li>
<li>insert(contentsOf:at:) 插入字符串</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var testStr = &quot;Hello, playground&quot;</span><br><span class="line">testStr.insert(&quot;!&quot;, at: testStr.endIndex) // &quot;Hello, playground!&quot;</span><br><span class="line">testStr.insert(contentsOf: &quot;Niko: &quot;, at: testStr.startIndex) // // &quot;Niko: Hello, playground!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>删除<ul>
<li>remove(at:) 特定索引位置移除字符</li>
<li>removeSubrange(_:) 移除一小段特定范围的字符串</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var testStr = &quot;Niko: Hello, playground!&quot;</span><br><span class="line">testStr.remove(at: testStr.index(before: testStr.endIndex)) // Niko: Hello, playground</span><br><span class="line">testStr.removeSubrange(testStr.startIndex...testStr.index(testStr.startIndex, offsetBy: 5)) // Hello, playground</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h4><p>Swift中获取自字符串也比较简单，直接通过索引获取就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var testStr = &quot;Niko: Hello, playground!&quot;</span><br><span class="line">let subTestStrTmp = testStr[testStr.startIndex...testStr.index(testStr.startIndex, offsetBy: 6)]</span><br><span class="line">print(String(subTestStrTmp)) // Niko: H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Swift 中截取出的子字符串并不是 String 类型，因为处于优化的原因，SubString 并不不会单独用内存保存着组成这个字符串的字符，而是共享 被截取的String 的内存中的那些数据,所以如果你需要保存这个子字符串，则需要用 String 去初始化一下。</p>
<p><img src="https://cnswift.content-delivery.top/wp-content/uploads/2018/01/stringSubstring_2x.png"></p>
</blockquote>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>两个 String值（或者两个 Character值）如果它们的扩展字形集群是规范化相等，则被认为是相等的。如果扩展字形集群拥有相同的语言意义和外形，我们就说它规范化相等，就算它们实际上是由不同的 Unicode 标量组合而成。</p>
<p>使用逻辑运算符中的 “&#x3D;&#x3D;” 和 “！&#x3D;” 即可</p>
<h4 id="前缀和后缀相等性"><a href="#前缀和后缀相等性" class="headerlink" title="前缀和后缀相等性"></a>前缀和后缀相等性</h4><ul>
<li>hasPrefix(_:) 比较前缀相等</li>
<li>hasSuffix(_:) 比较后缀相等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let testStr = &quot;Niko: Hello, playground!&quot;</span><br><span class="line">print(testStr.hasPrefix(&quot;Niko&quot;))  // true</span><br><span class="line">print(testStr.hasSuffix(&quot;word!&quot;)) // false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var list1 = [Int]()</span><br><span class="line"></span><br><span class="line">var list2 = []</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list1 = [Int]()</span><br><span class="line"></span><br><span class="line">var list2 = []</span><br></pre></td></tr></table></figure>

<h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><ul>
<li><code>array.count</code> count属性可以查看数组的元素数量</li>
<li><code>array.isEmpty</code> isEmpty可以直接查看数组是否为空</li>
<li><code>append(_:)</code> 可以添加元素: <code>array.append(&quot;元素&quot;)</code></li>
<li>“+&#x3D;” 可以直接加数组: <code>array1 += [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code></li>
<li><code>insert(_ : at :)</code> : 数组插入元素 : <code>array.insert(&quot;元素&quot;, at: 0)</code></li>
<li><code>remove(_:at:)</code> 数组删除元素 ：<code>array.remove(&quot;元素&quot;, at: 0)</code></li>
<li>数组下标: <code>array[0]</code>获取某个元素，或者<code>array[0...2]</code>获取某段数组</li>
<li><code>last</code> 和 <code>first</code> 可以直接获取首尾的元素，这样可以避免使用count属性</li>
<li><code>for in</code> 遍历数组的元素, <code>for (index, value) in array.enumerated()</code> 可以获取元素和索引</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>合集(Set)</strong> 将同一类型且不重复的值无序地储存在一个集合当中。当元素的顺序不那么重要的时候你就可以使用合集来代替数组，或者你需要确保元素不会重复的时候。</p>
<blockquote>
<p>所有能储存在合集中的元素必须是可哈希的，所以如果需要自定义数据结构支持Set，就必须实现Swift的hashtable协议</p>
</blockquote>
<h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var valueTest = Set&lt;String&gt;()</span><br><span class="line">valueTest.insert(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">var sets: Set = [&quot;1&quot;,&quot;3&quot;,&quot;2&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="合集的操作"><a href="#合集的操作" class="headerlink" title="合集的操作"></a>合集的操作</h4><ul>
<li><code>array.count</code> count属性可以查看合集的元素数量</li>
<li><code>array.isEmpty</code> isEmpty可以直接查看合集是否为空</li>
<li><code>remove()</code> 和 <code>removeAll()</code> 合集删除元素 ：<code>array.remove(&quot;元素&quot;)  array.removeAll()</code></li>
<li><code>contains(_:)</code> 检查合集中是否包含某个元素,返回布尔值：<code>list.contains(&quot;元素&quot;)</code></li>
<li><code>for in</code> 遍历合集</li>
</ul>
<h4 id="合集的交并集"><a href="#合集的交并集" class="headerlink" title="合集的交并集"></a>合集的交并集</h4><p><img src="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/setVennDiagram_2x.png"></p>
<ul>
<li>使用 intersection(_:)方法来创建一个只包含两个合集共有值的新合集；</li>
<li>使用 symmetricDifference(_:)方法来创建一个只包含两个合集各自有的非共有值的新合集；</li>
<li>使用 union(_:)方法来创建一个包含两个合集所有值的新合集；</li>
<li>使用 subtracting(_:)方法来创建一个两个合集当中不包含某个合集值的新合集。</li>
</ul>
<hr>
<ul>
<li>使用“相等”运算符 ( &#x3D;&#x3D; )来判断两个合集是否包含有相同的值；</li>
<li>使用 isSubset(of:) 方法来确定一个合集的所有值是被某合集包含；</li>
<li>使用 isSuperset(of:)方法来确定一个合集是否包含某个合集的所有值；</li>
<li>使用 isStrictSubset(of:) 或者 isStrictSuperset(of:)方法来确定是个合集是否为某一个合集的子集或者超集，但并不相等；</li>
<li>使用 isDisjoint(with:)方法来判断两个合集是否拥有完全不同的值。</li>
</ul>
<h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><h4 id="字典的初始化"><a href="#字典的初始化" class="headerlink" title="字典的初始化"></a>字典的初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var namesOfIntegers = [Int: String]()</span><br><span class="line">var numsOfIntegers = [:]</span><br><span class="line"></span><br><span class="line">var namesDic = [&quot;name&quot;:&quot;1&quot;,&quot;sex&quot;:&quot;girl&quot;,&quot;age&quot;:&quot;19&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h4><ul>
<li><code>dic.count</code> count属性可以查看字典的元素数量</li>
<li><code>dic.isEmpty</code> isEmpty可以直接查看字典是否为空</li>
<li>可以直接添加新key来添加值： <code>dic[&quot;新Key&quot;] = &quot;test&quot;</code></li>
<li><code>removeValue(forkey:)</code> 删除元素“ <code>dic.removeValue(forKey: &quot;key&quot;)</code></li>
<li><code>for (ley, value) in dic</code> 遍历字典的键值对</li>
</ul>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><blockquote>
<p>推荐优先使用内置高阶函数。</p>
</blockquote>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for - in"></a>for - in</h3><p><code>for - in</code> 可以遍历集合类型的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let list = [0,1,2,3]</span><br><span class="line"></span><br><span class="line">for item int list &#123;</span><br><span class="line">	print(&quot;\(item)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 0 1 2 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="While"><a href="#While" class="headerlink" title="While"></a>While</h3><p>while 循环通过判断单一的条件开始。如果条件为 true ，语句的合集就会重复执行直到条件变为 false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while x &lt; y &#123;</span><br><span class="line">	print(&quot;test&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="repeat-while"><a href="#repeat-while" class="headerlink" title="repeat-while"></a>repeat-while</h3><p>功能上等同于<code>do-while</code></p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>if - else 和 OC 的条件语句的功能差不多，但是 Swift 中小括号不是必写的</p>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>Swift 的 Switch 与 OC 不一样，break不再是必须的情况，因为Swift中，进入case，执行完case内的语句后，接直接结束Switch语句了，不需要单独的break来结束，但是break在Swift中仍然有效，可根据习惯来写。</p>
<blockquote>
<p>如果需要 OC 的Switch属性(case后会进入下个case，而不会直接结束)，则需要在case语句中，在末尾加入<code>fallthrough</code>而不是<code>break</code>就可以了</p>
</blockquote>
<h4 id="Switch-的灵活运用"><a href="#Switch-的灵活运用" class="headerlink" title="Switch 的灵活运用"></a>Switch 的灵活运用</h4><p>Swift 的 Switch 非常灵活</p>
<h5 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">switch 15 &#123;</span><br><span class="line"></span><br><span class="line">case 0:</span><br><span class="line">	print(&quot;0&quot;)</span><br><span class="line">case 1...10:</span><br><span class="line">	print(&quot;1&quot;)</span><br><span class="line">case 11..&lt;16: // right</span><br><span class="line">	print(&quot;2&quot;)</span><br><span class="line">default:</span><br><span class="line">	print(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="多条件"><a href="#多条件" class="headerlink" title="多条件"></a>多条件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">switch 3 &#123;</span><br><span class="line">case 0,1,2:</span><br><span class="line">	print(&quot;0&quot;)</span><br><span class="line">case 3,4,5:</span><br><span class="line">	print(&quot;1&quot;) // right</span><br><span class="line">default:</span><br><span class="line">	print(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">switch (1,9) &#123;</span><br><span class="line">case (0,0):</span><br><span class="line">	print(&quot;0&quot;)</span><br><span class="line">case (1,0):</span><br><span class="line">	print(&quot;2&quot;)</span><br><span class="line">case (1,1):</span><br><span class="line">	print(&quot;3&quot;)</span><br><span class="line">case (1,_):</span><br><span class="line">	print(&quot;4&quot;) // right</span><br><span class="line">default:</span><br><span class="line">	print(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">switch (9,0) &#123;</span><br><span class="line"></span><br><span class="line">case (let x, 0):</span><br><span class="line">	print(&quot;1&quot;)  // right</span><br><span class="line">case (0, let y):</span><br><span class="line">	print(&quot;2&quot;)</span><br><span class="line">default:</span><br><span class="line">	print(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">switch (9,0) &#123;</span><br><span class="line"></span><br><span class="line">case let (x, y) where x == y:</span><br><span class="line">	print(&quot;0&quot;)</span><br><span class="line">case let (x, y) where x &lt; y:</span><br><span class="line">	print(&quot;1&quot;)</span><br><span class="line">case let (x, y) where x &gt; y: </span><br><span class="line">	print(&quot;2&quot;) // right</span><br><span class="line">default:</span><br><span class="line">	print(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h3><p>guard 语句，类似于 if 语句，是 if 的反义词，基于布尔值表达式来执行语句。使用 guard 语句来要求一个条件必须是真才能执行 guard 之后的语句。与 if 语句不同， guard 语句总是有一个 else 分句—— else 分句里的代码会在条件不为真的时候执行</p>
<blockquote>
<p>推荐优先使用 guard</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let test = &quot;test&quot;</span><br><span class="line"></span><br><span class="line">guard test == &quot;value&quot; else &#123;</span><br><span class="line">	print(&quot;0&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">// 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func usingFunctionName(name: String, age: Int) -&gt; Int &#123;</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在例子的函数中，如果不需要的部分都可以省略不写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func usingFunctionName() &#123;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 省略的返回值和形参，表示不需要返回值和输入参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在设计接口时，不要为每一个形参是否需要而编写一个方法了，减少方法数。同时，尽量使用默认形参，简化接口设计。</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包的表达式"><a href="#闭包的表达式" class="headerlink" title="闭包的表达式"></a>闭包的表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; (parameters) -&gt; (return type) in</span><br><span class="line">   statements</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="闭包作为参数"><a href="#闭包作为参数" class="headerlink" title="闭包作为参数"></a>闭包作为参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let testStr = [0,1,2,3,4,5,6,7,8,9]</span><br><span class="line"></span><br><span class="line">func testFunction(handler: @escaping () -&gt; String) &#123;</span><br><span class="line">    print(handler())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testFunction &#123; () -&gt; String in</span><br><span class="line">    return &quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通常在参数中用 <code>(type) -&gt; retuntype</code> 来作为闭包的表达式，并且需要加上 <code>@escaping</code> 来指明</p>
<p><code>@escaping</code> 是表示这个闭包是逃逸闭包，允许在函数返回之后被调用</p>
<p>通常推荐 <strong>闭包做初始化</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let testView: UIView = &#123; </span><br><span class="line">	let view = UIView()</span><br><span class="line">	view.frame = CGRect.Zero</span><br><span class="line">	return view</span><br><span class="line">&#125;()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举为一组相关值定义了一个通用类型，从而可以让你在代码中类型安全地操作这些值。</p>
<h3 id="Swift-枚举语法"><a href="#Swift-枚举语法" class="headerlink" title="Swift 枚举语法"></a>Swift 枚举语法</h3><p>用 enum关键字 来定义一个枚举，然后将其所有的定义内容放在一个大括号{}中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum nTest &#123;</span><br><span class="line">    case left</span><br><span class="line">    case right</span><br><span class="line">    case uppset</span><br><span class="line">    case bottom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;\(nTest.left)&quot;)</span><br><span class="line"></span><br><span class="line">// left</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遍历枚举情况"><a href="#遍历枚举情况" class="headerlink" title="遍历枚举情况"></a>遍历枚举情况</h3><p>Swift 中需要在枚举名字后面写上 CaseIterable 来允许枚举被遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum nTest: CaseIterable &#123;</span><br><span class="line">    case left</span><br><span class="line">    case right</span><br><span class="line">    case uppset</span><br><span class="line">    case bottom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for item in nTest.allCases &#123;</span><br><span class="line">    print(&quot;\(item)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// left</span><br><span class="line">// right</span><br><span class="line">// uppset</span><br><span class="line">// bottom</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Swift 中枚举也可以嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum nTest &#123;</span><br><span class="line">    case left</span><br><span class="line">    case right</span><br><span class="line">    </span><br><span class="line">    enum mTest &#123;</span><br><span class="line">    		case uppset</span><br><span class="line">    		case bottom</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><p>定义 Swift 枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同。枚举其他语言中的 discriminated unions, tagged unions, 或者 variants 类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum nTest &#123;</span><br><span class="line">    case name(String)</span><br><span class="line">    case ageSix(Int, String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var showDetail = nTest.name(&quot;name&quot;)</span><br><span class="line">showDetail = nTest.ageSix(19, &quot;boy&quot;)</span><br><span class="line"></span><br><span class="line">switch showDetail &#123;</span><br><span class="line">case let .ageSix(x, y):</span><br><span class="line">    print(&quot;\(x)   \(y)&quot;)</span><br><span class="line">case let .name(z):</span><br><span class="line">    print(&quot;\(z)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 19   boy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum nTest &#123;</span><br><span class="line">    case name = &quot;lucy&quot;</span><br><span class="line">    case age = &quot;girl&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以给枚举值给予一个 默认的值。</p>
<blockquote>
<p>如果只给其中一个枚举赋予了默认值，那么其他枚举会有一个隐式的默认值</p>
</blockquote>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum nTest &#123;</span><br><span class="line">    case left = 0</span><br><span class="line">    case right  // 1</span><br><span class="line">    case upset  // 2</span><br><span class="line">    case bottom // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="枚举用于用于命名空间声明"><a href="#枚举用于用于命名空间声明" class="headerlink" title="枚举用于用于命名空间声明"></a>枚举用于用于命名空间声明</h3><p>Swift 的 Enum 比较适合用于命名空间的定义，能嵌套，且不存在初始化方法不会被用于其他作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Event &#123;</span><br><span class="line">    enum Hander &#123;</span><br><span class="line">        static let login = &quot;event.handler.login&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Event.Name.login</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Swift也提供了一些非常好用枚举。比如说 Result，包含成功或者失败的枚举值，并持有相应成功或者失败的值，通过范型确定类型信息。因为成功和失败是互斥的，这样就可以避免多个可选参数返回。</p>
<h2 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h2><p>类和结构体是一种多功能且灵活的构造体。通过使用与现存常量、变量、函数完全相同的语法来在类和结构体当中定义属性和方法以添加功能.</p>
<blockquote>
<p>Swift不需要你为自定义类和结构体创建独立的接口和实现文件。在 Swift 中，你在一个文件中定义一个类或者结构体， 则系统将会自动生成面向其他代码的外部接口</p>
</blockquote>
<blockquote>
<p>值得注意的是：</p>
<ul>
<li>类是引用类型</li>
<li>结构体和枚举是值类型</li>
</ul>
</blockquote>
<p><strong>多定义 struct，少定义 class</strong></p>
<blockquote>
<p>struct 是值类型，class 是引用类型。类类型分配在堆区，默认浅拷贝，容易被不经意间被改变，而值类型分配在栈区，默认深拷贝。</p>
<p>因此，即使是使用 class 时，也仅在必要时（如桥接到 ObjC，使用 Runtime 一些特性）继承自 NSObject。</p>
</blockquote>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">	var height = 100</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TestStruct &#123;</span><br><span class="line"></span><br><span class="line">	var width = 200</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let item = Test()</span><br><span class="line"></span><br><span class="line">let itemStruct = TestStruct()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">item.height</span><br><span class="line"></span><br><span class="line">itemStruct.width</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-x3D-和-x3D-x3D"><a href="#x3D-x3D-x3D-和-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D;</h3><p>利用这两个恒等运算符来检查两个常量或者变量是否引用相同的实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if obj_a === obj_b &#123;</span><br><span class="line">    print(&quot;obj_a 和 obj_b 都是同一个对象的引用&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类和结构体之间的选择"><a href="#类和结构体之间的选择" class="headerlink" title="类和结构体之间的选择"></a>类和结构体之间的选择</h3><p>结构体实例总是通过值来传递，而类实例总是通过引用来传递</p>
<p>符合以下内容就使用结构体：</p>
<ul>
<li>结构体的主要目的是为了封装一些相关的简单数据值；</li>
<li>当你在赋予或者传递结构实例时，有理由需要封装的数据值被拷贝而不是引用；</li>
<li>任何存储在结构体中的属性是值类型，也将被拷贝而不是被引用；</li>
<li>结构体不需要从一个已存在类型继承属性或者行为。</li>
</ul>
<p>反之使用类</p>
<blockquote>
<p>Swift 的 String , Array 和 Dictionary类型是作为结构体来实现的，这意味着字符串，数组和字典在它们被赋值到一个新的常量或者变量，亦或者它们本身被传递到一个函数或方法中的时候，其实是传递了拷贝。</p>
<p>这种行为不同于基础库中的 NSString, NSArray和 NSDictionary，它们是作为类来实现的，而不是结构体。 NSString , NSArray 和 NSDictionary实例总是作为一个已存在实例的引用而不是拷贝来赋值和传递。</p>
<blockquote>
<p>在官方的推荐中，能用 Swift 标准库类型，尽量不用对应的 Foundation 类型。</p>
</blockquote>
</blockquote>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性可以将值与特定的类、结构体或者是枚举联系起来。存储属性会存储常量或变量作为实例的一部分，反之计算属性会计算（而不是存储）值。计算属性可以由类、结构体和枚举定义。存储属性只能由类和结构体定义。</p>
<h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><p>存储属性是一个作为特定类和结构体实例一部分的常量或变量。存储属性要么是变量存储属性（由 var  关键字引入）要么是常量存储属性（由 let  关键字引入）</p>
<h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><p>延迟存储属性的初始值在其第一次使用时才进行计算。你可以通过在其声明前标注 lazy 修饰语来表示一个延迟存储属性。</p>
<blockquote>
<p>与 OC 中的懒加载很像 ，但是不用像 OC 一样重写 getter 方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">    </span><br><span class="line">    lazy var num = 1</span><br><span class="line">    </span><br><span class="line">    func fuction() &#123;</span><br><span class="line">        print(&quot;\(num)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tst = Test()</span><br><span class="line"></span><br><span class="line">tst.fuction()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="getter-setter-（计算属性）"><a href="#getter-setter-（计算属性）" class="headerlink" title="getter - setter （计算属性）"></a>getter - setter （计算属性）</h4><p>与 OC 不同，Swift的getter和setter是 计算属性 ， 计算属性并不会存储属性的值。因此在每次调用计算属性时，都要计算该值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">    </span><br><span class="line">    var calNum = 0</span><br><span class="line">    var curNum: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return calNum</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            calNum = newValue</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tst = Test()</span><br><span class="line">tst.curNum = 1</span><br><span class="line">print(&quot;\(tst.curNum)&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>计算属性总是需要一个 getter。如果缺少 setter，则该属性被称为只读属性。</p>
</blockquote>
<h4 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h4><p>属性观察者会观察并对属性值的变化做出回应。每当一个属性的值被设置时，属性观察者都会被调用，即使这个值与该属性当前的值相同。</p>
<ul>
<li>willSet 会在改值被存储之前被调用</li>
<li>didSet 会在新值被存储后被调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    </span><br><span class="line">    var curNum: Int = 0 &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;newValue : \(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;oldValue : \(oldValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tst = Test()</span><br><span class="line">tst.curNum = 100</span><br><span class="line">print(&quot;\(tst.curNum)&quot;)</span><br><span class="line"></span><br><span class="line">// newValue : 100</span><br><span class="line">// oldValue : 0</span><br><span class="line">// 100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个类可以从另一个类继承方法、属性和其他的特性。当一个类从另一个类继承的时候，继承的类就是所谓的子类，而这个类继承的类被称为父类。</p>
<p>在 Swift 中类可以调用和访问属于它们父类的方法、属性和下标脚本，并且可以提供它们自己重写的方法，属性和下标脚本来定义或修改它们的行为。Swift 会通过检查重写定义都有一个与之匹配的父类定义来确保你的重写是正确的。</p>
<p>类也可以向继承的属性添加属性观察器，以便在属性的值改变时得到通知。可以添加任何属性监视到属性中，不管它是被定义为存储还是计算属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class SomeSubclass: SomeSuperclass &#123;</span><br><span class="line">    // subclass definition goes here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="重写-overide"><a href="#重写-overide" class="headerlink" title="重写 overide"></a>重写 overide</h3><p>override 关键字会执行 Swift 编译器检查你重写的类的父类(或者父类的父类)是否有与之匹配的声明来供你重写。这个检查确保你重写的定义是正确的。</p>
<h3 id="阻止重写-final"><a href="#阻止重写-final" class="headerlink" title="阻止重写 final"></a>阻止重写 final</h3><p>你可以通过标记为终点来阻止一个方法、属性或者下标脚本被重写。通过在方法、属性或者下标脚本的关键字前写 final 修饰符(比如 final var ， final func ， final class func ， final subscript )。</p>
<h2 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是为类、结构体或者枚举准备实例的过程。这个过需要给实例里的每一个存储属性设置一个初始值并且在新实例可以使用之前执行任何其他所必须的配置或初始化。</p>
<h3 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h3><p>初始化器在创建特定类型的实例时被调用。在这个简单的形式中，初始化器就像一个没有形式参数的实例方法，使用 init 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var test: Int</span><br><span class="line">init() &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    test = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="convenience-遍历构造器"><a href="#convenience-遍历构造器" class="headerlink" title="convenience 遍历构造器"></a>convenience 遍历构造器</h3><p>使用convenience修饰的构造函数叫做便利构造函数</p>
<h3 id="required-必要初始化器"><a href="#required-必要初始化器" class="headerlink" title="required 必要初始化器"></a>required 必要初始化器</h3><p>在类的初始化器前添加 required  修饰符来表明所有该类的子类都必须实现该初始化器</p>
<blockquote>
<p>当子类重写父类的必要初始化器时，必须在子类的初始化器前同样添加 required 修饰符以确保当其它类继承该子类时，该初始化器同为必要初始化器。在重写父类的必要初始化器时，不需要添加 override 修饰符</p>
</blockquote>
<h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p>Swift 的类初始化是一个两段式过程。在第一个阶段，每一个存储属性被引入类为分配了一个初始值。一旦每个存储属性的初始状态被确定，第二个阶段就开始了，每个类都有机会在新的实例准备使用之前来定制它的存储属性。</p>
<p>两段式初始化过程的使用让初始化更加安全，同时在每个类的层级结构给与了完备的灵活性。两段式初始化过程可以防止属性值在初始化之前被访问，还可以防止属性值被另一个初始化器意外地赋予不同的值。</p>
<h3 id="初始化器的自动继承"><a href="#初始化器的自动继承" class="headerlink" title="初始化器的自动继承"></a>初始化器的自动继承</h3><p>子类默认不会继承父类初始化器。但是在特定的情况下父类初始化器是可以被自动继承的</p>
<ul>
<li>如果你的子类没有定义任何指定初始化器，它会自动继承父类所有的指定初始化器。</li>
<li>如果你的子类提供了所有父类指定初始化器的实现——要么是通过规则1继承来的，要么通过在定义中提供自定义实现的——那么它自动继承所有的父类便捷初始化器。</li>
</ul>
<h3 id="反初始化"><a href="#反初始化" class="headerlink" title="反初始化"></a>反初始化</h3><p>在类实例被释放的时候，反初始化器就会立即被调用。你可以是用 deinit 关键字来写反初始化器，就如同写初始化器要用 init 关键字一样。反初始化器只在类类型中有效.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">deinit &#123;</span><br><span class="line">    // perform the deinitialization</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h2><p>Swift 使用自动引用计数(ARC)机制来追踪和管理你的 App 的内存。 这点上，Swift 和 OC 非常相似。</p>
<blockquote>
<p>引用计数只应用于类的实例。结构体和枚举是值类型，不是引用类型，没有通过引用存储和传递。</p>
</blockquote>
<h3 id="循环强引用"><a href="#循环强引用" class="headerlink" title="循环强引用"></a>循环强引用</h3><p>因为可能导致，两个类实例互相强引用的情况，这样的话，两个对象的引用计数就永远不能为0，也就是说对象不会被销毁，内存不能释放。这种情况被称为 <strong>循环强引用</strong>。</p>
<p>而解决方法就是打断这个引用链，使用 ”weak“ 修饰其中某条引用即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test()&#123; [weak self] in </span><br><span class="line">		guard let self = self else &#123; return &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>[weak self]</code> 等同于 <code>__weak typeof(self) weak_self = self;</code></p>
<p> <code>let self = self</code> 等同于 <code>__typeof__(self) strong_self = weak_self;</code></p>
</blockquote>
<h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><p>可选链是一个调用和查询可选属性、方法和下标的过程，它可能为 nil 。如果可选项包含值，属性、方法或者下标的调用成功；如果可选项是 nil ，属性、方法或者下标的调用会返回 nil 。多个查询可以链接在一起，如果链中任何一个节点是 nil ，那么整个链就会得体地失败。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换可以判断实例的类型，也可以将该实例在其所在的类层次中视为其父类或子类的实例。Swift 中类型转换的实现为 is 和 as 操作符.</p>
<h3 id="类型检查-is"><a href="#类型检查-is" class="headerlink" title="类型检查 is"></a>类型检查 is</h3><p>使用类型检查操作符 （ is ）来检查一个实例是否属于一个特定的子类。如果实例是该子类类型，类型检查操作符返回 true ，否则返回 false </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var num:String = &quot;0&quot;</span><br><span class="line"></span><br><span class="line">if num is String &#123;</span><br><span class="line">	print(&quot;right&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// right</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="向下类型转换-as"><a href="#向下类型转换-as" class="headerlink" title="向下类型转换 as"></a>向下类型转换 as</h3><p>由于向下类型转换能失败，类型转换操作符就有了两个不同形式。条件形式， as? ，返回了一个你将要向下类型转换的值的可选项。强制形式， as! ，则将向下类型转换和强制展开结合为一个步骤。</p>
<h3 id="Any-和-AnyObject"><a href="#Any-和-AnyObject" class="headerlink" title="Any 和 AnyObject"></a>Any 和 AnyObject</h3><ul>
<li>AnyObject  可以表示任何类类型的实例。</li>
<li>Any  可以表示任何类型，包括函数类型。</li>
</ul>
<blockquote>
<p>Any类型表示了任意类型的值，包括可选类型。如果你给显式声明的Any类型使用可选项，Swift 就会发出警告。</p>
</blockquote>
<h2 id="内嵌类型"><a href="#内嵌类型" class="headerlink" title="内嵌类型"></a>内嵌类型</h2><p>若要在一种类型中嵌套另一种类型，在其支持类型的大括号内定义即可。可以根据需求多级嵌套数个类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">	enum typeNum &#123;</span><br><span class="line">		case : one</span><br><span class="line">		case : two</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let value = Test.typeNum.one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>功能与 OC 中的分类差不多，但是不会像 分类 一样有一个命名</p>
<blockquote>
<p>扩展可以向一个类型添加新的方法，但是不能重写已有的方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extension SomeClass &#123;</span><br><span class="line">	// add new methods</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扩展还可以添加 计算属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extension SomeClass &#123;</span><br><span class="line">	</span><br><span class="line">	var height: Int &#123;</span><br><span class="line">		return 100</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	var width: Int &#123;</span><br><span class="line">		return 200</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展可以添加新的计算属性，但是不能添加存储属性，也不能向已有的属性添加属性观察者。</p>
</blockquote>
<h3 id="异变实例方法-mutating"><a href="#异变实例方法-mutating" class="headerlink" title="异变实例方法 mutating"></a>异变实例方法 mutating</h3><p>增加了扩展的实例方法仍可以修改（或异变）实例本身。结构体和枚举类型方法在修改 self 或本身的属性时必须标记实例方法为 mutating ，和原本实现的异变方法一样。</p>
<p>Swift中protocol的功能比OC中强大很多，不仅能再class中实现，同时也适用于struct、enum。但是struct、enum都是值类型，每个值都是有默认的，所以在实例方法中不能改变，因此就要用mutating关键字，这个关键字可以让在此方法中值的改变，会返回到原始结构里边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extension Int &#123;</span><br><span class="line">	</span><br><span class="line">	mutating func add() &#123;</span><br><span class="line">		self = self + self</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var num = 1</span><br><span class="line"></span><br><span class="line">num.add() // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="协议-protocol"><a href="#协议-protocol" class="headerlink" title="协议 protocol"></a>协议 protocol</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protocol SomeName &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>协议可以要求所有遵循该协议的类型提供特定名字和类型的实例属性或类型属性。协议并不会具体说明属性是储存型属性还是计算型属性——它只具体要求属性有特定的名称和类型。协议同时要求一个属性必须明确是可读的或可读的和可写的。</p>
<p>属性要求定义为变量属性，在名称前面使用 var 关键字。可读写的属性使用 { get set } 来写在声明后面来明确，使用 { get } 来明确可读的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    var num: Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Test: SomeProtocl &#123;</span><br><span class="line">	var num: Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异变方法-mutating"><a href="#异变方法-mutating" class="headerlink" title="异变方法 mutating"></a>异变方法 mutating</h3><p>有时一个方法需要改变（或异变）其所属的实例。例如值类型的实例方法（即结构体或枚举），在方法的 func 关键字之前使用 mutating 关键字，来表示在该方法可以改变其所属的实例，以及该实例的所有属性。</p>
<p>在TestPro协议的定义中， test() 方法使用 mutating 关键字标记，来表明该方法在调用时会改变遵循该协议的实例的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protocol TestPro &#123;</span><br><span class="line">    mutating func test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><p>协议可以要求遵循协议的类型实现指定的初始化器。和一般的初始化器一样，只用将初始化器写在协议的定义当中，只是不用写大括号也就是初始化器的实体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init(someParameter: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="将协议作为类型"><a href="#将协议作为类型" class="headerlink" title="将协议作为类型"></a>将协议作为类型</h3><p>实际上协议自身并不实现功能。不过你创建的任意协议都可以变为一个功能完备的类型在代码中使用。</p>
<ul>
<li>在函数、方法或者初始化器里作为形式参数类型或者返回类型；</li>
<li>作为常量、变量或者属性的类型；</li>
<li>作为数组、字典或者其他存储器的元素的类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line"></span><br><span class="line">	var item: SomeProtocol</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// item 的类型是 协议SomeProtocol，这样所有实现了SomeProtocol协议 的类的实例都可以赋值 item</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托是一个允许类或者结构体放手（或者说委托）它们自身的某些责任给另外类型实例的设计模式。这个设计模式通过定义一个封装了委托责任的协议来实现，比如遵循了协议的类型（所谓的委托）来保证提供被委托的功能。委托可以用来响应一个特定的行为，或者从外部资源取回数据而不需要了解资源具体的类型。</p>
<p>效果等同于 OC 中的代理</p>
<h3 id="类专用的协议"><a href="#类专用的协议" class="headerlink" title="类专用的协议"></a>类专用的协议</h3><p>通过添加 AnyObject 关键字到协议的继承列表，你就可以限制协议只能被类类型采纳（并且不是结构体或者枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protocol SomeClassOnlyProtocol: AnyObject,SomeInheritedProtocol &#123;</span><br><span class="line">    // class-only protocol definition goes here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="可选协议-optional"><a href="#可选协议-optional" class="headerlink" title="可选协议 optional"></a>可选协议 optional</h3><p>可选要求使用 optional 修饰符作为前缀放在协议的定义中。可选要求允许你的代码与 Objective-C 操作。协议和可选要求必须使用 @objc 标志标记。注意 @objc 协议只能被继承自 Objective-C 类或其他 @objc 类采纳。它们不能被结构体或者枚举采纳</p>
<h3 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h3><p>你可以使用协议扩展来给协议的任意方法或者计算属性要求提供默认实现。如果遵循类型给这个协议的要求提供了它自己的实现，那么它就会替代扩展中提供的默认实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extension PrettyTextRepresentable  &#123;</span><br><span class="line">    var prettyTextualDescription: String &#123;</span><br><span class="line">        return textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h3><p>Swift 中对于 Protocol 的功能进行了极大的加强。一定程度上能替代 抽象类 的左右。所以推荐使用 Protocol 来代替抽象类。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型代码让你能根据你所定义的要求写出可以用于任何类型的灵活的、可复用的函数。你可以编写出可复用、意图表达清晰、抽象的代码。</p>
<p>比如：Array 、 Dictionary就支持泛型(<code>Array&lt;T&gt;</code>)</p>
<h2 id="内存安全性"><a href="#内存安全性" class="headerlink" title="内存安全性"></a>内存安全性</h2><p>默认情况下，Swift 会阻止你代码中发生的不安全行为。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>访问控制限制其他源文件和模块对你的代码的访问。这个特性允许你隐藏代码的实现细节，并指定一个偏好的接口让其他代码可以访问和使用。</p>
<ul>
<li>Open 访问 和 public 访问 允许实体被定义模块中的任意源文件访问，同样可以被另一模块的源文件通过导入该定义模块来访问。在指定框架的公共接口时，通常使用 open 或 public 访问。 open 和 public 访问 之间的区别将在之后给出；</li>
<li>Internal 访问 允许实体被定义模块中的任意源文件访问，但不能被该模块之外的任何源文件访问。通常在定义应用程序或是框架的内部结构时使用。</li>
<li>File-private 访问 将实体的使用限制于当前定义源文件中。当一些细节在整个文件中使用时，使用 file-private 访问隐藏特定功能的实现细节。</li>
<li>private 访问 将实体的使用限制于封闭声明中。当一些细节仅在单独的声明中使用时，使用 private 访问隐藏特定功能的实现细节。</li>
</ul>
<blockquote>
<p>元组类型的访问级别是所有类型里最严格的。例如，如果你将两个不同类型的元素组成一个元组，一个元素的访问级别是 internal，另一个是 private，那么这个元组类型是 private 级别的。</p>
</blockquote>
<h2 id="高级运算符"><a href="#高级运算符" class="headerlink" title="高级运算符"></a>高级运算符</h2><h3 id="取反-运算符"><a href="#取反-运算符" class="headerlink" title="取反 运算符 ~"></a>取反 运算符 ~</h3><p>位取反运算符（ ~ ）是对所有位的数字进行取反操作：</p>
<p><img src="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseNOT_2x.png"></p>
<h3 id="与-运算符-amp"><a href="#与-运算符-amp" class="headerlink" title="与 运算符 &amp;"></a>与 运算符 &amp;</h3><p>位与运算符（ &amp; ）可以对两个数的比特位进行合并。它会返回一个新的数，只有当这两个数都是 1 的时候才能返回 1 </p>
<p><img src="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseAND_2x.png"></p>
<h3 id="或-运算符"><a href="#或-运算符" class="headerlink" title="或 运算符"></a>或 运算符</h3><p>位或运算符（ | ）可以对两个比特位进行比较，然后返回一个新的数，只要两个操作位任意一个为 1 时，那么对应的位数就为 1 ：</p>
<p><img src="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseOR_2x.png"></p>
<h3 id="异或-运算符"><a href="#异或-运算符" class="headerlink" title="异或 运算符 ^"></a>异或 运算符 ^</h3><p>位异或运算符，或者说“互斥或”（ ^ ）可以对两个数的比特位进行比较。它返回一个新的数，当两个操作数的对应位不相同时，该数的对应位就为 1 ：</p>
<p><img src="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitwiseXOR_2x.png"></p>
<h3 id="左移-和-右移运算符-lt-lt-gt-gt"><a href="#左移-和-右移运算符-lt-lt-gt-gt" class="headerlink" title="左移 和 右移运算符 &lt;&lt; &gt;&gt;"></a>左移 和 右移运算符 &lt;&lt; &gt;&gt;</h3><p>位左移运算符（ &lt;&lt; ）和位右移运算符（ &gt;&gt; ）可以把所有位数的数字向左或向右移动一个确定的位数，但是需要遵守下面定义的规则。</p>
<p>位左和右移具有给整数乘以或除以二的效果。将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。</p>
<p>例如：11111111 &lt;&lt; 1 和 11111111 &gt;&gt; 1 </p>
<p><img src="https://cnswift.content-delivery.top/wp-content/uploads/2015/08/bitshiftUnsigned_2x.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var num = 2</span><br><span class="line">print(&quot;\(num &lt;&lt; 1)&quot;) // 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>Swift 为 KVO 增加了方便好用的闭包API。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个NSKeyValueObservation类型的值</span><br><span class="line">var observation: NSKeyValueObservation?</span><br><span class="line">// 对webView添加监听，监听estimatedProgress属性</span><br><span class="line">observation = webView.observe(\WKWebView.estimatedProgress, options: .new) &#123; [weak self] (wkwebview, change) in</span><br><span class="line">            </span><br><span class="line">            guard let self = self else &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            print(&quot;已经加载 \(change.newValue! * 100)%&quot;)</span><br><span class="line">            self.progressview.progress = Float(wkwebview.estimatedProgress)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Codable"><a href="#Codable" class="headerlink" title="Codable"></a>Codable</h2><p>Swift4之后则拥有Codable来直接编码或者解码JSON。</p>
<p><code>public typealias Codable = Decodable &amp; Encodable</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 设置CityInfo遵循Decodable解码协议</span><br><span class="line">struct CityInfo: Decodable &#123;</span><br><span class="line">// 变量和JSON里面的key也必须是一致的</span><br><span class="line">    var city: String</span><br><span class="line">    var citykey: Int</span><br><span class="line">    var parent: String</span><br><span class="line">    var updateTime: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解码JSON对象data, 将其转化成CityInfo对象</span><br><span class="line">guard let jsonModel = try? JSONDecoder().decode(CityInfo.self, from: data!) else &#123;</span><br><span class="line">      fatalError(&quot;`JSON Decode Failed`&quot;)</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">print(&quot;data: \(jsonModel)&quot;)</span><br></pre></td></tr></table></figure></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/iOS/">iOS</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/06/17/Go-note/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Go 笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/01/30/HowToLearniOSBase/"><span class="level-item">iOS-学习基础和文章推荐</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="SeaBrea"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SeaBrea</p><p class="is-size-6 is-block">记录生活，记录学习</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">43</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">25</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seabrea" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seabrea"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Backend/"><span class="level-start"><span class="level-item">Backend</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Daily/"><span class="level-start"><span class="level-item">Daily</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Mobile/"><span class="level-start"><span class="level-item">Mobile</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-27T00:00:00.000Z">2021-10-27</time></p><p class="title"><a href="/2021/10/27/ReactRouter/">Router 路由</a></p><p class="categories"><a href="/categories/Web/">Web</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-27T00:00:00.000Z">2021-06-27</time></p><p class="title"><a href="/2021/06/27/ShellScript/">Shell Script</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-14T16:00:00.000Z">2021-01-15</time></p><p class="title"><a href="/2021/01/15/web_base/">Web基础</a></p><p class="categories"><a href="/categories/Web/">Web</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-14T16:00:00.000Z">2020-12-15</time></p><p class="title"><a href="/2020/12/15/FlutterBase/">Flutter基础</a></p><p class="categories"><a href="/categories/Mobile/">Mobile</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-23T16:00:00.000Z">2020-11-24</time></p><p class="title"><a href="/2020/11/24/Network/">计算机网络</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">June 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">March 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">January 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">December 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">September 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">April 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/11/"><span class="level-start"><span class="level-item">November 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">March 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">February 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MD5/"><span class="tag">MD5</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Network/"><span class="tag">Network</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UI/"><span class="tag">UI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flutter/"><span class="tag">flutter</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zsh/"><span class="tag">zsh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="tag">二进制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"><span class="tag">位运算</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"><span class="tag">字符编码</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="tag">正则表达式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83/"><span class="tag">知识产权</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%8F%E6%B5%8E/"><span class="tag">经济</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E4%B8%BB%E5%AD%A6%E4%B9%A0/"><span class="tag">自主学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"><span class="tag">计算机原理</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="BLOG" height="28"></a><p class="is-size-7"><span>&copy; 2022 Sea Brea</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>